/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/easymde";
exports.ids = ["vendor-chunks/easymde"];
exports.modules = {

/***/ "(ssr)/./node_modules/easymde/src/js/codemirror/tablist.js":
/*!***********************************************************!*\
  !*** ./node_modules/easymde/src/js/codemirror/tablist.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\nvar CodeMirror = __webpack_require__(/*! codemirror */ \"(ssr)/./node_modules/codemirror/lib/codemirror.js\");\n\nCodeMirror.commands.tabAndIndentMarkdownList = function (cm) {\n    var ranges = cm.listSelections();\n    var pos = ranges[0].head;\n    var eolState = cm.getStateAfter(pos.line);\n    var inList = eolState.list !== false;\n\n    if (inList) {\n        cm.execCommand('indentMore');\n        return;\n    }\n\n    if (cm.options.indentWithTabs) {\n        cm.execCommand('insertTab');\n    } else {\n        var spaces = Array(cm.options.tabSize + 1).join(' ');\n        cm.replaceSelection(spaces);\n    }\n};\n\nCodeMirror.commands.shiftTabAndUnindentMarkdownList = function (cm) {\n    var ranges = cm.listSelections();\n    var pos = ranges[0].head;\n    var eolState = cm.getStateAfter(pos.line);\n    var inList = eolState.list !== false;\n\n    if (inList) {\n        cm.execCommand('indentLess');\n        return;\n    }\n\n    if (cm.options.indentWithTabs) {\n        cm.execCommand('insertTab');\n    } else {\n        var spaces = Array(cm.options.tabSize + 1).join(' ');\n        cm.replaceSelection(spaces);\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWFzeW1kZS9zcmMvanMvY29kZW1pcnJvci90YWJsaXN0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMscUVBQVk7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWFzeW1kZS9zcmMvanMvY29kZW1pcnJvci90YWJsaXN0LmpzP2YwOTMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG52YXIgQ29kZU1pcnJvciA9IHJlcXVpcmUoJ2NvZGVtaXJyb3InKTtcblxuQ29kZU1pcnJvci5jb21tYW5kcy50YWJBbmRJbmRlbnRNYXJrZG93bkxpc3QgPSBmdW5jdGlvbiAoY20pIHtcbiAgICB2YXIgcmFuZ2VzID0gY20ubGlzdFNlbGVjdGlvbnMoKTtcbiAgICB2YXIgcG9zID0gcmFuZ2VzWzBdLmhlYWQ7XG4gICAgdmFyIGVvbFN0YXRlID0gY20uZ2V0U3RhdGVBZnRlcihwb3MubGluZSk7XG4gICAgdmFyIGluTGlzdCA9IGVvbFN0YXRlLmxpc3QgIT09IGZhbHNlO1xuXG4gICAgaWYgKGluTGlzdCkge1xuICAgICAgICBjbS5leGVjQ29tbWFuZCgnaW5kZW50TW9yZScpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNtLm9wdGlvbnMuaW5kZW50V2l0aFRhYnMpIHtcbiAgICAgICAgY20uZXhlY0NvbW1hbmQoJ2luc2VydFRhYicpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzcGFjZXMgPSBBcnJheShjbS5vcHRpb25zLnRhYlNpemUgKyAxKS5qb2luKCcgJyk7XG4gICAgICAgIGNtLnJlcGxhY2VTZWxlY3Rpb24oc3BhY2VzKTtcbiAgICB9XG59O1xuXG5Db2RlTWlycm9yLmNvbW1hbmRzLnNoaWZ0VGFiQW5kVW5pbmRlbnRNYXJrZG93bkxpc3QgPSBmdW5jdGlvbiAoY20pIHtcbiAgICB2YXIgcmFuZ2VzID0gY20ubGlzdFNlbGVjdGlvbnMoKTtcbiAgICB2YXIgcG9zID0gcmFuZ2VzWzBdLmhlYWQ7XG4gICAgdmFyIGVvbFN0YXRlID0gY20uZ2V0U3RhdGVBZnRlcihwb3MubGluZSk7XG4gICAgdmFyIGluTGlzdCA9IGVvbFN0YXRlLmxpc3QgIT09IGZhbHNlO1xuXG4gICAgaWYgKGluTGlzdCkge1xuICAgICAgICBjbS5leGVjQ29tbWFuZCgnaW5kZW50TGVzcycpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNtLm9wdGlvbnMuaW5kZW50V2l0aFRhYnMpIHtcbiAgICAgICAgY20uZXhlY0NvbW1hbmQoJ2luc2VydFRhYicpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzcGFjZXMgPSBBcnJheShjbS5vcHRpb25zLnRhYlNpemUgKyAxKS5qb2luKCcgJyk7XG4gICAgICAgIGNtLnJlcGxhY2VTZWxlY3Rpb24oc3BhY2VzKTtcbiAgICB9XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/easymde/src/js/codemirror/tablist.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/easymde/src/js/easymde.js":
/*!************************************************!*\
  !*** ./node_modules/easymde/src/js/easymde.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar CodeMirror = __webpack_require__(/*! codemirror */ \"(ssr)/./node_modules/codemirror/lib/codemirror.js\");\n__webpack_require__(/*! codemirror/addon/edit/continuelist.js */ \"(ssr)/./node_modules/codemirror/addon/edit/continuelist.js\");\n__webpack_require__(/*! ./codemirror/tablist */ \"(ssr)/./node_modules/easymde/src/js/codemirror/tablist.js\");\n__webpack_require__(/*! codemirror/addon/display/fullscreen.js */ \"(ssr)/./node_modules/codemirror/addon/display/fullscreen.js\");\n__webpack_require__(/*! codemirror/mode/markdown/markdown.js */ \"(ssr)/./node_modules/codemirror/mode/markdown/markdown.js\");\n__webpack_require__(/*! codemirror/addon/mode/overlay.js */ \"(ssr)/./node_modules/codemirror/addon/mode/overlay.js\");\n__webpack_require__(/*! codemirror/addon/display/placeholder.js */ \"(ssr)/./node_modules/codemirror/addon/display/placeholder.js\");\n__webpack_require__(/*! codemirror/addon/display/autorefresh.js */ \"(ssr)/./node_modules/codemirror/addon/display/autorefresh.js\");\n__webpack_require__(/*! codemirror/addon/selection/mark-selection.js */ \"(ssr)/./node_modules/codemirror/addon/selection/mark-selection.js\");\n__webpack_require__(/*! codemirror/addon/search/searchcursor.js */ \"(ssr)/./node_modules/codemirror/addon/search/searchcursor.js\");\n__webpack_require__(/*! codemirror/mode/gfm/gfm.js */ \"(ssr)/./node_modules/codemirror/mode/gfm/gfm.js\");\n__webpack_require__(/*! codemirror/mode/xml/xml.js */ \"(ssr)/./node_modules/codemirror/mode/xml/xml.js\");\nvar CodeMirrorSpellChecker = __webpack_require__(/*! codemirror-spell-checker */ \"(ssr)/./node_modules/codemirror-spell-checker/src/js/spell-checker.js\");\nvar marked = (__webpack_require__(/*! marked */ \"(ssr)/./node_modules/marked/lib/marked.cjs\").marked);\n\n\n// Some variables\nvar isMac = /Mac/.test(navigator.platform);\nvar anchorToExternalRegex = new RegExp(/(<a.*?https?:\\/\\/.*?[^a]>)+?/g);\n\n// Mapping of actions that can be bound to keyboard shortcuts or toolbar buttons\nvar bindings = {\n    'toggleBold': toggleBold,\n    'toggleItalic': toggleItalic,\n    'drawLink': drawLink,\n    'toggleHeadingSmaller': toggleHeadingSmaller,\n    'toggleHeadingBigger': toggleHeadingBigger,\n    'drawImage': drawImage,\n    'toggleBlockquote': toggleBlockquote,\n    'toggleOrderedList': toggleOrderedList,\n    'toggleUnorderedList': toggleUnorderedList,\n    'toggleCodeBlock': toggleCodeBlock,\n    'togglePreview': togglePreview,\n    'toggleStrikethrough': toggleStrikethrough,\n    'toggleHeading1': toggleHeading1,\n    'toggleHeading2': toggleHeading2,\n    'toggleHeading3': toggleHeading3,\n    'toggleHeading4': toggleHeading4,\n    'toggleHeading5': toggleHeading5,\n    'toggleHeading6': toggleHeading6,\n    'cleanBlock': cleanBlock,\n    'drawTable': drawTable,\n    'drawHorizontalRule': drawHorizontalRule,\n    'undo': undo,\n    'redo': redo,\n    'toggleSideBySide': toggleSideBySide,\n    'toggleFullScreen': toggleFullScreen,\n};\n\nvar shortcuts = {\n    'toggleBold': 'Cmd-B',\n    'toggleItalic': 'Cmd-I',\n    'drawLink': 'Cmd-K',\n    'toggleHeadingSmaller': 'Cmd-H',\n    'toggleHeadingBigger': 'Shift-Cmd-H',\n    'toggleHeading1': 'Ctrl+Alt+1',\n    'toggleHeading2': 'Ctrl+Alt+2',\n    'toggleHeading3': 'Ctrl+Alt+3',\n    'toggleHeading4': 'Ctrl+Alt+4',\n    'toggleHeading5': 'Ctrl+Alt+5',\n    'toggleHeading6': 'Ctrl+Alt+6',\n    'cleanBlock': 'Cmd-E',\n    'drawImage': 'Cmd-Alt-I',\n    'toggleBlockquote': 'Cmd-\\'',\n    'toggleOrderedList': 'Cmd-Alt-L',\n    'toggleUnorderedList': 'Cmd-L',\n    'toggleCodeBlock': 'Cmd-Alt-C',\n    'togglePreview': 'Cmd-P',\n    'toggleSideBySide': 'F9',\n    'toggleFullScreen': 'F11',\n};\n\nvar getBindingName = function (f) {\n    for (var key in bindings) {\n        if (bindings[key] === f) {\n            return key;\n        }\n    }\n    return null;\n};\n\nvar isMobile = function () {\n    var check = false;\n    (function (a) {\n        if (/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(a.substr(0, 4))) check = true;\n    })(navigator.userAgent || navigator.vendor || window.opera);\n    return check;\n};\n\n/**\n * Modify HTML to add 'target=\"_blank\"' to links so they open in new tabs by default.\n * @param {string} htmlText - HTML to be modified.\n * @return {string} The modified HTML text.\n */\nfunction addAnchorTargetBlank(htmlText) {\n    var match;\n    while ((match = anchorToExternalRegex.exec(htmlText)) !== null) {\n        // With only one capture group in the RegExp, we can safely take the first index from the match.\n        var linkString = match[0];\n\n        if (linkString.indexOf('target=') === -1) {\n            var fixedLinkString = linkString.replace(/>$/, ' target=\"_blank\">');\n            htmlText = htmlText.replace(linkString, fixedLinkString);\n        }\n    }\n    return htmlText;\n}\n\n/**\n * Modify HTML to remove the list-style when rendering checkboxes.\n * @param {string} htmlText - HTML to be modified.\n * @return {string} The modified HTML text.\n */\nfunction removeListStyleWhenCheckbox(htmlText) {\n\n    var parser = new DOMParser();\n    var htmlDoc = parser.parseFromString(htmlText, 'text/html');\n    var listItems = htmlDoc.getElementsByTagName('li');\n\n    for (var i = 0; i < listItems.length; i++) {\n        var listItem = listItems[i];\n\n        for (var j = 0; j < listItem.children.length; j++) {\n            var listItemChild = listItem.children[j];\n\n            if (listItemChild instanceof HTMLInputElement && listItemChild.type === 'checkbox') {\n                // From Github: margin: 0 .2em .25em -1.6em;\n                listItem.style.marginLeft = '-1.5em';\n                listItem.style.listStyleType = 'none';\n            }\n        }\n    }\n\n    return htmlDoc.documentElement.innerHTML;\n}\n\n/**\n * Fix shortcut. Mac use Command, others use Ctrl.\n */\nfunction fixShortcut(name) {\n    if (isMac) {\n        name = name.replace('Ctrl', 'Cmd');\n    } else {\n        name = name.replace('Cmd', 'Ctrl');\n    }\n    return name;\n}\n\n/**\n * Create dropdown block\n */\nfunction createToolbarDropdown(options, enableTooltips, shortcuts, parent) {\n    var el = createToolbarButton(options, false, enableTooltips, shortcuts, 'button', parent);\n    el.classList.add('easymde-dropdown');\n\n    el.onclick = function () {\n        el.focus();\n    };\n\n    var content = document.createElement('div');\n    content.className = 'easymde-dropdown-content';\n    for (var childrenIndex = 0; childrenIndex < options.children.length; childrenIndex++) {\n\n        var child = options.children[childrenIndex];\n        var childElement;\n\n        if (typeof child === 'string' && child in toolbarBuiltInButtons) {\n            childElement = createToolbarButton(toolbarBuiltInButtons[child], true, enableTooltips, shortcuts, 'button', parent);\n        } else {\n            childElement = createToolbarButton(child, true, enableTooltips, shortcuts, 'button', parent);\n        }\n\n        childElement.addEventListener('click', function (e) { e.stopPropagation(); }, false);\n        content.appendChild(childElement);\n    }\n    el.appendChild(content);\n    return el;\n}\n\n/**\n * Create button element for toolbar.\n */\nfunction createToolbarButton(options, enableActions, enableTooltips, shortcuts, markup, parent) {\n    options = options || {};\n    var el = document.createElement(markup);\n\n    // Add 'custom' attributes as early as possible, so that 'official' attributes will never be overwritten.\n    if (options.attributes) {\n        for (var attribute in options.attributes) {\n            if (Object.prototype.hasOwnProperty.call(options.attributes, attribute)) {\n                el.setAttribute(attribute, options.attributes[attribute]);\n            }\n        }\n    }\n\n    var classNamePrefix = parent.options.toolbarButtonClassPrefix ? parent.options.toolbarButtonClassPrefix + '-' : '';\n    el.className = classNamePrefix + options.name;\n    el.setAttribute('type', markup);\n    enableTooltips = (enableTooltips == undefined) ? true : enableTooltips;\n\n    if (options.text) {\n        el.innerText = options.text;\n    }\n\n    // Properly handle custom shortcuts\n    if (options.name && options.name in shortcuts) {\n        bindings[options.name] = options.action;\n    }\n\n    if (options.title && enableTooltips) {\n        el.title = createTooltip(options.title, options.action, shortcuts);\n\n        if (isMac) {\n            el.title = el.title.replace('Ctrl', '⌘');\n            el.title = el.title.replace('Alt', '⌥');\n        }\n    }\n\n    if (options.title) {\n        el.setAttribute('aria-label', options.title);\n    }\n\n    if (options.noDisable) {\n        el.classList.add('no-disable');\n    }\n\n    if (options.noMobile) {\n        el.classList.add('no-mobile');\n    }\n\n    // Prevent errors if there is no class name in custom options\n    var classNameParts = [];\n    if (typeof options.className !== 'undefined') {\n        classNameParts = options.className.split(' ');\n    }\n\n    // Provide backwards compatibility with simple-markdown-editor by adding custom classes to the button.\n    var iconClasses = [];\n    for (var classNameIndex = 0; classNameIndex < classNameParts.length; classNameIndex++) {\n        var classNamePart = classNameParts[classNameIndex];\n        // Split icon classes from the button.\n        // Regex will detect \"fa\", \"fas\", \"fa-something\" and \"fa-some-icon-1\", but not \"fanfare\".\n        if (classNamePart.match(/^fa([srlb]|(-[\\w-]*)|$)/)) {\n            iconClasses.push(classNamePart);\n        } else {\n            el.classList.add(classNamePart);\n        }\n    }\n\n    el.tabIndex = -1;\n\n    if (iconClasses.length > 0) {\n        // Create icon element and append as a child to the button\n        var icon = document.createElement('i');\n        for (var iconClassIndex = 0; iconClassIndex < iconClasses.length; iconClassIndex++) {\n            var iconClass = iconClasses[iconClassIndex];\n            icon.classList.add(iconClass);\n        }\n        el.appendChild(icon);\n    }\n\n    // If there is a custom icon markup set, use that\n    if (typeof options.icon !== 'undefined') {\n        el.innerHTML = options.icon;\n    }\n\n    if (options.action && enableActions) {\n        if (typeof options.action === 'function') {\n            el.onclick = function (e) {\n                e.preventDefault();\n                options.action(parent);\n            };\n        } else if (typeof options.action === 'string') {\n            el.onclick = function (e) {\n                e.preventDefault();\n                window.open(options.action, '_blank');\n            };\n        }\n    }\n\n    return el;\n}\n\nfunction createSep() {\n    var el = document.createElement('i');\n    el.className = 'separator';\n    el.innerHTML = '|';\n    return el;\n}\n\nfunction createTooltip(title, action, shortcuts) {\n    var actionName;\n    var tooltip = title;\n\n    if (action) {\n        actionName = getBindingName(action);\n        if (shortcuts[actionName]) {\n            tooltip += ' (' + fixShortcut(shortcuts[actionName]) + ')';\n        }\n    }\n\n    return tooltip;\n}\n\n/**\n * The state of CodeMirror at the given position.\n */\nfunction getState(cm, pos) {\n    pos = pos || cm.getCursor('start');\n    var stat = cm.getTokenAt(pos);\n    if (!stat.type) return {};\n\n    var types = stat.type.split(' ');\n\n    var ret = {},\n        data, text;\n    for (var i = 0; i < types.length; i++) {\n        data = types[i];\n        if (data === 'strong') {\n            ret.bold = true;\n        } else if (data === 'variable-2') {\n            text = cm.getLine(pos.line);\n            if (/^\\s*\\d+\\.\\s/.test(text)) {\n                ret['ordered-list'] = true;\n            } else {\n                ret['unordered-list'] = true;\n            }\n        } else if (data === 'atom') {\n            ret.quote = true;\n        } else if (data === 'em') {\n            ret.italic = true;\n        } else if (data === 'quote') {\n            ret.quote = true;\n        } else if (data === 'strikethrough') {\n            ret.strikethrough = true;\n        } else if (data === 'comment') {\n            ret.code = true;\n        } else if (data === 'link' && !ret.image) {\n            ret.link = true;\n        } else if (data === 'image') {\n            ret.image = true;\n        } else if (data.match(/^header(-[1-6])?$/)) {\n            ret[data.replace('header', 'heading')] = true;\n        }\n    }\n    return ret;\n}\n\n\n// Saved overflow setting\nvar saved_overflow = '';\n\n/**\n * Toggle full screen of the editor.\n * @param {EasyMDE} editor\n */\nfunction toggleFullScreen(editor) {\n    // Set fullscreen\n    var cm = editor.codemirror;\n    cm.setOption('fullScreen', !cm.getOption('fullScreen'));\n\n\n    // Prevent scrolling on body during fullscreen active\n    if (cm.getOption('fullScreen')) {\n        saved_overflow = document.body.style.overflow;\n        document.body.style.overflow = 'hidden';\n    } else {\n        document.body.style.overflow = saved_overflow;\n    }\n\n    var wrapper = cm.getWrapperElement();\n    var sidebyside = wrapper.nextSibling;\n\n    if (sidebyside.classList.contains('editor-preview-active-side')) {\n        if (editor.options.sideBySideFullscreen === false) {\n            // if side-by-side not-fullscreen ok, apply classes as needed\n            var easyMDEContainer = wrapper.parentNode;\n            if (cm.getOption('fullScreen')) {\n                easyMDEContainer.classList.remove('sided--no-fullscreen');\n            } else {\n                easyMDEContainer.classList.add('sided--no-fullscreen');\n            }\n        } else {\n            toggleSideBySide(editor);\n        }\n    }\n\n    if (editor.options.onToggleFullScreen) {\n        editor.options.onToggleFullScreen(cm.getOption('fullScreen') || false);\n    }\n\n    // Remove or set maxHeight\n    if (typeof editor.options.maxHeight !== 'undefined') {\n        if (cm.getOption('fullScreen')) {\n            cm.getScrollerElement().style.removeProperty('height');\n            sidebyside.style.removeProperty('height');\n        } else {\n            cm.getScrollerElement().style.height = editor.options.maxHeight;\n            editor.setPreviewMaxHeight();\n        }\n    }\n\n    // Update toolbar class\n    editor.toolbar_div.classList.toggle('fullscreen');\n\n    // Update toolbar button\n    if (editor.toolbarElements && editor.toolbarElements.fullscreen) {\n        var toolbarButton = editor.toolbarElements.fullscreen;\n        toolbarButton.classList.toggle('active');\n    }\n}\n\n\n/**\n * Action for toggling bold.\n * @param {EasyMDE} editor\n */\nfunction toggleBold(editor) {\n    _toggleBlock(editor, 'bold', editor.options.blockStyles.bold);\n}\n\n\n/**\n * Action for toggling italic.\n * @param {EasyMDE} editor\n */\nfunction toggleItalic(editor) {\n    _toggleBlock(editor, 'italic', editor.options.blockStyles.italic);\n}\n\n\n/**\n * Action for toggling strikethrough.\n * @param {EasyMDE} editor\n */\nfunction toggleStrikethrough(editor) {\n    _toggleBlock(editor, 'strikethrough', '~~');\n}\n\n/**\n * Action for toggling code block.\n * @param {EasyMDE} editor\n */\nfunction toggleCodeBlock(editor) {\n    var fenceCharsToInsert = editor.options.blockStyles.code;\n\n    function fencing_line(line) {\n        /* return true, if this is a ``` or ~~~ line */\n        if (typeof line !== 'object') {\n            throw 'fencing_line() takes a \\'line\\' object (not a line number, or line text).  Got: ' + typeof line + ': ' + line;\n        }\n        return line.styles && line.styles[2] && line.styles[2].indexOf('formatting-code-block') !== -1;\n    }\n\n    function token_state(token) {\n        // base goes an extra level deep when mode backdrops are used, e.g. spellchecker on\n        return token.state.base.base || token.state.base;\n    }\n\n    function code_type(cm, line_num, line, firstTok, lastTok) {\n        /*\n         * Return \"single\", \"indented\", \"fenced\" or false\n         *\n         * cm and line_num are required.  Others are optional for efficiency\n         *   To check in the middle of a line, pass in firstTok yourself.\n         */\n        line = line || cm.getLineHandle(line_num);\n        firstTok = firstTok || cm.getTokenAt({\n            line: line_num,\n            ch: 1,\n        });\n        lastTok = lastTok || (!!line.text && cm.getTokenAt({\n            line: line_num,\n            ch: line.text.length - 1,\n        }));\n        var types = firstTok.type ? firstTok.type.split(' ') : [];\n        if (lastTok && token_state(lastTok).indentedCode) {\n            // have to check last char, since first chars of first line aren\"t marked as indented\n            return 'indented';\n        } else if (types.indexOf('comment') === -1) {\n            // has to be after \"indented\" check, since first chars of first indented line aren\"t marked as such\n            return false;\n        } else if (token_state(firstTok).fencedChars || token_state(lastTok).fencedChars || fencing_line(line)) {\n            return 'fenced';\n        } else {\n            return 'single';\n        }\n    }\n\n    function insertFencingAtSelection(cm, cur_start, cur_end, fenceCharsToInsert) {\n        var start_line_sel = cur_start.line + 1,\n            end_line_sel = cur_end.line + 1,\n            sel_multi = cur_start.line !== cur_end.line,\n            repl_start = fenceCharsToInsert + '\\n',\n            repl_end = '\\n' + fenceCharsToInsert;\n        if (sel_multi) {\n            end_line_sel++;\n        }\n        // handle last char including \\n or not\n        if (sel_multi && cur_end.ch === 0) {\n            repl_end = fenceCharsToInsert + '\\n';\n            end_line_sel--;\n        }\n        _replaceSelection(cm, false, [repl_start, repl_end]);\n        cm.setSelection({\n            line: start_line_sel,\n            ch: 0,\n        }, {\n            line: end_line_sel,\n            ch: 0,\n        });\n    }\n\n    var cm = editor.codemirror,\n        cur_start = cm.getCursor('start'),\n        cur_end = cm.getCursor('end'),\n        tok = cm.getTokenAt({\n            line: cur_start.line,\n            ch: cur_start.ch || 1,\n        }), // avoid ch 0 which is a cursor pos but not token\n        line = cm.getLineHandle(cur_start.line),\n        is_code = code_type(cm, cur_start.line, line, tok);\n    var block_start, block_end, lineCount;\n\n    if (is_code === 'single') {\n        // similar to some EasyMDE _toggleBlock logic\n        var start = line.text.slice(0, cur_start.ch).replace('`', ''),\n            end = line.text.slice(cur_start.ch).replace('`', '');\n        cm.replaceRange(start + end, {\n            line: cur_start.line,\n            ch: 0,\n        }, {\n            line: cur_start.line,\n            ch: 99999999999999,\n        });\n        cur_start.ch--;\n        if (cur_start !== cur_end) {\n            cur_end.ch--;\n        }\n        cm.setSelection(cur_start, cur_end);\n        cm.focus();\n    } else if (is_code === 'fenced') {\n        if (cur_start.line !== cur_end.line || cur_start.ch !== cur_end.ch) {\n            // use selection\n\n            // find the fenced line so we know what type it is (tilde, backticks, number of them)\n            for (block_start = cur_start.line; block_start >= 0; block_start--) {\n                line = cm.getLineHandle(block_start);\n                if (fencing_line(line)) {\n                    break;\n                }\n            }\n            var fencedTok = cm.getTokenAt({\n                line: block_start,\n                ch: 1,\n            });\n            var fence_chars = token_state(fencedTok).fencedChars;\n            var start_text, start_line;\n            var end_text, end_line;\n            // check for selection going up against fenced lines, in which case we don't want to add more fencing\n            if (fencing_line(cm.getLineHandle(cur_start.line))) {\n                start_text = '';\n                start_line = cur_start.line;\n            } else if (fencing_line(cm.getLineHandle(cur_start.line - 1))) {\n                start_text = '';\n                start_line = cur_start.line - 1;\n            } else {\n                start_text = fence_chars + '\\n';\n                start_line = cur_start.line;\n            }\n            if (fencing_line(cm.getLineHandle(cur_end.line))) {\n                end_text = '';\n                end_line = cur_end.line;\n                if (cur_end.ch === 0) {\n                    end_line += 1;\n                }\n            } else if (cur_end.ch !== 0 && fencing_line(cm.getLineHandle(cur_end.line + 1))) {\n                end_text = '';\n                end_line = cur_end.line + 1;\n            } else {\n                end_text = fence_chars + '\\n';\n                end_line = cur_end.line + 1;\n            }\n            if (cur_end.ch === 0) {\n                // full last line selected, putting cursor at beginning of next\n                end_line -= 1;\n            }\n            cm.operation(function () {\n                // end line first, so that line numbers don't change\n                cm.replaceRange(end_text, {\n                    line: end_line,\n                    ch: 0,\n                }, {\n                    line: end_line + (end_text ? 0 : 1),\n                    ch: 0,\n                });\n                cm.replaceRange(start_text, {\n                    line: start_line,\n                    ch: 0,\n                }, {\n                    line: start_line + (start_text ? 0 : 1),\n                    ch: 0,\n                });\n            });\n            cm.setSelection({\n                line: start_line + (start_text ? 1 : 0),\n                ch: 0,\n            }, {\n                line: end_line + (start_text ? 1 : -1),\n                ch: 0,\n            });\n            cm.focus();\n        } else {\n            // no selection, search for ends of this fenced block\n            var search_from = cur_start.line;\n            if (fencing_line(cm.getLineHandle(cur_start.line))) { // gets a little tricky if cursor is right on a fenced line\n                if (code_type(cm, cur_start.line + 1) === 'fenced') {\n                    block_start = cur_start.line;\n                    search_from = cur_start.line + 1; // for searching for \"end\"\n                } else {\n                    block_end = cur_start.line;\n                    search_from = cur_start.line - 1; // for searching for \"start\"\n                }\n            }\n            if (block_start === undefined) {\n                for (block_start = search_from; block_start >= 0; block_start--) {\n                    line = cm.getLineHandle(block_start);\n                    if (fencing_line(line)) {\n                        break;\n                    }\n                }\n            }\n            if (block_end === undefined) {\n                lineCount = cm.lineCount();\n                for (block_end = search_from; block_end < lineCount; block_end++) {\n                    line = cm.getLineHandle(block_end);\n                    if (fencing_line(line)) {\n                        break;\n                    }\n                }\n            }\n            cm.operation(function () {\n                cm.replaceRange('', {\n                    line: block_start,\n                    ch: 0,\n                }, {\n                    line: block_start + 1,\n                    ch: 0,\n                });\n                cm.replaceRange('', {\n                    line: block_end - 1,\n                    ch: 0,\n                }, {\n                    line: block_end,\n                    ch: 0,\n                });\n            });\n            cm.focus();\n        }\n    } else if (is_code === 'indented') {\n        if (cur_start.line !== cur_end.line || cur_start.ch !== cur_end.ch) {\n            // use selection\n            block_start = cur_start.line;\n            block_end = cur_end.line;\n            if (cur_end.ch === 0) {\n                block_end--;\n            }\n        } else {\n            // no selection, search for ends of this indented block\n            for (block_start = cur_start.line; block_start >= 0; block_start--) {\n                line = cm.getLineHandle(block_start);\n                if (line.text.match(/^\\s*$/)) {\n                    // empty or all whitespace - keep going\n                    continue;\n                } else {\n                    if (code_type(cm, block_start, line) !== 'indented') {\n                        block_start += 1;\n                        break;\n                    }\n                }\n            }\n            lineCount = cm.lineCount();\n            for (block_end = cur_start.line; block_end < lineCount; block_end++) {\n                line = cm.getLineHandle(block_end);\n                if (line.text.match(/^\\s*$/)) {\n                    // empty or all whitespace - keep going\n                    continue;\n                } else {\n                    if (code_type(cm, block_end, line) !== 'indented') {\n                        block_end -= 1;\n                        break;\n                    }\n                }\n            }\n        }\n        // if we are going to un-indent based on a selected set of lines, and the next line is indented too, we need to\n        // insert a blank line so that the next line(s) continue to be indented code\n        var next_line = cm.getLineHandle(block_end + 1),\n            next_line_last_tok = next_line && cm.getTokenAt({\n                line: block_end + 1,\n                ch: next_line.text.length - 1,\n            }),\n            next_line_indented = next_line_last_tok && token_state(next_line_last_tok).indentedCode;\n        if (next_line_indented) {\n            cm.replaceRange('\\n', {\n                line: block_end + 1,\n                ch: 0,\n            });\n        }\n\n        for (var i = block_start; i <= block_end; i++) {\n            cm.indentLine(i, 'subtract'); // TODO: this doesn't get tracked in the history, so can't be undone :(\n        }\n        cm.focus();\n    } else {\n        // insert code formatting\n        var no_sel_and_starting_of_line = (cur_start.line === cur_end.line && cur_start.ch === cur_end.ch && cur_start.ch === 0);\n        var sel_multi = cur_start.line !== cur_end.line;\n        if (no_sel_and_starting_of_line || sel_multi) {\n            insertFencingAtSelection(cm, cur_start, cur_end, fenceCharsToInsert);\n        } else {\n            _replaceSelection(cm, false, ['`', '`']);\n        }\n    }\n}\n\n/**\n * Action for toggling blockquote.\n */\nfunction toggleBlockquote(editor) {\n    _toggleLine(editor.codemirror, 'quote');\n}\n\n/**\n * Action for toggling heading size: normal -> h1 -> h2 -> h3 -> h4 -> h5 -> h6 -> normal\n */\nfunction toggleHeadingSmaller(editor) {\n    _toggleHeading(editor.codemirror, 'smaller');\n}\n\n/**\n * Action for toggling heading size: normal -> h6 -> h5 -> h4 -> h3 -> h2 -> h1 -> normal\n */\nfunction toggleHeadingBigger(editor) {\n    _toggleHeading(editor.codemirror, 'bigger');\n}\n\n/**\n * Action for toggling heading size 1\n */\nfunction toggleHeading1(editor) {\n    _toggleHeading(editor.codemirror, undefined, 1);\n}\n\n/**\n * Action for toggling heading size 2\n */\nfunction toggleHeading2(editor) {\n    _toggleHeading(editor.codemirror, undefined, 2);\n}\n\n/**\n * Action for toggling heading size 3\n */\nfunction toggleHeading3(editor) {\n    _toggleHeading(editor.codemirror, undefined, 3);\n}\n\n/**\n * Action for toggling heading size 4\n */\nfunction toggleHeading4(editor) {\n    _toggleHeading(editor.codemirror, undefined, 4);\n}\n\n/**\n * Action for toggling heading size 5\n */\nfunction toggleHeading5(editor) {\n    _toggleHeading(editor.codemirror, undefined, 5);\n}\n\n/**\n * Action for toggling heading size 6\n */\nfunction toggleHeading6(editor) {\n    _toggleHeading(editor.codemirror, undefined, 6);\n}\n\n\n/**\n * Action for toggling ul.\n */\nfunction toggleUnorderedList(editor) {\n    var cm = editor.codemirror;\n\n    var listStyle = '*'; // Default\n    if (['-', '+', '*'].includes(editor.options.unorderedListStyle)) {\n        listStyle = editor.options.unorderedListStyle;\n    }\n\n    _toggleLine(cm, 'unordered-list', listStyle);\n}\n\n\n/**\n * Action for toggling ol.\n */\nfunction toggleOrderedList(editor) {\n    _toggleLine(editor.codemirror, 'ordered-list');\n}\n\n/**\n * Action for clean block (remove headline, list, blockquote code, markers)\n */\nfunction cleanBlock(editor) {\n    _cleanBlock(editor.codemirror);\n}\n\n/**\n * Action for drawing a link.\n * @param {EasyMDE} editor\n */\nfunction drawLink(editor) {\n    var options = editor.options;\n    var url = 'https://';\n    if (options.promptURLs) {\n        var result = prompt(options.promptTexts.link, url);\n        if (!result) {\n            return false;\n        }\n        url = escapePromptURL(result);\n    }\n    _toggleLink(editor, 'link', options.insertTexts.link, url);\n}\n\n/**\n * Action for drawing an img.\n * @param {EasyMDE} editor\n */\nfunction drawImage(editor) {\n    var options = editor.options;\n    var url = 'https://';\n    if (options.promptURLs) {\n        var result = prompt(options.promptTexts.image, url);\n        if (!result) {\n            return false;\n        }\n        url = escapePromptURL(result);\n    }\n    _toggleLink(editor, 'image', options.insertTexts.image, url);\n}\n\n/**\n * Encode and escape URLs to prevent breaking up rendered Markdown links.\n * @param {string} url The url of the link or image\n */\nfunction escapePromptURL(url) {\n    return encodeURI(url).replace(/([\\\\()])/g, '\\\\$1');\n}\n\n/**\n * Action for opening the browse-file window to upload an image to a server.\n * @param {EasyMDE} editor The EasyMDE object\n */\nfunction drawUploadedImage(editor) {\n    // TODO: Draw the image template with a fake url? ie: '![](importing foo.png...)'\n    editor.openBrowseFileWindow();\n}\n\n/**\n * Action executed after an image have been successfully imported on the server.\n * @param {EasyMDE} editor The EasyMDE object\n * @param {string} url The url of the uploaded image\n */\nfunction afterImageUploaded(editor, url) {\n    var cm = editor.codemirror;\n    var stat = getState(cm);\n    var options = editor.options;\n    var imageName = url.substr(url.lastIndexOf('/') + 1);\n    var ext = imageName.substring(imageName.lastIndexOf('.') + 1).replace(/\\?.*$/, '').toLowerCase();\n\n    // Check if media is an image\n    if (['png', 'jpg', 'jpeg', 'gif', 'svg', 'apng', 'avif', 'webp'].includes(ext)) {\n        _replaceSelection(cm, stat.image, options.insertTexts.uploadedImage, url);\n    } else {\n        var text_link = options.insertTexts.link;\n        text_link[0] = '[' + imageName;\n        _replaceSelection(cm, stat.link, text_link, url);\n    }\n\n    // show uploaded image filename for 1000ms\n    editor.updateStatusBar('upload-image', editor.options.imageTexts.sbOnUploaded.replace('#image_name#', imageName));\n    setTimeout(function () {\n        editor.updateStatusBar('upload-image', editor.options.imageTexts.sbInit);\n    }, 1000);\n}\n\n/**\n * Action for drawing a table.\n * @param {EasyMDE} editor\n */\nfunction drawTable(editor) {\n    var cm = editor.codemirror;\n    var stat = getState(cm);\n    var options = editor.options;\n    _replaceSelection(cm, stat.table, options.insertTexts.table);\n}\n\n/**\n * Action for drawing a horizontal rule.\n * @param {EasyMDE} editor\n */\nfunction drawHorizontalRule(editor) {\n    var cm = editor.codemirror;\n    var stat = getState(cm);\n    var options = editor.options;\n    _replaceSelection(cm, stat.image, options.insertTexts.horizontalRule);\n}\n\n\n/**\n * Undo action.\n * @param {EasyMDE} editor\n */\nfunction undo(editor) {\n    var cm = editor.codemirror;\n    cm.undo();\n    cm.focus();\n}\n\n\n/**\n * Redo action.\n * @param {EasyMDE} editor\n */\nfunction redo(editor) {\n    var cm = editor.codemirror;\n    cm.redo();\n    cm.focus();\n}\n\n\n/**\n * Toggle side by side preview\n * @param {EasyMDE} editor\n */\nfunction toggleSideBySide(editor) {\n    var cm = editor.codemirror;\n    var wrapper = cm.getWrapperElement();\n    var preview = wrapper.nextSibling;\n    var toolbarButton = editor.toolbarElements && editor.toolbarElements['side-by-side'];\n    var useSideBySideListener = false;\n\n    var easyMDEContainer = wrapper.parentNode;\n\n    if (preview.classList.contains('editor-preview-active-side')) {\n        if (editor.options.sideBySideFullscreen === false) {\n            // if side-by-side not-fullscreen ok, remove classes when hiding side\n            easyMDEContainer.classList.remove('sided--no-fullscreen');\n        }\n        preview.classList.remove('editor-preview-active-side');\n        if (toolbarButton) toolbarButton.classList.remove('active');\n        wrapper.classList.remove('CodeMirror-sided');\n    } else {\n        // When the preview button is clicked for the first time,\n        // give some time for the transition from editor.css to fire and the view to slide from right to left,\n        // instead of just appearing.\n        setTimeout(function () {\n            if (!cm.getOption('fullScreen')) {\n                if (editor.options.sideBySideFullscreen === false) {\n                    // if side-by-side not-fullscreen ok, add classes when not fullscreen and showing side\n                    easyMDEContainer.classList.add('sided--no-fullscreen');\n                } else {\n                    toggleFullScreen(editor);\n                }\n            }\n            preview.classList.add('editor-preview-active-side');\n        }, 1);\n        if (toolbarButton) toolbarButton.classList.add('active');\n        wrapper.classList.add('CodeMirror-sided');\n        useSideBySideListener = true;\n    }\n\n    // Hide normal preview if active\n    var previewNormal = wrapper.lastChild;\n    if (previewNormal.classList.contains('editor-preview-active')) {\n        previewNormal.classList.remove('editor-preview-active');\n        var toolbar = editor.toolbarElements.preview;\n        var toolbar_div = editor.toolbar_div;\n        toolbar.classList.remove('active');\n        toolbar_div.classList.remove('disabled-for-preview');\n    }\n\n    var sideBySideRenderingFunction = function () {\n        var newValue = editor.options.previewRender(editor.value(), preview);\n        if (newValue != null) {\n            preview.innerHTML = newValue;\n        }\n    };\n\n    if (!cm.sideBySideRenderingFunction) {\n        cm.sideBySideRenderingFunction = sideBySideRenderingFunction;\n    }\n\n    if (useSideBySideListener) {\n        var newValue = editor.options.previewRender(editor.value(), preview);\n        if (newValue != null) {\n            preview.innerHTML = newValue;\n        }\n        cm.on('update', cm.sideBySideRenderingFunction);\n    } else {\n        cm.off('update', cm.sideBySideRenderingFunction);\n    }\n\n    // Refresh to fix selection being off (#309)\n    cm.refresh();\n}\n\n\n/**\n * Preview action.\n * @param {EasyMDE} editor\n */\nfunction togglePreview(editor) {\n    var cm = editor.codemirror;\n    var wrapper = cm.getWrapperElement();\n    var toolbar_div = editor.toolbar_div;\n    var toolbar = editor.options.toolbar ? editor.toolbarElements.preview : false;\n    var preview = wrapper.lastChild;\n\n    // Turn off side by side if needed\n    var sidebyside = cm.getWrapperElement().nextSibling;\n    if (sidebyside.classList.contains('editor-preview-active-side'))\n        toggleSideBySide(editor);\n\n    if (!preview || !preview.classList.contains('editor-preview-full')) {\n\n        preview = document.createElement('div');\n        preview.className = 'editor-preview-full';\n\n        if (editor.options.previewClass) {\n\n            if (Array.isArray(editor.options.previewClass)) {\n                for (var i = 0; i < editor.options.previewClass.length; i++) {\n                    preview.classList.add(editor.options.previewClass[i]);\n                }\n\n            } else if (typeof editor.options.previewClass === 'string') {\n                preview.classList.add(editor.options.previewClass);\n            }\n        }\n\n        wrapper.appendChild(preview);\n    }\n\n    if (preview.classList.contains('editor-preview-active')) {\n        preview.classList.remove('editor-preview-active');\n        if (toolbar) {\n            toolbar.classList.remove('active');\n            toolbar_div.classList.remove('disabled-for-preview');\n        }\n    } else {\n        // When the preview button is clicked for the first time,\n        // give some time for the transition from editor.css to fire and the view to slide from right to left,\n        // instead of just appearing.\n        setTimeout(function () {\n            preview.classList.add('editor-preview-active');\n        }, 1);\n        if (toolbar) {\n            toolbar.classList.add('active');\n            toolbar_div.classList.add('disabled-for-preview');\n        }\n    }\n\n    var preview_result = editor.options.previewRender(editor.value(), preview);\n    if (preview_result !== null) {\n        preview.innerHTML = preview_result;\n    }\n\n}\n\nfunction _replaceSelection(cm, active, startEnd, url) {\n    if (cm.getWrapperElement().lastChild.classList.contains('editor-preview-active'))\n        return;\n\n    var text;\n    var start = startEnd[0];\n    var end = startEnd[1];\n    var startPoint = {},\n        endPoint = {};\n    Object.assign(startPoint, cm.getCursor('start'));\n    Object.assign(endPoint, cm.getCursor('end'));\n    if (url) {\n        start = start.replace('#url#', url);  // url is in start for upload-image\n        end = end.replace('#url#', url);\n    }\n    if (active) {\n        text = cm.getLine(startPoint.line);\n        start = text.slice(0, startPoint.ch);\n        end = text.slice(startPoint.ch);\n        cm.replaceRange(start + end, {\n            line: startPoint.line,\n            ch: 0,\n        });\n    } else {\n        text = cm.getSelection();\n        cm.replaceSelection(start + text + end);\n\n        startPoint.ch += start.length;\n        if (startPoint !== endPoint) {\n            endPoint.ch += start.length;\n        }\n    }\n    cm.setSelection(startPoint, endPoint);\n    cm.focus();\n}\n\n\nfunction _toggleHeading(cm, direction, size) {\n    if (cm.getWrapperElement().lastChild.classList.contains('editor-preview-active'))\n        return;\n\n    var startPoint = cm.getCursor('start');\n    var endPoint = cm.getCursor('end');\n    for (var i = startPoint.line; i <= endPoint.line; i++) {\n        (function (i) {\n            var text = cm.getLine(i);\n            var currHeadingLevel = text.search(/[^#]/);\n\n            if (direction !== undefined) {\n                if (currHeadingLevel <= 0) {\n                    if (direction == 'bigger') {\n                        text = '###### ' + text;\n                    } else {\n                        text = '# ' + text;\n                    }\n                } else if (currHeadingLevel == 6 && direction == 'smaller') {\n                    text = text.substr(7);\n                } else if (currHeadingLevel == 1 && direction == 'bigger') {\n                    text = text.substr(2);\n                } else {\n                    if (direction == 'bigger') {\n                        text = text.substr(1);\n                    } else {\n                        text = '#' + text;\n                    }\n                }\n            } else {\n                if (currHeadingLevel <= 0) {\n                    text = '#'.repeat(size) + ' ' + text;\n                } else if (currHeadingLevel == size) {\n                    text = text.substr(currHeadingLevel + 1);\n                } else {\n                    text = '#'.repeat(size) + ' ' + text.substr(currHeadingLevel + 1);\n                }\n            }\n\n            cm.replaceRange(text, {\n                line: i,\n                ch: 0,\n            }, {\n                line: i,\n                ch: 99999999999999,\n            });\n        })(i);\n    }\n    cm.focus();\n}\n\n\nfunction _toggleLine(cm, name, liststyle) {\n    if (cm.getWrapperElement().lastChild.classList.contains('editor-preview-active'))\n        return;\n\n    var listRegexp = /^(\\s*)(\\*|-|\\+|\\d*\\.)(\\s+)/;\n    var whitespacesRegexp = /^\\s*/;\n\n    var stat = getState(cm);\n    var startPoint = cm.getCursor('start');\n    var endPoint = cm.getCursor('end');\n    var repl = {\n        'quote': /^(\\s*)>\\s+/,\n        'unordered-list': listRegexp,\n        'ordered-list': listRegexp,\n    };\n\n    var _getChar = function (name, i) {\n        var map = {\n            'quote': '>',\n            'unordered-list': liststyle,\n            'ordered-list': '%%i.',\n        };\n\n        return map[name].replace('%%i', i);\n    };\n\n    var _checkChar = function (name, char) {\n        var map = {\n            'quote': '>',\n            'unordered-list': '\\\\' + liststyle,\n            'ordered-list': '\\\\d+.',\n        };\n        var rt = new RegExp(map[name]);\n\n        return char && rt.test(char);\n    };\n\n    var _toggle = function (name, text, untoggleOnly) {\n        var arr = listRegexp.exec(text);\n        var char = _getChar(name, line);\n        if (arr !== null) {\n            if (_checkChar(name, arr[2])) {\n                char = '';\n            }\n            text = arr[1] + char + arr[3] + text.replace(whitespacesRegexp, '').replace(repl[name], '$1');\n        } else if (untoggleOnly == false) {\n            text = char + ' ' + text;\n        }\n        return text;\n    };\n\n    var line = 1;\n    for (var i = startPoint.line; i <= endPoint.line; i++) {\n        (function (i) {\n            var text = cm.getLine(i);\n            if (stat[name]) {\n                text = text.replace(repl[name], '$1');\n            } else {\n                // If we're toggling unordered-list formatting, check if the current line\n                // is part of an ordered-list, and if so, untoggle that first.\n                // Workaround for https://github.com/Ionaru/easy-markdown-editor/issues/92\n                if (name == 'unordered-list') {\n                    text = _toggle('ordered-list', text, true);\n                }\n                text = _toggle(name, text, false);\n                line += 1;\n            }\n            cm.replaceRange(text, {\n                line: i,\n                ch: 0,\n            }, {\n                line: i,\n                ch: 99999999999999,\n            });\n        })(i);\n    }\n    cm.focus();\n}\n\n/**\n * @param {EasyMDE} editor\n * @param {'link' | 'image'} type\n * @param {string} startEnd\n * @param {string} url\n */\nfunction _toggleLink(editor, type, startEnd, url) {\n    if (!editor.codemirror || editor.isPreviewActive()) {\n        return;\n    }\n\n    var cm = editor.codemirror;\n    var stat = getState(cm);\n    var active = stat[type];\n    if (!active) {\n        _replaceSelection(cm, active, startEnd, url);\n        return;\n    }\n\n    var startPoint = cm.getCursor('start');\n    var endPoint = cm.getCursor('end');\n    var text = cm.getLine(startPoint.line);\n    var start = text.slice(0, startPoint.ch);\n    var end = text.slice(startPoint.ch);\n\n    if (type == 'link') {\n        start = start.replace(/(.*)[^!]\\[/, '$1');\n    } else if (type == 'image') {\n        start = start.replace(/(.*)!\\[$/, '$1');\n    }\n    end = end.replace(/]\\(.*?\\)/, '');\n\n    cm.replaceRange(start + end, {\n        line: startPoint.line,\n        ch: 0,\n    }, {\n        line: startPoint.line,\n        ch: 99999999999999,\n    });\n\n    startPoint.ch -= startEnd[0].length;\n    if (startPoint !== endPoint) {\n        endPoint.ch -= startEnd[0].length;\n    }\n    cm.setSelection(startPoint, endPoint);\n    cm.focus();\n}\n\n/**\n * @param {EasyMDE} editor\n */\nfunction _toggleBlock(editor, type, start_chars, end_chars) {\n    if (!editor.codemirror || editor.isPreviewActive()) {\n        return;\n    }\n\n    end_chars = (typeof end_chars === 'undefined') ? start_chars : end_chars;\n    var cm = editor.codemirror;\n    var stat = getState(cm);\n\n    var text;\n    var start = start_chars;\n    var end = end_chars;\n\n    var startPoint = cm.getCursor('start');\n    var endPoint = cm.getCursor('end');\n\n    if (stat[type]) {\n        text = cm.getLine(startPoint.line);\n        start = text.slice(0, startPoint.ch);\n        end = text.slice(startPoint.ch);\n        if (type == 'bold') {\n            start = start.replace(/(\\*\\*|__)(?![\\s\\S]*(\\*\\*|__))/, '');\n            end = end.replace(/(\\*\\*|__)/, '');\n        } else if (type == 'italic') {\n            start = start.replace(/(\\*|_)(?![\\s\\S]*(\\*|_))/, '');\n            end = end.replace(/(\\*|_)/, '');\n        } else if (type == 'strikethrough') {\n            start = start.replace(/(\\*\\*|~~)(?![\\s\\S]*(\\*\\*|~~))/, '');\n            end = end.replace(/(\\*\\*|~~)/, '');\n        }\n        cm.replaceRange(start + end, {\n            line: startPoint.line,\n            ch: 0,\n        }, {\n            line: startPoint.line,\n            ch: 99999999999999,\n        });\n\n        if (type == 'bold' || type == 'strikethrough') {\n            startPoint.ch -= 2;\n            if (startPoint !== endPoint) {\n                endPoint.ch -= 2;\n            }\n        } else if (type == 'italic') {\n            startPoint.ch -= 1;\n            if (startPoint !== endPoint) {\n                endPoint.ch -= 1;\n            }\n        }\n    } else {\n        text = cm.getSelection();\n        if (type == 'bold') {\n            text = text.split('**').join('');\n            text = text.split('__').join('');\n        } else if (type == 'italic') {\n            text = text.split('*').join('');\n            text = text.split('_').join('');\n        } else if (type == 'strikethrough') {\n            text = text.split('~~').join('');\n        }\n        cm.replaceSelection(start + text + end);\n\n        startPoint.ch += start_chars.length;\n        endPoint.ch = startPoint.ch + text.length;\n    }\n\n    cm.setSelection(startPoint, endPoint);\n    cm.focus();\n}\n\nfunction _cleanBlock(cm) {\n    if (cm.getWrapperElement().lastChild.classList.contains('editor-preview-active'))\n        return;\n\n    var startPoint = cm.getCursor('start');\n    var endPoint = cm.getCursor('end');\n    var text;\n\n    for (var line = startPoint.line; line <= endPoint.line; line++) {\n        text = cm.getLine(line);\n        text = text.replace(/^[ ]*([# ]+|\\*|-|[> ]+|[0-9]+(.|\\)))[ ]*/, '');\n\n        cm.replaceRange(text, {\n            line: line,\n            ch: 0,\n        }, {\n            line: line,\n            ch: 99999999999999,\n        });\n    }\n}\n\n/**\n * Convert a number of bytes to a human-readable file size. If you desire\n * to add a space between the value and the unit, you need to add this space\n * to the given units.\n * @param bytes {number} A number of bytes, as integer. Ex: 421137\n * @param units {number[]} An array of human-readable units, ie. [' B', ' K', ' MB']\n * @returns string A human-readable file size. Ex: '412 KB'\n */\nfunction humanFileSize(bytes, units) {\n    if (Math.abs(bytes) < 1024) {\n        return '' + bytes + units[0];\n    }\n    var u = 0;\n    do {\n        bytes /= 1024;\n        ++u;\n    } while (Math.abs(bytes) >= 1024 && u < units.length);\n    return '' + bytes.toFixed(1) + units[u];\n}\n\n// Merge the properties of one object into another.\nfunction _mergeProperties(target, source) {\n    for (var property in source) {\n        if (Object.prototype.hasOwnProperty.call(source, property)) {\n            if (source[property] instanceof Array) {\n                target[property] = source[property].concat(target[property] instanceof Array ? target[property] : []);\n            } else if (\n                source[property] !== null &&\n                typeof source[property] === 'object' &&\n                source[property].constructor === Object\n            ) {\n                target[property] = _mergeProperties(target[property] || {}, source[property]);\n            } else {\n                target[property] = source[property];\n            }\n        }\n    }\n\n    return target;\n}\n\n// Merge an arbitrary number of objects into one.\nfunction extend(target) {\n    for (var i = 1; i < arguments.length; i++) {\n        target = _mergeProperties(target, arguments[i]);\n    }\n\n    return target;\n}\n\n/* The right word count in respect for CJK. */\nfunction wordCount(data) {\n    var pattern = /[a-zA-Z0-9_\\u00A0-\\u02AF\\u0392-\\u03c9\\u0410-\\u04F9]+|[\\u4E00-\\u9FFF\\u3400-\\u4dbf\\uf900-\\ufaff\\u3040-\\u309f\\uac00-\\ud7af]+/g;\n    var m = data.match(pattern);\n    var count = 0;\n    if (m === null) return count;\n    for (var i = 0; i < m.length; i++) {\n        if (m[i].charCodeAt(0) >= 0x4E00) {\n            count += m[i].length;\n        } else {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nvar iconClassMap = {\n    'bold': 'fa fa-bold',\n    'italic': 'fa fa-italic',\n    'strikethrough': 'fa fa-strikethrough',\n    'heading': 'fa fa-header fa-heading',\n    'heading-smaller': 'fa fa-header fa-heading header-smaller',\n    'heading-bigger': 'fa fa-header fa-heading header-bigger',\n    'heading-1': 'fa fa-header fa-heading header-1',\n    'heading-2': 'fa fa-header fa-heading header-2',\n    'heading-3': 'fa fa-header fa-heading header-3',\n    'code': 'fa fa-code',\n    'quote': 'fa fa-quote-left',\n    'ordered-list': 'fa fa-list-ol',\n    'unordered-list': 'fa fa-list-ul',\n    'clean-block': 'fa fa-eraser',\n    'link': 'fa fa-link',\n    'image': 'fa fa-image',\n    'upload-image': 'fa fa-image',\n    'table': 'fa fa-table',\n    'horizontal-rule': 'fa fa-minus',\n    'preview': 'fa fa-eye',\n    'side-by-side': 'fa fa-columns',\n    'fullscreen': 'fa fa-arrows-alt',\n    'guide': 'fa fa-question-circle',\n    'undo': 'fa fa-undo',\n    'redo': 'fa fa-repeat fa-redo',\n};\n\nvar toolbarBuiltInButtons = {\n    'bold': {\n        name: 'bold',\n        action: toggleBold,\n        className: iconClassMap['bold'],\n        title: 'Bold',\n        default: true,\n    },\n    'italic': {\n        name: 'italic',\n        action: toggleItalic,\n        className: iconClassMap['italic'],\n        title: 'Italic',\n        default: true,\n    },\n    'strikethrough': {\n        name: 'strikethrough',\n        action: toggleStrikethrough,\n        className: iconClassMap['strikethrough'],\n        title: 'Strikethrough',\n    },\n    'heading': {\n        name: 'heading',\n        action: toggleHeadingSmaller,\n        className: iconClassMap['heading'],\n        title: 'Heading',\n        default: true,\n    },\n    'heading-smaller': {\n        name: 'heading-smaller',\n        action: toggleHeadingSmaller,\n        className: iconClassMap['heading-smaller'],\n        title: 'Smaller Heading',\n    },\n    'heading-bigger': {\n        name: 'heading-bigger',\n        action: toggleHeadingBigger,\n        className: iconClassMap['heading-bigger'],\n        title: 'Bigger Heading',\n    },\n    'heading-1': {\n        name: 'heading-1',\n        action: toggleHeading1,\n        className: iconClassMap['heading-1'],\n        title: 'Big Heading',\n    },\n    'heading-2': {\n        name: 'heading-2',\n        action: toggleHeading2,\n        className: iconClassMap['heading-2'],\n        title: 'Medium Heading',\n    },\n    'heading-3': {\n        name: 'heading-3',\n        action: toggleHeading3,\n        className: iconClassMap['heading-3'],\n        title: 'Small Heading',\n    },\n    'separator-1': {\n        name: 'separator-1',\n    },\n    'code': {\n        name: 'code',\n        action: toggleCodeBlock,\n        className: iconClassMap['code'],\n        title: 'Code',\n    },\n    'quote': {\n        name: 'quote',\n        action: toggleBlockquote,\n        className: iconClassMap['quote'],\n        title: 'Quote',\n        default: true,\n    },\n    'unordered-list': {\n        name: 'unordered-list',\n        action: toggleUnorderedList,\n        className: iconClassMap['unordered-list'],\n        title: 'Generic List',\n        default: true,\n    },\n    'ordered-list': {\n        name: 'ordered-list',\n        action: toggleOrderedList,\n        className: iconClassMap['ordered-list'],\n        title: 'Numbered List',\n        default: true,\n    },\n    'clean-block': {\n        name: 'clean-block',\n        action: cleanBlock,\n        className: iconClassMap['clean-block'],\n        title: 'Clean block',\n    },\n    'separator-2': {\n        name: 'separator-2',\n    },\n    'link': {\n        name: 'link',\n        action: drawLink,\n        className: iconClassMap['link'],\n        title: 'Create Link',\n        default: true,\n    },\n    'image': {\n        name: 'image',\n        action: drawImage,\n        className: iconClassMap['image'],\n        title: 'Insert Image',\n        default: true,\n    },\n    'upload-image': {\n        name: 'upload-image',\n        action: drawUploadedImage,\n        className: iconClassMap['upload-image'],\n        title: 'Import an image',\n    },\n    'table': {\n        name: 'table',\n        action: drawTable,\n        className: iconClassMap['table'],\n        title: 'Insert Table',\n    },\n    'horizontal-rule': {\n        name: 'horizontal-rule',\n        action: drawHorizontalRule,\n        className: iconClassMap['horizontal-rule'],\n        title: 'Insert Horizontal Line',\n    },\n    'separator-3': {\n        name: 'separator-3',\n    },\n    'preview': {\n        name: 'preview',\n        action: togglePreview,\n        className: iconClassMap['preview'],\n        noDisable: true,\n        title: 'Toggle Preview',\n        default: true,\n    },\n    'side-by-side': {\n        name: 'side-by-side',\n        action: toggleSideBySide,\n        className: iconClassMap['side-by-side'],\n        noDisable: true,\n        noMobile: true,\n        title: 'Toggle Side by Side',\n        default: true,\n    },\n    'fullscreen': {\n        name: 'fullscreen',\n        action: toggleFullScreen,\n        className: iconClassMap['fullscreen'],\n        noDisable: true,\n        noMobile: true,\n        title: 'Toggle Fullscreen',\n        default: true,\n    },\n    'separator-4': {\n        name: 'separator-4',\n    },\n    'guide': {\n        name: 'guide',\n        action: 'https://www.markdownguide.org/basic-syntax/',\n        className: iconClassMap['guide'],\n        noDisable: true,\n        title: 'Markdown Guide',\n        default: true,\n    },\n    'separator-5': {\n        name: 'separator-5',\n    },\n    'undo': {\n        name: 'undo',\n        action: undo,\n        className: iconClassMap['undo'],\n        noDisable: true,\n        title: 'Undo',\n    },\n    'redo': {\n        name: 'redo',\n        action: redo,\n        className: iconClassMap['redo'],\n        noDisable: true,\n        title: 'Redo',\n    },\n};\n\nvar insertTexts = {\n    link: ['[', '](#url#)'],\n    image: ['![', '](#url#)'],\n    uploadedImage: ['![](#url#)', ''],\n    // uploadedImage: ['![](#url#)\\n', ''], // TODO: New line insertion doesn't work here.\n    table: ['', '\\n\\n| Column 1 | Column 2 | Column 3 |\\n| -------- | -------- | -------- |\\n| Text     | Text     | Text     |\\n\\n'],\n    horizontalRule: ['', '\\n\\n-----\\n\\n'],\n};\n\nvar promptTexts = {\n    link: 'URL for the link:',\n    image: 'URL of the image:',\n};\n\nvar timeFormat = {\n    locale: 'en-US',\n    format: {\n        hour: '2-digit',\n        minute: '2-digit',\n    },\n};\n\nvar blockStyles = {\n    'bold': '**',\n    'code': '```',\n    'italic': '*',\n};\n\n/**\n * Texts displayed to the user (mainly on the status bar) for the import image\n * feature. Can be used for customization or internationalization.\n */\nvar imageTexts = {\n    sbInit: 'Attach files by drag and dropping or pasting from clipboard.',\n    sbOnDragEnter: 'Drop image to upload it.',\n    sbOnDrop: 'Uploading image #images_names#...',\n    sbProgress: 'Uploading #file_name#: #progress#%',\n    sbOnUploaded: 'Uploaded #image_name#',\n    sizeUnits: ' B, KB, MB',\n};\n\n/**\n * Errors displayed to the user, using the `errorCallback` option. Can be used for\n * customization or internationalization.\n */\nvar errorMessages = {\n    noFileGiven: 'You must select a file.',\n    typeNotAllowed: 'This image type is not allowed.',\n    fileTooLarge: 'Image #image_name# is too big (#image_size#).\\n' +\n        'Maximum file size is #image_max_size#.',\n    importError: 'Something went wrong when uploading the image #image_name#.',\n};\n\n/**\n * Interface of EasyMDE.\n */\nfunction EasyMDE(options) {\n    // Handle options parameter\n    options = options || {};\n\n    // Used later to refer to it\"s parent\n    options.parent = this;\n\n    // Check if Font Awesome needs to be auto downloaded\n    var autoDownloadFA = true;\n\n    if (options.autoDownloadFontAwesome === false) {\n        autoDownloadFA = false;\n    }\n\n    if (options.autoDownloadFontAwesome !== true) {\n        var styleSheets = document.styleSheets;\n        for (var i = 0; i < styleSheets.length; i++) {\n            if (!styleSheets[i].href)\n                continue;\n\n            if (styleSheets[i].href.indexOf('//maxcdn.bootstrapcdn.com/font-awesome/') > -1) {\n                autoDownloadFA = false;\n            }\n        }\n    }\n\n    if (autoDownloadFA) {\n        var link = document.createElement('link');\n        link.rel = 'stylesheet';\n        link.href = 'https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css';\n        document.getElementsByTagName('head')[0].appendChild(link);\n    }\n\n\n    // Find the textarea to use\n    if (options.element) {\n        this.element = options.element;\n    } else if (options.element === null) {\n        // This means that the element option was specified, but no element was found\n        console.log('EasyMDE: Error. No element was found.');\n        return;\n    }\n\n\n    // Handle toolbar\n    if (options.toolbar === undefined) {\n        // Initialize\n        options.toolbar = [];\n\n\n        // Loop over the built in buttons, to get the preferred order\n        for (var key in toolbarBuiltInButtons) {\n            if (Object.prototype.hasOwnProperty.call(toolbarBuiltInButtons, key)) {\n                if (key.indexOf('separator-') != -1) {\n                    options.toolbar.push('|');\n                }\n\n                if (toolbarBuiltInButtons[key].default === true || (options.showIcons && options.showIcons.constructor === Array && options.showIcons.indexOf(key) != -1)) {\n                    options.toolbar.push(key);\n                }\n            }\n        }\n    }\n\n    // Editor preview styling class.\n    if (!Object.prototype.hasOwnProperty.call(options, 'previewClass')) {\n        options.previewClass = 'editor-preview';\n    }\n\n    // Handle status bar\n    if (!Object.prototype.hasOwnProperty.call(options, 'status')) {\n        options.status = ['autosave', 'lines', 'words', 'cursor'];\n\n        if (options.uploadImage) {\n            options.status.unshift('upload-image');\n        }\n    }\n\n\n    // Add default preview rendering function\n    if (!options.previewRender) {\n        options.previewRender = function (plainText) {\n            // Note: \"this\" refers to the options object\n            return this.parent.markdown(plainText);\n        };\n    }\n\n\n    // Set default options for parsing config\n    options.parsingConfig = extend({\n        highlightFormatting: true, // needed for toggleCodeBlock to detect types of code\n    }, options.parsingConfig || {});\n\n\n    // Merging the insertTexts, with the given options\n    options.insertTexts = extend({}, insertTexts, options.insertTexts || {});\n\n\n    // Merging the promptTexts, with the given options\n    options.promptTexts = extend({}, promptTexts, options.promptTexts || {});\n\n\n    // Merging the blockStyles, with the given options\n    options.blockStyles = extend({}, blockStyles, options.blockStyles || {});\n\n\n    if (options.autosave != undefined) {\n        // Merging the Autosave timeFormat, with the given options\n        options.autosave.timeFormat = extend({}, timeFormat, options.autosave.timeFormat || {});\n    }\n\n    options.iconClassMap = extend({}, iconClassMap, options.iconClassMap || {});\n\n    // Merging the shortcuts, with the given options\n    options.shortcuts = extend({}, shortcuts, options.shortcuts || {});\n\n    options.maxHeight = options.maxHeight || undefined;\n\n    options.direction = options.direction || 'ltr';\n\n    if (typeof options.maxHeight !== 'undefined') {\n        // Min and max height are equal if maxHeight is set\n        options.minHeight = options.maxHeight;\n    } else {\n        options.minHeight = options.minHeight || '300px';\n    }\n\n    options.errorCallback = options.errorCallback || function (errorMessage) {\n        alert(errorMessage);\n    };\n\n    // Import-image default configuration\n    options.uploadImage = options.uploadImage || false;\n    options.imageMaxSize = options.imageMaxSize || 2097152; // 1024 * 1024 * 2\n    options.imageAccept = options.imageAccept || 'image/png, image/jpeg, image/gif, image/avif';\n    options.imageTexts = extend({}, imageTexts, options.imageTexts || {});\n    options.errorMessages = extend({}, errorMessages, options.errorMessages || {});\n    options.imagePathAbsolute = options.imagePathAbsolute || false;\n    options.imageCSRFName = options.imageCSRFName || 'csrfmiddlewaretoken';\n    options.imageCSRFHeader = options.imageCSRFHeader || false;\n\n\n    // Change unique_id to uniqueId for backwards compatibility\n    if (options.autosave != undefined && options.autosave.unique_id != undefined && options.autosave.unique_id != '')\n        options.autosave.uniqueId = options.autosave.unique_id;\n\n    // If overlay mode is specified and combine is not provided, default it to true\n    if (options.overlayMode && options.overlayMode.combine === undefined) {\n        options.overlayMode.combine = true;\n    }\n\n    // Update this options\n    this.options = options;\n\n\n    // Auto render\n    this.render();\n\n\n    // The codemirror component is only available after rendering\n    // so, the setter for the initialValue can only run after\n    // the element has been rendered\n    if (options.initialValue && (!this.options.autosave || this.options.autosave.foundSavedValue !== true)) {\n        this.value(options.initialValue);\n    }\n\n    if (options.uploadImage) {\n        var self = this;\n\n        this.codemirror.on('dragenter', function (cm, event) {\n            self.updateStatusBar('upload-image', self.options.imageTexts.sbOnDragEnter);\n            event.stopPropagation();\n            event.preventDefault();\n        });\n        this.codemirror.on('dragend', function (cm, event) {\n            self.updateStatusBar('upload-image', self.options.imageTexts.sbInit);\n            event.stopPropagation();\n            event.preventDefault();\n        });\n        this.codemirror.on('dragleave', function (cm, event) {\n            self.updateStatusBar('upload-image', self.options.imageTexts.sbInit);\n            event.stopPropagation();\n            event.preventDefault();\n        });\n\n        this.codemirror.on('dragover', function (cm, event) {\n            self.updateStatusBar('upload-image', self.options.imageTexts.sbOnDragEnter);\n            event.stopPropagation();\n            event.preventDefault();\n        });\n\n        this.codemirror.on('drop', function (cm, event) {\n            event.stopPropagation();\n            event.preventDefault();\n            if (options.imageUploadFunction) {\n                self.uploadImagesUsingCustomFunction(options.imageUploadFunction, event.dataTransfer.files);\n            } else {\n                self.uploadImages(event.dataTransfer.files);\n            }\n        });\n\n        this.codemirror.on('paste', function (cm, event) {\n            if (options.imageUploadFunction) {\n                self.uploadImagesUsingCustomFunction(options.imageUploadFunction, event.clipboardData.files);\n            } else {\n                self.uploadImages(event.clipboardData.files);\n            }\n        });\n    }\n}\n\n/**\n * Upload asynchronously a list of images to a server.\n *\n * Can be triggered by:\n * - drag&drop;\n * - copy-paste;\n * - the browse-file window (opened when the user clicks on the *upload-image* icon).\n * @param {FileList} files The files to upload the the server.\n * @param [onSuccess] {function} see EasyMDE.prototype.uploadImage\n * @param [onError] {function} see EasyMDE.prototype.uploadImage\n */\nEasyMDE.prototype.uploadImages = function (files, onSuccess, onError) {\n    if (files.length === 0) {\n        return;\n    }\n    var names = [];\n    for (var i = 0; i < files.length; i++) {\n        names.push(files[i].name);\n        this.uploadImage(files[i], onSuccess, onError);\n    }\n    this.updateStatusBar('upload-image', this.options.imageTexts.sbOnDrop.replace('#images_names#', names.join(', ')));\n};\n\n/**\n * Upload asynchronously a list of images to a server.\n *\n * Can be triggered by:\n * - drag&drop;\n * - copy-paste;\n * - the browse-file window (opened when the user clicks on the *upload-image* icon).\n * @param imageUploadFunction {Function} The custom function to upload the image passed in options.\n * @param {FileList} files The files to upload the the server.\n */\nEasyMDE.prototype.uploadImagesUsingCustomFunction = function (imageUploadFunction, files) {\n    if (files.length === 0) {\n        return;\n    }\n    var names = [];\n    for (var i = 0; i < files.length; i++) {\n        names.push(files[i].name);\n        this.uploadImageUsingCustomFunction(imageUploadFunction, files[i]);\n    }\n    this.updateStatusBar('upload-image', this.options.imageTexts.sbOnDrop.replace('#images_names#', names.join(', ')));\n};\n\n/**\n * Update an item in the status bar.\n * @param itemName {string} The name of the item to update (ie. 'upload-image', 'autosave', etc.).\n * @param content {string} the new content of the item to write in the status bar.\n */\nEasyMDE.prototype.updateStatusBar = function (itemName, content) {\n    if (!this.gui.statusbar) {\n        return;\n    }\n\n    var matchingClasses = this.gui.statusbar.getElementsByClassName(itemName);\n    if (matchingClasses.length === 1) {\n        this.gui.statusbar.getElementsByClassName(itemName)[0].textContent = content;\n    } else if (matchingClasses.length === 0) {\n        console.log('EasyMDE: status bar item ' + itemName + ' was not found.');\n    } else {\n        console.log('EasyMDE: Several status bar items named ' + itemName + ' was found.');\n    }\n};\n\n/**\n * Default markdown render.\n */\nEasyMDE.prototype.markdown = function (text) {\n    if (marked) {\n        // Initialize\n        var markedOptions;\n        if (this.options && this.options.renderingConfig && this.options.renderingConfig.markedOptions) {\n            markedOptions = this.options.renderingConfig.markedOptions;\n        } else {\n            markedOptions = {};\n        }\n\n        // Update options\n        if (this.options && this.options.renderingConfig && this.options.renderingConfig.singleLineBreaks === false) {\n            markedOptions.breaks = false;\n        } else {\n            markedOptions.breaks = true;\n        }\n\n        if (this.options && this.options.renderingConfig && this.options.renderingConfig.codeSyntaxHighlighting === true) {\n\n            /* Get HLJS from config or window */\n            var hljs = this.options.renderingConfig.hljs || window.hljs;\n\n            /* Check if HLJS loaded */\n            if (hljs) {\n                markedOptions.highlight = function (code, language) {\n                    if (language && hljs.getLanguage(language)) {\n                        return hljs.highlight(language, code).value;\n                    } else {\n                        return hljs.highlightAuto(code).value;\n                    }\n                };\n            }\n        }\n\n        // Set options\n        marked.setOptions(markedOptions);\n\n        // Convert the markdown to HTML\n        var htmlText = marked.parse(text);\n\n        // Sanitize HTML\n        if (this.options.renderingConfig && typeof this.options.renderingConfig.sanitizerFunction === 'function') {\n            htmlText = this.options.renderingConfig.sanitizerFunction.call(this, htmlText);\n        }\n\n        // Edit the HTML anchors to add 'target=\"_blank\"' by default.\n        htmlText = addAnchorTargetBlank(htmlText);\n\n        // Remove list-style when rendering checkboxes\n        htmlText = removeListStyleWhenCheckbox(htmlText);\n\n        return htmlText;\n    }\n};\n\n/**\n * Render editor to the given element.\n */\nEasyMDE.prototype.render = function (el) {\n    if (!el) {\n        el = this.element || document.getElementsByTagName('textarea')[0];\n    }\n\n    if (this._rendered && this._rendered === el) {\n        // Already rendered.\n        return;\n    }\n\n    this.element = el;\n    var options = this.options;\n\n    var self = this;\n    var keyMaps = {};\n\n    for (var key in options.shortcuts) {\n        // null stands for \"do not bind this command\"\n        if (options.shortcuts[key] !== null && bindings[key] !== null) {\n            (function (key) {\n                keyMaps[fixShortcut(options.shortcuts[key])] = function () {\n                    var action = bindings[key];\n                    if (typeof action === 'function') {\n                        action(self);\n                    } else if (typeof action === 'string') {\n                        window.open(action, '_blank');\n                    }\n                };\n            })(key);\n        }\n    }\n\n    keyMaps['Enter'] = 'newlineAndIndentContinueMarkdownList';\n    keyMaps['Tab'] = 'tabAndIndentMarkdownList';\n    keyMaps['Shift-Tab'] = 'shiftTabAndUnindentMarkdownList';\n    keyMaps['Esc'] = function (cm) {\n        if (cm.getOption('fullScreen')) toggleFullScreen(self);\n    };\n\n    this.documentOnKeyDown = function (e) {\n        e = e || window.event;\n\n        if (e.keyCode == 27) {\n            if (self.codemirror.getOption('fullScreen')) toggleFullScreen(self);\n        }\n    };\n    document.addEventListener('keydown', this.documentOnKeyDown, false);\n\n    var mode, backdrop;\n\n    // CodeMirror overlay mode\n    if (options.overlayMode) {\n        CodeMirror.defineMode('overlay-mode', function (config) {\n            return CodeMirror.overlayMode(CodeMirror.getMode(config, options.spellChecker !== false ? 'spell-checker' : 'gfm'), options.overlayMode.mode, options.overlayMode.combine);\n        });\n\n        mode = 'overlay-mode';\n        backdrop = options.parsingConfig;\n        backdrop.gitHubSpice = false;\n    } else {\n        mode = options.parsingConfig;\n        mode.name = 'gfm';\n        mode.gitHubSpice = false;\n    }\n    if (options.spellChecker !== false) {\n        mode = 'spell-checker';\n        backdrop = options.parsingConfig;\n        backdrop.name = 'gfm';\n        backdrop.gitHubSpice = false;\n\n        if (typeof options.spellChecker === 'function') {\n            options.spellChecker({\n                codeMirrorInstance: CodeMirror,\n            });\n        } else {\n            CodeMirrorSpellChecker({\n                codeMirrorInstance: CodeMirror,\n            });\n        }\n    }\n\n    // eslint-disable-next-line no-unused-vars\n    function configureMouse(cm, repeat, event) {\n        return {\n            addNew: false,\n        };\n    }\n\n    this.codemirror = CodeMirror.fromTextArea(el, {\n        mode: mode,\n        backdrop: backdrop,\n        theme: (options.theme != undefined) ? options.theme : 'easymde',\n        tabSize: (options.tabSize != undefined) ? options.tabSize : 2,\n        indentUnit: (options.tabSize != undefined) ? options.tabSize : 2,\n        indentWithTabs: (options.indentWithTabs === false) ? false : true,\n        lineNumbers: (options.lineNumbers === true) ? true : false,\n        autofocus: (options.autofocus === true) ? true : false,\n        extraKeys: keyMaps,\n        direction: options.direction,\n        lineWrapping: (options.lineWrapping === false) ? false : true,\n        allowDropFileTypes: ['text/plain'],\n        placeholder: options.placeholder || el.getAttribute('placeholder') || '',\n        styleSelectedText: (options.styleSelectedText != undefined) ? options.styleSelectedText : !isMobile(),\n        scrollbarStyle: (options.scrollbarStyle != undefined) ? options.scrollbarStyle : 'native',\n        configureMouse: configureMouse,\n        inputStyle: (options.inputStyle != undefined) ? options.inputStyle : isMobile() ? 'contenteditable' : 'textarea',\n        spellcheck: (options.nativeSpellcheck != undefined) ? options.nativeSpellcheck : true,\n        autoRefresh: (options.autoRefresh != undefined) ? options.autoRefresh : false,\n    });\n\n    this.codemirror.getScrollerElement().style.minHeight = options.minHeight;\n\n    if (typeof options.maxHeight !== 'undefined') {\n        this.codemirror.getScrollerElement().style.height = options.maxHeight;\n    }\n\n    if (options.forceSync === true) {\n        var cm = this.codemirror;\n        cm.on('change', function () {\n            cm.save();\n        });\n    }\n\n    this.gui = {};\n\n    // Wrap Codemirror with container before create toolbar, etc,\n    // to use with sideBySideFullscreen option.\n    var easyMDEContainer = document.createElement('div');\n    easyMDEContainer.classList.add('EasyMDEContainer');\n    easyMDEContainer.setAttribute('role', 'application');\n    var cmWrapper = this.codemirror.getWrapperElement();\n    cmWrapper.parentNode.insertBefore(easyMDEContainer, cmWrapper);\n    easyMDEContainer.appendChild(cmWrapper);\n\n    if (options.toolbar !== false) {\n        this.gui.toolbar = this.createToolbar();\n    }\n    if (options.status !== false) {\n        this.gui.statusbar = this.createStatusbar();\n    }\n    if (options.autosave != undefined && options.autosave.enabled === true) {\n        this.autosave(); // use to load localstorage content\n        this.codemirror.on('change', function () {\n            clearTimeout(self._autosave_timeout);\n            self._autosave_timeout = setTimeout(function () {\n                self.autosave();\n            }, self.options.autosave.submit_delay || self.options.autosave.delay || 1000);\n        });\n    }\n\n    function calcHeight(naturalWidth, naturalHeight) {\n        var height;\n        var viewportWidth = window.getComputedStyle(document.querySelector('.CodeMirror-sizer')).width.replace('px', '');\n        if (naturalWidth < viewportWidth) {\n            height = naturalHeight + 'px';\n        } else {\n            height = (naturalHeight / naturalWidth * 100) + '%';\n        }\n        return height;\n    }\n\n    var _vm = this;\n\n\n    function assignImageBlockAttributes(parentEl, img) {\n        parentEl.setAttribute('data-img-src', img.url);\n        parentEl.setAttribute('style', '--bg-image:url(' + img.url + ');--width:' + img.naturalWidth + 'px;--height:' + calcHeight(img.naturalWidth, img.naturalHeight));\n        _vm.codemirror.setSize();\n    }\n\n    function handleImages() {\n        if (!options.previewImagesInEditor) {\n            return;\n        }\n\n        easyMDEContainer.querySelectorAll('.cm-image-marker').forEach(function (e) {\n            var parentEl = e.parentElement;\n            if (!parentEl.innerText.match(/^!\\[.*?\\]\\(.*\\)/g)) {\n                // if img pasted on the same line with other text, don't preview, preview only images on separate line\n                return;\n            }\n            if (!parentEl.hasAttribute('data-img-src')) {\n                var srcAttr = parentEl.innerText.match('\\\\((.*)\\\\)'); // might require better parsing according to markdown spec\n                if (!window.EMDEimagesCache) {\n                    window.EMDEimagesCache = {};\n                }\n\n                if (srcAttr && srcAttr.length >= 2) {\n                    var keySrc = srcAttr[1];\n\n                    if (options.imagesPreviewHandler) {\n                        var newSrc = options.imagesPreviewHandler(srcAttr[1]);\n                        // defensive check making sure the handler provided by the user returns a string\n                        if (typeof newSrc === 'string') {\n                            keySrc = newSrc;\n                        }\n                    }\n\n                    if (!window.EMDEimagesCache[keySrc]) {\n                        var img = document.createElement('img');\n                        img.onload = function () {\n                            window.EMDEimagesCache[keySrc] = {\n                                naturalWidth: img.naturalWidth,\n                                naturalHeight: img.naturalHeight,\n                                url: keySrc,\n                            };\n                            assignImageBlockAttributes(parentEl, window.EMDEimagesCache[keySrc]);\n                        };\n                        img.src = keySrc;\n                    } else {\n                        assignImageBlockAttributes(parentEl, window.EMDEimagesCache[keySrc]);\n                    }\n                }\n            }\n        });\n    }\n\n    this.codemirror.on('update', function () {\n        handleImages();\n    });\n\n    this.gui.sideBySide = this.createSideBySide();\n    this._rendered = this.element;\n\n    if (options.autofocus === true || el.autofocus) {\n        this.codemirror.focus();\n    }\n\n    // Fixes CodeMirror bug (#344)\n    var temp_cm = this.codemirror;\n    setTimeout(function () {\n        temp_cm.refresh();\n    }.bind(temp_cm), 0);\n};\n\nEasyMDE.prototype.cleanup = function () {\n    document.removeEventListener('keydown', this.documentOnKeyDown);\n};\n\n// Safari, in Private Browsing Mode, looks like it supports localStorage but all calls to setItem throw QuotaExceededError. We're going to detect this and set a variable accordingly.\nfunction isLocalStorageAvailable() {\n    if (typeof localStorage === 'object') {\n        try {\n            localStorage.setItem('smde_localStorage', 1);\n            localStorage.removeItem('smde_localStorage');\n        } catch (e) {\n            return false;\n        }\n    } else {\n        return false;\n    }\n\n    return true;\n}\n\nEasyMDE.prototype.autosave = function () {\n    if (isLocalStorageAvailable()) {\n        var easyMDE = this;\n\n        if (this.options.autosave.uniqueId == undefined || this.options.autosave.uniqueId == '') {\n            console.log('EasyMDE: You must set a uniqueId to use the autosave feature');\n            return;\n        }\n\n        if (this.options.autosave.binded !== true) {\n            if (easyMDE.element.form != null && easyMDE.element.form != undefined) {\n                easyMDE.element.form.addEventListener('submit', function () {\n                    clearTimeout(easyMDE.autosaveTimeoutId);\n                    easyMDE.autosaveTimeoutId = undefined;\n\n                    localStorage.removeItem('smde_' + easyMDE.options.autosave.uniqueId);\n                });\n            }\n\n            this.options.autosave.binded = true;\n        }\n\n        if (this.options.autosave.loaded !== true) {\n            if (typeof localStorage.getItem('smde_' + this.options.autosave.uniqueId) == 'string' && localStorage.getItem('smde_' + this.options.autosave.uniqueId) != '') {\n                this.codemirror.setValue(localStorage.getItem('smde_' + this.options.autosave.uniqueId));\n                this.options.autosave.foundSavedValue = true;\n            }\n\n            this.options.autosave.loaded = true;\n        }\n\n        var value = easyMDE.value();\n        if (value !== '') {\n            localStorage.setItem('smde_' + this.options.autosave.uniqueId, value);\n        } else {\n            localStorage.removeItem('smde_' + this.options.autosave.uniqueId);\n        }\n\n        var el = document.getElementById('autosaved');\n        if (el != null && el != undefined && el != '') {\n            var d = new Date();\n            var dd = new Intl.DateTimeFormat([this.options.autosave.timeFormat.locale, 'en-US'], this.options.autosave.timeFormat.format).format(d);\n            var save = this.options.autosave.text == undefined ? 'Autosaved: ' : this.options.autosave.text;\n\n            el.innerHTML = save + dd;\n        }\n    } else {\n        console.log('EasyMDE: localStorage not available, cannot autosave');\n    }\n};\n\nEasyMDE.prototype.clearAutosavedValue = function () {\n    if (isLocalStorageAvailable()) {\n        if (this.options.autosave == undefined || this.options.autosave.uniqueId == undefined || this.options.autosave.uniqueId == '') {\n            console.log('EasyMDE: You must set a uniqueId to clear the autosave value');\n            return;\n        }\n\n        localStorage.removeItem('smde_' + this.options.autosave.uniqueId);\n    } else {\n        console.log('EasyMDE: localStorage not available, cannot autosave');\n    }\n};\n\n/**\n * Open the browse-file window to upload an image to a server.\n * @param [onSuccess] {function} see EasyMDE.prototype.uploadImage\n * @param [onError] {function} see EasyMDE.prototype.uploadImage\n */\nEasyMDE.prototype.openBrowseFileWindow = function (onSuccess, onError) {\n    var self = this;\n    var imageInput = this.gui.toolbar.getElementsByClassName('imageInput')[0];\n    imageInput.click(); //dispatchEvent(new MouseEvent('click'));  // replaced with click() for IE11 compatibility.\n    function onChange(event) {\n        if (self.options.imageUploadFunction) {\n            self.uploadImagesUsingCustomFunction(self.options.imageUploadFunction, event.target.files);\n        } else {\n            self.uploadImages(event.target.files, onSuccess, onError);\n        }\n        imageInput.removeEventListener('change', onChange);\n    }\n\n    imageInput.addEventListener('change', onChange);\n};\n\n/**\n * Upload an image to the server.\n *\n * @param file {File} The image to upload, as a HTML5 File object (https://developer.mozilla.org/en-US/docs/Web/API/File)\n * @param [onSuccess] {function} A callback function to execute after the image has been successfully uploaded, with one parameter:\n * - url (string): The URL of the uploaded image.\n * @param [onError] {function} A callback function to execute when the image upload fails, with one parameter:\n * - error (string): the detailed error to display to the user (based on messages from options.errorMessages).\n */\nEasyMDE.prototype.uploadImage = function (file, onSuccess, onError) {\n    var self = this;\n    onSuccess = onSuccess || function onSuccess(imageUrl) {\n        afterImageUploaded(self, imageUrl);\n    };\n\n    function onErrorSup(errorMessage) {\n        // show error on status bar and reset after 10000ms\n        self.updateStatusBar('upload-image', errorMessage);\n\n        setTimeout(function () {\n            self.updateStatusBar('upload-image', self.options.imageTexts.sbInit);\n        }, 10000);\n\n        // run custom error handler\n        if (onError && typeof onError === 'function') {\n            onError(errorMessage);\n        }\n        // run error handler from options, this alerts the message.\n        self.options.errorCallback(errorMessage);\n    }\n\n    function fillErrorMessage(errorMessage) {\n        var units = self.options.imageTexts.sizeUnits.split(',');\n        return errorMessage\n            .replace('#image_name#', file.name)\n            .replace('#image_size#', humanFileSize(file.size, units))\n            .replace('#image_max_size#', humanFileSize(self.options.imageMaxSize, units));\n    }\n\n    if (file.size > this.options.imageMaxSize) {\n        onErrorSup(fillErrorMessage(this.options.errorMessages.fileTooLarge));\n        return;\n    }\n\n    var formData = new FormData();\n    formData.append('image', file);\n\n    // insert CSRF body token if provided in config.\n    if (self.options.imageCSRFToken && !self.options.imageCSRFHeader) {\n        formData.append(self.options.imageCSRFName, self.options.imageCSRFToken);\n    }\n\n    var request = new XMLHttpRequest();\n    request.upload.onprogress = function (event) {\n        if (event.lengthComputable) {\n            var progress = '' + Math.round((event.loaded * 100) / event.total);\n            self.updateStatusBar('upload-image', self.options.imageTexts.sbProgress.replace('#file_name#', file.name).replace('#progress#', progress));\n        }\n    };\n    request.open('POST', this.options.imageUploadEndpoint);\n\n    // insert CSRF header token if provided in config.\n    if (self.options.imageCSRFToken && self.options.imageCSRFHeader) {\n        request.setRequestHeader(self.options.imageCSRFName, self.options.imageCSRFToken);\n    }\n\n    request.onload = function () {\n        try {\n            var response = JSON.parse(this.responseText);\n        } catch (error) {\n            console.error('EasyMDE: The server did not return a valid json.');\n            onErrorSup(fillErrorMessage(self.options.errorMessages.importError));\n            return;\n        }\n        if (this.status === 200 && response && !response.error && response.data && response.data.filePath) {\n            onSuccess((self.options.imagePathAbsolute ? '' : (window.location.origin + '/')) + response.data.filePath);\n        } else {\n            if (response.error && response.error in self.options.errorMessages) {  // preformatted error message\n                onErrorSup(fillErrorMessage(self.options.errorMessages[response.error]));\n            } else if (response.error) {  // server side generated error message\n                onErrorSup(fillErrorMessage(response.error));\n            } else {  //unknown error\n                console.error('EasyMDE: Received an unexpected response after uploading the image.'\n                    + this.status + ' (' + this.statusText + ')');\n                onErrorSup(fillErrorMessage(self.options.errorMessages.importError));\n            }\n        }\n    };\n\n    request.onerror = function (event) {\n        console.error('EasyMDE: An unexpected error occurred when trying to upload the image.'\n            + event.target.status + ' (' + event.target.statusText + ')');\n        onErrorSup(self.options.errorMessages.importError);\n    };\n\n    request.send(formData);\n\n};\n\n/**\n * Upload an image to the server using a custom upload function.\n *\n * @param imageUploadFunction {Function} The custom function to upload the image passed in options\n * @param file {File} The image to upload, as a HTML5 File object (https://developer.mozilla.org/en-US/docs/Web/API/File).\n */\nEasyMDE.prototype.uploadImageUsingCustomFunction = function (imageUploadFunction, file) {\n    var self = this;\n\n    function onSuccess(imageUrl) {\n        afterImageUploaded(self, imageUrl);\n    }\n\n    function onError(errorMessage) {\n        var filledErrorMessage = fillErrorMessage(errorMessage);\n        // show error on status bar and reset after 10000ms\n        self.updateStatusBar('upload-image', filledErrorMessage);\n\n        setTimeout(function () {\n            self.updateStatusBar('upload-image', self.options.imageTexts.sbInit);\n        }, 10000);\n\n        // run error handler from options, this alerts the message.\n        self.options.errorCallback(filledErrorMessage);\n    }\n\n    function fillErrorMessage(errorMessage) {\n        var units = self.options.imageTexts.sizeUnits.split(',');\n        return errorMessage\n            .replace('#image_name#', file.name)\n            .replace('#image_size#', humanFileSize(file.size, units))\n            .replace('#image_max_size#', humanFileSize(self.options.imageMaxSize, units));\n    }\n\n    imageUploadFunction.apply(this, [file, onSuccess, onError]);\n};\n\nEasyMDE.prototype.setPreviewMaxHeight = function () {\n    var cm = this.codemirror;\n    var wrapper = cm.getWrapperElement();\n    var preview = wrapper.nextSibling;\n\n    // Calc preview max height\n    var paddingTop = parseInt(window.getComputedStyle(wrapper).paddingTop);\n    var borderTopWidth = parseInt(window.getComputedStyle(wrapper).borderTopWidth);\n    var optionsMaxHeight = parseInt(this.options.maxHeight);\n    var wrapperMaxHeight = optionsMaxHeight + paddingTop * 2 + borderTopWidth * 2;\n    var previewMaxHeight = wrapperMaxHeight.toString() + 'px';\n\n    preview.style.height = previewMaxHeight;\n};\n\nEasyMDE.prototype.createSideBySide = function () {\n    var cm = this.codemirror;\n    var wrapper = cm.getWrapperElement();\n    var preview = wrapper.nextSibling;\n\n    if (!preview || !preview.classList.contains('editor-preview-side')) {\n        preview = document.createElement('div');\n        preview.className = 'editor-preview-side';\n\n        if (this.options.previewClass) {\n\n            if (Array.isArray(this.options.previewClass)) {\n                for (var i = 0; i < this.options.previewClass.length; i++) {\n                    preview.classList.add(this.options.previewClass[i]);\n                }\n\n            } else if (typeof this.options.previewClass === 'string') {\n                preview.classList.add(this.options.previewClass);\n            }\n        }\n\n        wrapper.parentNode.insertBefore(preview, wrapper.nextSibling);\n    }\n\n    if (typeof this.options.maxHeight !== 'undefined') {\n        this.setPreviewMaxHeight();\n    }\n\n    if (this.options.syncSideBySidePreviewScroll === false) return preview;\n    // Syncs scroll  editor -> preview\n    var cScroll = false;\n    var pScroll = false;\n    cm.on('scroll', function (v) {\n        if (cScroll) {\n            cScroll = false;\n            return;\n        }\n        pScroll = true;\n        var height = v.getScrollInfo().height - v.getScrollInfo().clientHeight;\n        var ratio = parseFloat(v.getScrollInfo().top) / height;\n        var move = (preview.scrollHeight - preview.clientHeight) * ratio;\n        preview.scrollTop = move;\n    });\n\n    // Syncs scroll  preview -> editor\n    preview.onscroll = function () {\n        if (pScroll) {\n            pScroll = false;\n            return;\n        }\n        cScroll = true;\n        var height = preview.scrollHeight - preview.clientHeight;\n        var ratio = parseFloat(preview.scrollTop) / height;\n        var move = (cm.getScrollInfo().height - cm.getScrollInfo().clientHeight) * ratio;\n        cm.scrollTo(0, move);\n    };\n    return preview;\n};\n\nEasyMDE.prototype.createToolbar = function (items) {\n    items = items || this.options.toolbar;\n\n    if (!items || items.length === 0) {\n        return;\n    }\n    var i;\n    for (i = 0; i < items.length; i++) {\n        if (toolbarBuiltInButtons[items[i]] != undefined) {\n            items[i] = toolbarBuiltInButtons[items[i]];\n        }\n    }\n\n    var bar = document.createElement('div');\n    bar.className = 'editor-toolbar';\n    bar.setAttribute('role', 'toolbar');\n\n    var self = this;\n\n    var toolbarData = {};\n    self.toolbar = items;\n\n    for (i = 0; i < items.length; i++) {\n        if (items[i].name == 'guide' && self.options.toolbarGuideIcon === false)\n            continue;\n\n        if (self.options.hideIcons && self.options.hideIcons.indexOf(items[i].name) != -1)\n            continue;\n\n        // Fullscreen does not work well on mobile devices (even tablets)\n        // In the future, hopefully this can be resolved\n        if ((items[i].name == 'fullscreen' || items[i].name == 'side-by-side') && isMobile())\n            continue;\n\n\n        // Don't include trailing separators\n        if (items[i] === '|') {\n            var nonSeparatorIconsFollow = false;\n\n            for (var x = (i + 1); x < items.length; x++) {\n                if (items[x] !== '|' && (!self.options.hideIcons || self.options.hideIcons.indexOf(items[x].name) == -1)) {\n                    nonSeparatorIconsFollow = true;\n                }\n            }\n\n            if (!nonSeparatorIconsFollow)\n                continue;\n        }\n\n\n        // Create the icon and append to the toolbar\n        (function (item) {\n            var el;\n            if (item === '|') {\n                el = createSep();\n            } else if (item.children) {\n                el = createToolbarDropdown(item, self.options.toolbarTips, self.options.shortcuts, self);\n            } else {\n                el = createToolbarButton(item, true, self.options.toolbarTips, self.options.shortcuts, 'button', self);\n            }\n\n\n            toolbarData[item.name || item] = el;\n            bar.appendChild(el);\n\n            // Create the input element (ie. <input type='file'>), used among\n            // with the 'import-image' icon to open the browse-file window.\n            if (item.name === 'upload-image') {\n                var imageInput = document.createElement('input');\n                imageInput.className = 'imageInput';\n                imageInput.type = 'file';\n                imageInput.multiple = true;\n                imageInput.name = 'image';\n                imageInput.accept = self.options.imageAccept;\n                imageInput.style.display = 'none';\n                imageInput.style.opacity = 0;\n                bar.appendChild(imageInput);\n            }\n        })(items[i]);\n    }\n\n    self.toolbar_div = bar;\n    self.toolbarElements = toolbarData;\n\n    var cm = this.codemirror;\n    cm.on('cursorActivity', function () {\n        var stat = getState(cm);\n\n        for (var key in toolbarData) {\n            (function (key) {\n                var el = toolbarData[key];\n                if (stat[key]) {\n                    el.classList.add('active');\n                } else if (key != 'fullscreen' && key != 'side-by-side') {\n                    el.classList.remove('active');\n                }\n            })(key);\n        }\n    });\n\n    var cmWrapper = cm.getWrapperElement();\n    cmWrapper.parentNode.insertBefore(bar, cmWrapper);\n    return bar;\n};\n\nEasyMDE.prototype.createStatusbar = function (status) {\n    // Initialize\n    status = status || this.options.status;\n    var options = this.options;\n    var cm = this.codemirror;\n\n    // Make sure the status variable is valid\n    if (!status || status.length === 0) {\n        return;\n    }\n\n    // Set up the built-in items\n    var items = [];\n    var i, onUpdate, onActivity, defaultValue;\n\n    for (i = 0; i < status.length; i++) {\n        // Reset some values\n        onUpdate = undefined;\n        onActivity = undefined;\n        defaultValue = undefined;\n\n\n        // Handle if custom or not\n        if (typeof status[i] === 'object') {\n            items.push({\n                className: status[i].className,\n                defaultValue: status[i].defaultValue,\n                onUpdate: status[i].onUpdate,\n                onActivity: status[i].onActivity,\n            });\n        } else {\n            var name = status[i];\n\n            if (name === 'words') {\n                defaultValue = function (el) {\n                    el.innerHTML = wordCount(cm.getValue());\n                };\n                onUpdate = function (el) {\n                    el.innerHTML = wordCount(cm.getValue());\n                };\n            } else if (name === 'lines') {\n                defaultValue = function (el) {\n                    el.innerHTML = cm.lineCount();\n                };\n                onUpdate = function (el) {\n                    el.innerHTML = cm.lineCount();\n                };\n            } else if (name === 'cursor') {\n                defaultValue = function (el) {\n                    el.innerHTML = '1:1';\n                };\n                onActivity = function (el) {\n                    var pos = cm.getCursor();\n                    var posLine = pos.line + 1;\n                    var posColumn = pos.ch + 1;\n                    el.innerHTML = posLine + ':' + posColumn;\n                };\n            } else if (name === 'autosave') {\n                defaultValue = function (el) {\n                    if (options.autosave != undefined && options.autosave.enabled === true) {\n                        el.setAttribute('id', 'autosaved');\n                    }\n                };\n            } else if (name === 'upload-image') {\n                defaultValue = function (el) {\n                    el.innerHTML = options.imageTexts.sbInit;\n                };\n            }\n\n            items.push({\n                className: name,\n                defaultValue: defaultValue,\n                onUpdate: onUpdate,\n                onActivity: onActivity,\n            });\n        }\n    }\n\n\n    // Create element for the status bar\n    var bar = document.createElement('div');\n    bar.className = 'editor-statusbar';\n\n\n    // Create a new span for each item\n    for (i = 0; i < items.length; i++) {\n        // Store in temporary variable\n        var item = items[i];\n\n\n        // Create span element\n        var el = document.createElement('span');\n        el.className = item.className;\n\n\n        // Ensure the defaultValue is a function\n        if (typeof item.defaultValue === 'function') {\n            item.defaultValue(el);\n        }\n\n\n        // Ensure the onUpdate is a function\n        if (typeof item.onUpdate === 'function') {\n            // Create a closure around the span of the current action, then execute the onUpdate handler\n            this.codemirror.on('update', (function (el, item) {\n                return function () {\n                    item.onUpdate(el);\n                };\n            }(el, item)));\n        }\n        if (typeof item.onActivity === 'function') {\n            // Create a closure around the span of the current action, then execute the onActivity handler\n            this.codemirror.on('cursorActivity', (function (el, item) {\n                return function () {\n                    item.onActivity(el);\n                };\n            }(el, item)));\n        }\n\n\n        // Append the item to the status bar\n        bar.appendChild(el);\n    }\n\n\n    // Insert the status bar into the DOM\n    var cmWrapper = this.codemirror.getWrapperElement();\n    cmWrapper.parentNode.insertBefore(bar, cmWrapper.nextSibling);\n    return bar;\n};\n\n/**\n * Get or set the text content.\n */\nEasyMDE.prototype.value = function (val) {\n    var cm = this.codemirror;\n    if (val === undefined) {\n        return cm.getValue();\n    } else {\n        cm.getDoc().setValue(val);\n        if (this.isPreviewActive()) {\n            var wrapper = cm.getWrapperElement();\n            var preview = wrapper.lastChild;\n            var preview_result = this.options.previewRender(val, preview);\n            if (preview_result !== null) {\n                preview.innerHTML = preview_result;\n            }\n\n        }\n        return this;\n    }\n};\n\n\n/**\n * Bind static methods for exports.\n */\nEasyMDE.toggleBold = toggleBold;\nEasyMDE.toggleItalic = toggleItalic;\nEasyMDE.toggleStrikethrough = toggleStrikethrough;\nEasyMDE.toggleBlockquote = toggleBlockquote;\nEasyMDE.toggleHeadingSmaller = toggleHeadingSmaller;\nEasyMDE.toggleHeadingBigger = toggleHeadingBigger;\nEasyMDE.toggleHeading1 = toggleHeading1;\nEasyMDE.toggleHeading2 = toggleHeading2;\nEasyMDE.toggleHeading3 = toggleHeading3;\nEasyMDE.toggleHeading4 = toggleHeading4;\nEasyMDE.toggleHeading5 = toggleHeading5;\nEasyMDE.toggleHeading6 = toggleHeading6;\nEasyMDE.toggleCodeBlock = toggleCodeBlock;\nEasyMDE.toggleUnorderedList = toggleUnorderedList;\nEasyMDE.toggleOrderedList = toggleOrderedList;\nEasyMDE.cleanBlock = cleanBlock;\nEasyMDE.drawLink = drawLink;\nEasyMDE.drawImage = drawImage;\nEasyMDE.drawUploadedImage = drawUploadedImage;\nEasyMDE.drawTable = drawTable;\nEasyMDE.drawHorizontalRule = drawHorizontalRule;\nEasyMDE.undo = undo;\nEasyMDE.redo = redo;\nEasyMDE.togglePreview = togglePreview;\nEasyMDE.toggleSideBySide = toggleSideBySide;\nEasyMDE.toggleFullScreen = toggleFullScreen;\n\n/**\n * Bind instance methods for exports.\n */\nEasyMDE.prototype.toggleBold = function () {\n    toggleBold(this);\n};\nEasyMDE.prototype.toggleItalic = function () {\n    toggleItalic(this);\n};\nEasyMDE.prototype.toggleStrikethrough = function () {\n    toggleStrikethrough(this);\n};\nEasyMDE.prototype.toggleBlockquote = function () {\n    toggleBlockquote(this);\n};\nEasyMDE.prototype.toggleHeadingSmaller = function () {\n    toggleHeadingSmaller(this);\n};\nEasyMDE.prototype.toggleHeadingBigger = function () {\n    toggleHeadingBigger(this);\n};\nEasyMDE.prototype.toggleHeading1 = function () {\n    toggleHeading1(this);\n};\nEasyMDE.prototype.toggleHeading2 = function () {\n    toggleHeading2(this);\n};\nEasyMDE.prototype.toggleHeading3 = function () {\n    toggleHeading3(this);\n};\nEasyMDE.prototype.toggleHeading4 = function () {\n    toggleHeading4(this);\n};\nEasyMDE.prototype.toggleHeading5 = function () {\n    toggleHeading5(this);\n};\nEasyMDE.prototype.toggleHeading6 = function () {\n    toggleHeading6(this);\n};\nEasyMDE.prototype.toggleCodeBlock = function () {\n    toggleCodeBlock(this);\n};\nEasyMDE.prototype.toggleUnorderedList = function () {\n    toggleUnorderedList(this);\n};\nEasyMDE.prototype.toggleOrderedList = function () {\n    toggleOrderedList(this);\n};\nEasyMDE.prototype.cleanBlock = function () {\n    cleanBlock(this);\n};\nEasyMDE.prototype.drawLink = function () {\n    drawLink(this);\n};\nEasyMDE.prototype.drawImage = function () {\n    drawImage(this);\n};\nEasyMDE.prototype.drawUploadedImage = function () {\n    drawUploadedImage(this);\n};\nEasyMDE.prototype.drawTable = function () {\n    drawTable(this);\n};\nEasyMDE.prototype.drawHorizontalRule = function () {\n    drawHorizontalRule(this);\n};\nEasyMDE.prototype.undo = function () {\n    undo(this);\n};\nEasyMDE.prototype.redo = function () {\n    redo(this);\n};\nEasyMDE.prototype.togglePreview = function () {\n    togglePreview(this);\n};\nEasyMDE.prototype.toggleSideBySide = function () {\n    toggleSideBySide(this);\n};\nEasyMDE.prototype.toggleFullScreen = function () {\n    toggleFullScreen(this);\n};\n\nEasyMDE.prototype.isPreviewActive = function () {\n    var cm = this.codemirror;\n    var wrapper = cm.getWrapperElement();\n    var preview = wrapper.lastChild;\n\n    return preview.classList.contains('editor-preview-active');\n};\n\nEasyMDE.prototype.isSideBySideActive = function () {\n    var cm = this.codemirror;\n    var wrapper = cm.getWrapperElement();\n    var preview = wrapper.nextSibling;\n\n    return preview.classList.contains('editor-preview-active-side');\n};\n\nEasyMDE.prototype.isFullscreenActive = function () {\n    var cm = this.codemirror;\n\n    return cm.getOption('fullScreen');\n};\n\nEasyMDE.prototype.getState = function () {\n    var cm = this.codemirror;\n\n    return getState(cm);\n};\n\nEasyMDE.prototype.toTextArea = function () {\n    var cm = this.codemirror;\n    var wrapper = cm.getWrapperElement();\n    var easyMDEContainer = wrapper.parentNode;\n\n    if (easyMDEContainer) {\n        if (this.gui.toolbar) {\n            easyMDEContainer.removeChild(this.gui.toolbar);\n        }\n        if (this.gui.statusbar) {\n            easyMDEContainer.removeChild(this.gui.statusbar);\n        }\n        if (this.gui.sideBySide) {\n            easyMDEContainer.removeChild(this.gui.sideBySide);\n        }\n    }\n\n    // Unwrap easyMDEcontainer before codemirror toTextArea() call\n    easyMDEContainer.parentNode.insertBefore(wrapper, easyMDEContainer);\n    easyMDEContainer.remove();\n\n    cm.toTextArea();\n\n    if (this.autosaveTimeoutId) {\n        clearTimeout(this.autosaveTimeoutId);\n        this.autosaveTimeoutId = undefined;\n        this.clearAutosavedValue();\n    }\n};\n\nmodule.exports = EasyMDE;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWFzeW1kZS9zcmMvanMvZWFzeW1kZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGlCQUFpQixtQkFBTyxDQUFDLHFFQUFZO0FBQ3JDLG1CQUFPLENBQUMseUdBQXVDO0FBQy9DLG1CQUFPLENBQUMsdUZBQXNCO0FBQzlCLG1CQUFPLENBQUMsMkdBQXdDO0FBQ2hELG1CQUFPLENBQUMsdUdBQXNDO0FBQzlDLG1CQUFPLENBQUMsK0ZBQWtDO0FBQzFDLG1CQUFPLENBQUMsNkdBQXlDO0FBQ2pELG1CQUFPLENBQUMsNkdBQXlDO0FBQ2pELG1CQUFPLENBQUMsdUhBQThDO0FBQ3RELG1CQUFPLENBQUMsNkdBQXlDO0FBQ2pELG1CQUFPLENBQUMsbUZBQTRCO0FBQ3BDLG1CQUFPLENBQUMsbUZBQTRCO0FBQ3BDLDZCQUE2QixtQkFBTyxDQUFDLHVHQUEwQjtBQUMvRCxhQUFhLHdGQUF3Qjs7O0FBR3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FB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QUFvQixzQkFBc0I7QUFDMUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7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QTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0Esd0VBQXdFLG1DQUFtQztBQUMzRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7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QUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Vhc3ltZGUvc3JjL2pzL2Vhc3ltZGUuanM/ZjFiYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgQ29kZU1pcnJvciA9IHJlcXVpcmUoJ2NvZGVtaXJyb3InKTtcbnJlcXVpcmUoJ2NvZGVtaXJyb3IvYWRkb24vZWRpdC9jb250aW51ZWxpc3QuanMnKTtcbnJlcXVpcmUoJy4vY29kZW1pcnJvci90YWJsaXN0Jyk7XG5yZXF1aXJlKCdjb2RlbWlycm9yL2FkZG9uL2Rpc3BsYXkvZnVsbHNjcmVlbi5qcycpO1xucmVxdWlyZSgnY29kZW1pcnJvci9tb2RlL21hcmtkb3duL21hcmtkb3duLmpzJyk7XG5yZXF1aXJlKCdjb2RlbWlycm9yL2FkZG9uL21vZGUvb3ZlcmxheS5qcycpO1xucmVxdWlyZSgnY29kZW1pcnJvci9hZGRvbi9kaXNwbGF5L3BsYWNlaG9sZGVyLmpzJyk7XG5yZXF1aXJlKCdjb2RlbWlycm9yL2FkZG9uL2Rpc3BsYXkvYXV0b3JlZnJlc2guanMnKTtcbnJlcXVpcmUoJ2NvZGVtaXJyb3IvYWRkb24vc2VsZWN0aW9uL21hcmstc2VsZWN0aW9uLmpzJyk7XG5yZXF1aXJlKCdjb2RlbWlycm9yL2FkZG9uL3NlYXJjaC9zZWFyY2hjdXJzb3IuanMnKTtcbnJlcXVpcmUoJ2NvZGVtaXJyb3IvbW9kZS9nZm0vZ2ZtLmpzJyk7XG5yZXF1aXJlKCdjb2RlbWlycm9yL21vZGUveG1sL3htbC5qcycpO1xudmFyIENvZGVNaXJyb3JTcGVsbENoZWNrZXIgPSByZXF1aXJlKCdjb2RlbWlycm9yLXNwZWxsLWNoZWNrZXInKTtcbnZhciBtYXJrZWQgPSByZXF1aXJlKCdtYXJrZWQnKS5tYXJrZWQ7XG5cblxuLy8gU29tZSB2YXJpYWJsZXNcbnZhciBpc01hYyA9IC9NYWMvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcbnZhciBhbmNob3JUb0V4dGVybmFsUmVnZXggPSBuZXcgUmVnRXhwKC8oPGEuKj9odHRwcz86XFwvXFwvLio/W15hXT4pKz8vZyk7XG5cbi8vIE1hcHBpbmcgb2YgYWN0aW9ucyB0aGF0IGNhbiBiZSBib3VuZCB0byBrZXlib2FyZCBzaG9ydGN1dHMgb3IgdG9vbGJhciBidXR0b25zXG52YXIgYmluZGluZ3MgPSB7XG4gICAgJ3RvZ2dsZUJvbGQnOiB0b2dnbGVCb2xkLFxuICAgICd0b2dnbGVJdGFsaWMnOiB0b2dnbGVJdGFsaWMsXG4gICAgJ2RyYXdMaW5rJzogZHJhd0xpbmssXG4gICAgJ3RvZ2dsZUhlYWRpbmdTbWFsbGVyJzogdG9nZ2xlSGVhZGluZ1NtYWxsZXIsXG4gICAgJ3RvZ2dsZUhlYWRpbmdCaWdnZXInOiB0b2dnbGVIZWFkaW5nQmlnZ2VyLFxuICAgICdkcmF3SW1hZ2UnOiBkcmF3SW1hZ2UsXG4gICAgJ3RvZ2dsZUJsb2NrcXVvdGUnOiB0b2dnbGVCbG9ja3F1b3RlLFxuICAgICd0b2dnbGVPcmRlcmVkTGlzdCc6IHRvZ2dsZU9yZGVyZWRMaXN0LFxuICAgICd0b2dnbGVVbm9yZGVyZWRMaXN0JzogdG9nZ2xlVW5vcmRlcmVkTGlzdCxcbiAgICAndG9nZ2xlQ29kZUJsb2NrJzogdG9nZ2xlQ29kZUJsb2NrLFxuICAgICd0b2dnbGVQcmV2aWV3JzogdG9nZ2xlUHJldmlldyxcbiAgICAndG9nZ2xlU3RyaWtldGhyb3VnaCc6IHRvZ2dsZVN0cmlrZXRocm91Z2gsXG4gICAgJ3RvZ2dsZUhlYWRpbmcxJzogdG9nZ2xlSGVhZGluZzEsXG4gICAgJ3RvZ2dsZUhlYWRpbmcyJzogdG9nZ2xlSGVhZGluZzIsXG4gICAgJ3RvZ2dsZUhlYWRpbmczJzogdG9nZ2xlSGVhZGluZzMsXG4gICAgJ3RvZ2dsZUhlYWRpbmc0JzogdG9nZ2xlSGVhZGluZzQsXG4gICAgJ3RvZ2dsZUhlYWRpbmc1JzogdG9nZ2xlSGVhZGluZzUsXG4gICAgJ3RvZ2dsZUhlYWRpbmc2JzogdG9nZ2xlSGVhZGluZzYsXG4gICAgJ2NsZWFuQmxvY2snOiBjbGVhbkJsb2NrLFxuICAgICdkcmF3VGFibGUnOiBkcmF3VGFibGUsXG4gICAgJ2RyYXdIb3Jpem9udGFsUnVsZSc6IGRyYXdIb3Jpem9udGFsUnVsZSxcbiAgICAndW5kbyc6IHVuZG8sXG4gICAgJ3JlZG8nOiByZWRvLFxuICAgICd0b2dnbGVTaWRlQnlTaWRlJzogdG9nZ2xlU2lkZUJ5U2lkZSxcbiAgICAndG9nZ2xlRnVsbFNjcmVlbic6IHRvZ2dsZUZ1bGxTY3JlZW4sXG59O1xuXG52YXIgc2hvcnRjdXRzID0ge1xuICAgICd0b2dnbGVCb2xkJzogJ0NtZC1CJyxcbiAgICAndG9nZ2xlSXRhbGljJzogJ0NtZC1JJyxcbiAgICAnZHJhd0xpbmsnOiAnQ21kLUsnLFxuICAgICd0b2dnbGVIZWFkaW5nU21hbGxlcic6ICdDbWQtSCcsXG4gICAgJ3RvZ2dsZUhlYWRpbmdCaWdnZXInOiAnU2hpZnQtQ21kLUgnLFxuICAgICd0b2dnbGVIZWFkaW5nMSc6ICdDdHJsK0FsdCsxJyxcbiAgICAndG9nZ2xlSGVhZGluZzInOiAnQ3RybCtBbHQrMicsXG4gICAgJ3RvZ2dsZUhlYWRpbmczJzogJ0N0cmwrQWx0KzMnLFxuICAgICd0b2dnbGVIZWFkaW5nNCc6ICdDdHJsK0FsdCs0JyxcbiAgICAndG9nZ2xlSGVhZGluZzUnOiAnQ3RybCtBbHQrNScsXG4gICAgJ3RvZ2dsZUhlYWRpbmc2JzogJ0N0cmwrQWx0KzYnLFxuICAgICdjbGVhbkJsb2NrJzogJ0NtZC1FJyxcbiAgICAnZHJhd0ltYWdlJzogJ0NtZC1BbHQtSScsXG4gICAgJ3RvZ2dsZUJsb2NrcXVvdGUnOiAnQ21kLVxcJycsXG4gICAgJ3RvZ2dsZU9yZGVyZWRMaXN0JzogJ0NtZC1BbHQtTCcsXG4gICAgJ3RvZ2dsZVVub3JkZXJlZExpc3QnOiAnQ21kLUwnLFxuICAgICd0b2dnbGVDb2RlQmxvY2snOiAnQ21kLUFsdC1DJyxcbiAgICAndG9nZ2xlUHJldmlldyc6ICdDbWQtUCcsXG4gICAgJ3RvZ2dsZVNpZGVCeVNpZGUnOiAnRjknLFxuICAgICd0b2dnbGVGdWxsU2NyZWVuJzogJ0YxMScsXG59O1xuXG52YXIgZ2V0QmluZGluZ05hbWUgPSBmdW5jdGlvbiAoZikge1xuICAgIGZvciAodmFyIGtleSBpbiBiaW5kaW5ncykge1xuICAgICAgICBpZiAoYmluZGluZ3Nba2V5XSA9PT0gZikge1xuICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbnZhciBpc01vYmlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2hlY2sgPSBmYWxzZTtcbiAgICAoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgaWYgKC8oYW5kcm9pZHxiYlxcZCt8bWVlZ28pLittb2JpbGV8YXZhbnRnb3xiYWRhXFwvfGJsYWNrYmVycnl8YmxhemVyfGNvbXBhbHxlbGFpbmV8ZmVubmVjfGhpcHRvcHxpZW1vYmlsZXxpcChob25lfG9kKXxpcmlzfGtpbmRsZXxsZ2UgfG1hZW1vfG1pZHB8bW1wfG1vYmlsZS4rZmlyZWZveHxuZXRmcm9udHxvcGVyYSBtKG9ifGluKWl8cGFsbSggb3MpP3xwaG9uZXxwKGl4aXxyZSlcXC98cGx1Y2tlcnxwb2NrZXR8cHNwfHNlcmllcyg0fDYpMHxzeW1iaWFufHRyZW98dXBcXC4oYnJvd3NlcnxsaW5rKXx2b2RhZm9uZXx3YXB8d2luZG93cyBjZXx4ZGF8eGlpbm98YW5kcm9pZHxpcGFkfHBsYXlib29rfHNpbGsvaS50ZXN0KGEpIHx8IC8xMjA3fDYzMTB8NjU5MHwzZ3NvfDR0aHB8NTBbMS02XWl8Nzcwc3w4MDJzfGEgd2F8YWJhY3xhYyhlcnxvb3xzLSl8YWkoa298cm4pfGFsKGF2fGNhfGNvKXxhbW9pfGFuKGV4fG55fHl3KXxhcHR1fGFyKGNofGdvKXxhcyh0ZXx1cyl8YXR0d3xhdShkaXwtbXxyIHxzICl8YXZhbnxiZShja3xsbHxucSl8YmkobGJ8cmQpfGJsKGFjfGF6KXxicihlfHYpd3xidW1ifGJ3LShufHUpfGM1NVxcL3xjYXBpfGNjd2F8Y2RtLXxjZWxsfGNodG18Y2xkY3xjbWQtfGNvKG1wfG5kKXxjcmF3fGRhKGl0fGxsfG5nKXxkYnRlfGRjLXN8ZGV2aXxkaWNhfGRtb2J8ZG8oY3xwKW98ZHMoMTJ8LWQpfGVsKDQ5fGFpKXxlbShsMnx1bCl8ZXIoaWN8azApfGVzbDh8ZXooWzQtN10wfG9zfHdhfHplKXxmZXRjfGZseSgtfF8pfGcxIHV8ZzU2MHxnZW5lfGdmLTV8Zy1tb3xnbyhcXC53fG9kKXxncihhZHx1bil8aGFpZXxoY2l0fGhkLShtfHB8dCl8aGVpLXxoaShwdHx0YSl8aHAoIGl8aXApfGhzLWN8aHQoYygtfCB8X3xhfGd8cHxzfHQpfHRwKXxodShhd3x0Yyl8aS0oMjB8Z298bWEpfGkyMzB8aWFjKCB8LXxcXC8pfGlicm98aWRlYXxpZzAxfGlrb218aW0xa3xpbm5vfGlwYXF8aXJpc3xqYSh0fHYpYXxqYnJvfGplbXV8amlnc3xrZGRpfGtlaml8a2d0KCB8XFwvKXxrbG9ufGtwdCB8a3djLXxreW8oY3xrKXxsZShub3x4aSl8bGcoIGd8XFwvKGt8bHx1KXw1MHw1NHwtW2Etd10pfGxpYnd8bHlueHxtMS13fG0zZ2F8bTUwXFwvfG1hKHRlfHVpfHhvKXxtYygwMXwyMXxjYSl8bS1jcnxtZShyY3xyaSl8bWkobzh8b2F8dHMpfG1tZWZ8bW8oMDF8MDJ8Yml8ZGV8ZG98dCgtfCB8b3x2KXx6eil8bXQoNTB8cDF8diApfG13YnB8bXl3YXxuMTBbMC0yXXxuMjBbMi0zXXxuMzAoMHwyKXxuNTAoMHwyfDUpfG43KDAoMHwxKXwxMCl8bmUoKGN8bSktfG9ufHRmfHdmfHdnfHd0KXxub2soNnxpKXxuenBofG8yaW18b3AodGl8d3YpfG9yYW58b3dnMXxwODAwfHBhbihhfGR8dCl8cGR4Z3xwZygxM3wtKFsxLThdfGMpKXxwaGlsfHBpcmV8cGwoYXl8dWMpfHBuLTJ8cG8oY2t8cnR8c2UpfHByb3h8cHNpb3xwdC1nfHFhLWF8cWMoMDd8MTJ8MjF8MzJ8NjB8LVsyLTddfGktKXxxdGVrfHIzODB8cjYwMHxyYWtzfHJpbTl8cm8odmV8em8pfHM1NVxcL3xzYShnZXxtYXxtbXxtc3xueXx2YSl8c2MoMDF8aC18b298cC0pfHNka1xcL3xzZShjKC18MHwxKXw0N3xtY3xuZHxyaSl8c2doLXxzaGFyfHNpZSgtfG0pfHNrLTB8c2woNDV8aWQpfHNtKGFsfGFyfGIzfGl0fHQ1KXxzbyhmdHxueSl8c3AoMDF8aC18di18diApfHN5KDAxfG1iKXx0MigxOHw1MCl8dDYoMDB8MTB8MTgpfHRhKGd0fGxrKXx0Y2wtfHRkZy18dGVsKGl8bSl8dGltLXx0LW1vfHRvKHBsfHNoKXx0cyg3MHxtLXxtM3xtNSl8dHgtOXx1cChcXC5ifGcxfHNpKXx1dHN0fHY0MDB8djc1MHx2ZXJpfHZpKHJnfHRlKXx2ayg0MHw1WzAtM118LXYpfHZtNDB8dm9kYXx2dWxjfHZ4KDUyfDUzfDYwfDYxfDcwfDgwfDgxfDgzfDg1fDk4KXx3M2MoLXwgKXx3ZWJjfHdoaXR8d2koZyB8bmN8bncpfHdtbGJ8d29udXx4NzAwfHlhcy18eW91cnx6ZXRvfHp0ZS0vaS50ZXN0KGEuc3Vic3RyKDAsIDQpKSkgY2hlY2sgPSB0cnVlO1xuICAgIH0pKG5hdmlnYXRvci51c2VyQWdlbnQgfHwgbmF2aWdhdG9yLnZlbmRvciB8fCB3aW5kb3cub3BlcmEpO1xuICAgIHJldHVybiBjaGVjaztcbn07XG5cbi8qKlxuICogTW9kaWZ5IEhUTUwgdG8gYWRkICd0YXJnZXQ9XCJfYmxhbmtcIicgdG8gbGlua3Mgc28gdGhleSBvcGVuIGluIG5ldyB0YWJzIGJ5IGRlZmF1bHQuXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFRleHQgLSBIVE1MIHRvIGJlIG1vZGlmaWVkLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgbW9kaWZpZWQgSFRNTCB0ZXh0LlxuICovXG5mdW5jdGlvbiBhZGRBbmNob3JUYXJnZXRCbGFuayhodG1sVGV4dCkge1xuICAgIHZhciBtYXRjaDtcbiAgICB3aGlsZSAoKG1hdGNoID0gYW5jaG9yVG9FeHRlcm5hbFJlZ2V4LmV4ZWMoaHRtbFRleHQpKSAhPT0gbnVsbCkge1xuICAgICAgICAvLyBXaXRoIG9ubHkgb25lIGNhcHR1cmUgZ3JvdXAgaW4gdGhlIFJlZ0V4cCwgd2UgY2FuIHNhZmVseSB0YWtlIHRoZSBmaXJzdCBpbmRleCBmcm9tIHRoZSBtYXRjaC5cbiAgICAgICAgdmFyIGxpbmtTdHJpbmcgPSBtYXRjaFswXTtcblxuICAgICAgICBpZiAobGlua1N0cmluZy5pbmRleE9mKCd0YXJnZXQ9JykgPT09IC0xKSB7XG4gICAgICAgICAgICB2YXIgZml4ZWRMaW5rU3RyaW5nID0gbGlua1N0cmluZy5yZXBsYWNlKC8+JC8sICcgdGFyZ2V0PVwiX2JsYW5rXCI+Jyk7XG4gICAgICAgICAgICBodG1sVGV4dCA9IGh0bWxUZXh0LnJlcGxhY2UobGlua1N0cmluZywgZml4ZWRMaW5rU3RyaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaHRtbFRleHQ7XG59XG5cbi8qKlxuICogTW9kaWZ5IEhUTUwgdG8gcmVtb3ZlIHRoZSBsaXN0LXN0eWxlIHdoZW4gcmVuZGVyaW5nIGNoZWNrYm94ZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFRleHQgLSBIVE1MIHRvIGJlIG1vZGlmaWVkLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgbW9kaWZpZWQgSFRNTCB0ZXh0LlxuICovXG5mdW5jdGlvbiByZW1vdmVMaXN0U3R5bGVXaGVuQ2hlY2tib3goaHRtbFRleHQpIHtcblxuICAgIHZhciBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgdmFyIGh0bWxEb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKGh0bWxUZXh0LCAndGV4dC9odG1sJyk7XG4gICAgdmFyIGxpc3RJdGVtcyA9IGh0bWxEb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2xpJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RJdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGlzdEl0ZW0gPSBsaXN0SXRlbXNbaV07XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaXN0SXRlbS5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGxpc3RJdGVtQ2hpbGQgPSBsaXN0SXRlbS5jaGlsZHJlbltqXTtcblxuICAgICAgICAgICAgaWYgKGxpc3RJdGVtQ2hpbGQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50ICYmIGxpc3RJdGVtQ2hpbGQudHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAgICAgICAgICAgICAgIC8vIEZyb20gR2l0aHViOiBtYXJnaW46IDAgLjJlbSAuMjVlbSAtMS42ZW07XG4gICAgICAgICAgICAgICAgbGlzdEl0ZW0uc3R5bGUubWFyZ2luTGVmdCA9ICctMS41ZW0nO1xuICAgICAgICAgICAgICAgIGxpc3RJdGVtLnN0eWxlLmxpc3RTdHlsZVR5cGUgPSAnbm9uZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaHRtbERvYy5kb2N1bWVudEVsZW1lbnQuaW5uZXJIVE1MO1xufVxuXG4vKipcbiAqIEZpeCBzaG9ydGN1dC4gTWFjIHVzZSBDb21tYW5kLCBvdGhlcnMgdXNlIEN0cmwuXG4gKi9cbmZ1bmN0aW9uIGZpeFNob3J0Y3V0KG5hbWUpIHtcbiAgICBpZiAoaXNNYWMpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgnQ3RybCcsICdDbWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKCdDbWQnLCAnQ3RybCcpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgZHJvcGRvd24gYmxvY2tcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVG9vbGJhckRyb3Bkb3duKG9wdGlvbnMsIGVuYWJsZVRvb2x0aXBzLCBzaG9ydGN1dHMsIHBhcmVudCkge1xuICAgIHZhciBlbCA9IGNyZWF0ZVRvb2xiYXJCdXR0b24ob3B0aW9ucywgZmFsc2UsIGVuYWJsZVRvb2x0aXBzLCBzaG9ydGN1dHMsICdidXR0b24nLCBwYXJlbnQpO1xuICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2Vhc3ltZGUtZHJvcGRvd24nKTtcblxuICAgIGVsLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVsLmZvY3VzKCk7XG4gICAgfTtcblxuICAgIHZhciBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGVudC5jbGFzc05hbWUgPSAnZWFzeW1kZS1kcm9wZG93bi1jb250ZW50JztcbiAgICBmb3IgKHZhciBjaGlsZHJlbkluZGV4ID0gMDsgY2hpbGRyZW5JbmRleCA8IG9wdGlvbnMuY2hpbGRyZW4ubGVuZ3RoOyBjaGlsZHJlbkluZGV4KyspIHtcblxuICAgICAgICB2YXIgY2hpbGQgPSBvcHRpb25zLmNoaWxkcmVuW2NoaWxkcmVuSW5kZXhdO1xuICAgICAgICB2YXIgY2hpbGRFbGVtZW50O1xuXG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnICYmIGNoaWxkIGluIHRvb2xiYXJCdWlsdEluQnV0dG9ucykge1xuICAgICAgICAgICAgY2hpbGRFbGVtZW50ID0gY3JlYXRlVG9vbGJhckJ1dHRvbih0b29sYmFyQnVpbHRJbkJ1dHRvbnNbY2hpbGRdLCB0cnVlLCBlbmFibGVUb29sdGlwcywgc2hvcnRjdXRzLCAnYnV0dG9uJywgcGFyZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoaWxkRWxlbWVudCA9IGNyZWF0ZVRvb2xiYXJCdXR0b24oY2hpbGQsIHRydWUsIGVuYWJsZVRvb2x0aXBzLCBzaG9ydGN1dHMsICdidXR0b24nLCBwYXJlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHsgZS5zdG9wUHJvcGFnYXRpb24oKTsgfSwgZmFsc2UpO1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKGNoaWxkRWxlbWVudCk7XG4gICAgfVxuICAgIGVsLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgIHJldHVybiBlbDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYnV0dG9uIGVsZW1lbnQgZm9yIHRvb2xiYXIuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRvb2xiYXJCdXR0b24ob3B0aW9ucywgZW5hYmxlQWN0aW9ucywgZW5hYmxlVG9vbHRpcHMsIHNob3J0Y3V0cywgbWFya3VwLCBwYXJlbnQpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG1hcmt1cCk7XG5cbiAgICAvLyBBZGQgJ2N1c3RvbScgYXR0cmlidXRlcyBhcyBlYXJseSBhcyBwb3NzaWJsZSwgc28gdGhhdCAnb2ZmaWNpYWwnIGF0dHJpYnV0ZXMgd2lsbCBuZXZlciBiZSBvdmVyd3JpdHRlbi5cbiAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIGZvciAodmFyIGF0dHJpYnV0ZSBpbiBvcHRpb25zLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucy5hdHRyaWJ1dGVzLCBhdHRyaWJ1dGUpKSB7XG4gICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgb3B0aW9ucy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNsYXNzTmFtZVByZWZpeCA9IHBhcmVudC5vcHRpb25zLnRvb2xiYXJCdXR0b25DbGFzc1ByZWZpeCA/IHBhcmVudC5vcHRpb25zLnRvb2xiYXJCdXR0b25DbGFzc1ByZWZpeCArICctJyA6ICcnO1xuICAgIGVsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZVByZWZpeCArIG9wdGlvbnMubmFtZTtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCBtYXJrdXApO1xuICAgIGVuYWJsZVRvb2x0aXBzID0gKGVuYWJsZVRvb2x0aXBzID09IHVuZGVmaW5lZCkgPyB0cnVlIDogZW5hYmxlVG9vbHRpcHM7XG5cbiAgICBpZiAob3B0aW9ucy50ZXh0KSB7XG4gICAgICAgIGVsLmlubmVyVGV4dCA9IG9wdGlvbnMudGV4dDtcbiAgICB9XG5cbiAgICAvLyBQcm9wZXJseSBoYW5kbGUgY3VzdG9tIHNob3J0Y3V0c1xuICAgIGlmIChvcHRpb25zLm5hbWUgJiYgb3B0aW9ucy5uYW1lIGluIHNob3J0Y3V0cykge1xuICAgICAgICBiaW5kaW5nc1tvcHRpb25zLm5hbWVdID0gb3B0aW9ucy5hY3Rpb247XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMudGl0bGUgJiYgZW5hYmxlVG9vbHRpcHMpIHtcbiAgICAgICAgZWwudGl0bGUgPSBjcmVhdGVUb29sdGlwKG9wdGlvbnMudGl0bGUsIG9wdGlvbnMuYWN0aW9uLCBzaG9ydGN1dHMpO1xuXG4gICAgICAgIGlmIChpc01hYykge1xuICAgICAgICAgICAgZWwudGl0bGUgPSBlbC50aXRsZS5yZXBsYWNlKCdDdHJsJywgJ+KMmCcpO1xuICAgICAgICAgICAgZWwudGl0bGUgPSBlbC50aXRsZS5yZXBsYWNlKCdBbHQnLCAn4oylJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy50aXRsZSkge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBvcHRpb25zLnRpdGxlKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5ub0Rpc2FibGUpIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnbm8tZGlzYWJsZScpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm5vTW9iaWxlKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ25vLW1vYmlsZScpO1xuICAgIH1cblxuICAgIC8vIFByZXZlbnQgZXJyb3JzIGlmIHRoZXJlIGlzIG5vIGNsYXNzIG5hbWUgaW4gY3VzdG9tIG9wdGlvbnNcbiAgICB2YXIgY2xhc3NOYW1lUGFydHMgPSBbXTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuY2xhc3NOYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjbGFzc05hbWVQYXJ0cyA9IG9wdGlvbnMuY2xhc3NOYW1lLnNwbGl0KCcgJyk7XG4gICAgfVxuXG4gICAgLy8gUHJvdmlkZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIHNpbXBsZS1tYXJrZG93bi1lZGl0b3IgYnkgYWRkaW5nIGN1c3RvbSBjbGFzc2VzIHRvIHRoZSBidXR0b24uXG4gICAgdmFyIGljb25DbGFzc2VzID0gW107XG4gICAgZm9yICh2YXIgY2xhc3NOYW1lSW5kZXggPSAwOyBjbGFzc05hbWVJbmRleCA8IGNsYXNzTmFtZVBhcnRzLmxlbmd0aDsgY2xhc3NOYW1lSW5kZXgrKykge1xuICAgICAgICB2YXIgY2xhc3NOYW1lUGFydCA9IGNsYXNzTmFtZVBhcnRzW2NsYXNzTmFtZUluZGV4XTtcbiAgICAgICAgLy8gU3BsaXQgaWNvbiBjbGFzc2VzIGZyb20gdGhlIGJ1dHRvbi5cbiAgICAgICAgLy8gUmVnZXggd2lsbCBkZXRlY3QgXCJmYVwiLCBcImZhc1wiLCBcImZhLXNvbWV0aGluZ1wiIGFuZCBcImZhLXNvbWUtaWNvbi0xXCIsIGJ1dCBub3QgXCJmYW5mYXJlXCIuXG4gICAgICAgIGlmIChjbGFzc05hbWVQYXJ0Lm1hdGNoKC9eZmEoW3NybGJdfCgtW1xcdy1dKil8JCkvKSkge1xuICAgICAgICAgICAgaWNvbkNsYXNzZXMucHVzaChjbGFzc05hbWVQYXJ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lUGFydCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlbC50YWJJbmRleCA9IC0xO1xuXG4gICAgaWYgKGljb25DbGFzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gQ3JlYXRlIGljb24gZWxlbWVudCBhbmQgYXBwZW5kIGFzIGEgY2hpbGQgdG8gdGhlIGJ1dHRvblxuICAgICAgICB2YXIgaWNvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2knKTtcbiAgICAgICAgZm9yICh2YXIgaWNvbkNsYXNzSW5kZXggPSAwOyBpY29uQ2xhc3NJbmRleCA8IGljb25DbGFzc2VzLmxlbmd0aDsgaWNvbkNsYXNzSW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIGljb25DbGFzcyA9IGljb25DbGFzc2VzW2ljb25DbGFzc0luZGV4XTtcbiAgICAgICAgICAgIGljb24uY2xhc3NMaXN0LmFkZChpY29uQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsLmFwcGVuZENoaWxkKGljb24pO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGlzIGEgY3VzdG9tIGljb24gbWFya3VwIHNldCwgdXNlIHRoYXRcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuaWNvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZWwuaW5uZXJIVE1MID0gb3B0aW9ucy5pY29uO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmFjdGlvbiAmJiBlbmFibGVBY3Rpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGVsLm9uY2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmFjdGlvbihwYXJlbnQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5hY3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlbC5vbmNsaWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgd2luZG93Lm9wZW4ob3B0aW9ucy5hY3Rpb24sICdfYmxhbmsnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZWw7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNlcCgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpJyk7XG4gICAgZWwuY2xhc3NOYW1lID0gJ3NlcGFyYXRvcic7XG4gICAgZWwuaW5uZXJIVE1MID0gJ3wnO1xuICAgIHJldHVybiBlbDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVG9vbHRpcCh0aXRsZSwgYWN0aW9uLCBzaG9ydGN1dHMpIHtcbiAgICB2YXIgYWN0aW9uTmFtZTtcbiAgICB2YXIgdG9vbHRpcCA9IHRpdGxlO1xuXG4gICAgaWYgKGFjdGlvbikge1xuICAgICAgICBhY3Rpb25OYW1lID0gZ2V0QmluZGluZ05hbWUoYWN0aW9uKTtcbiAgICAgICAgaWYgKHNob3J0Y3V0c1thY3Rpb25OYW1lXSkge1xuICAgICAgICAgICAgdG9vbHRpcCArPSAnICgnICsgZml4U2hvcnRjdXQoc2hvcnRjdXRzW2FjdGlvbk5hbWVdKSArICcpJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0b29sdGlwO1xufVxuXG4vKipcbiAqIFRoZSBzdGF0ZSBvZiBDb2RlTWlycm9yIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0U3RhdGUoY20sIHBvcykge1xuICAgIHBvcyA9IHBvcyB8fCBjbS5nZXRDdXJzb3IoJ3N0YXJ0Jyk7XG4gICAgdmFyIHN0YXQgPSBjbS5nZXRUb2tlbkF0KHBvcyk7XG4gICAgaWYgKCFzdGF0LnR5cGUpIHJldHVybiB7fTtcblxuICAgIHZhciB0eXBlcyA9IHN0YXQudHlwZS5zcGxpdCgnICcpO1xuXG4gICAgdmFyIHJldCA9IHt9LFxuICAgICAgICBkYXRhLCB0ZXh0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGF0YSA9IHR5cGVzW2ldO1xuICAgICAgICBpZiAoZGF0YSA9PT0gJ3N0cm9uZycpIHtcbiAgICAgICAgICAgIHJldC5ib2xkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhID09PSAndmFyaWFibGUtMicpIHtcbiAgICAgICAgICAgIHRleHQgPSBjbS5nZXRMaW5lKHBvcy5saW5lKTtcbiAgICAgICAgICAgIGlmICgvXlxccypcXGQrXFwuXFxzLy50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0WydvcmRlcmVkLWxpc3QnXSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldFsndW5vcmRlcmVkLWxpc3QnXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gJ2F0b20nKSB7XG4gICAgICAgICAgICByZXQucXVvdGUgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEgPT09ICdlbScpIHtcbiAgICAgICAgICAgIHJldC5pdGFsaWMgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEgPT09ICdxdW90ZScpIHtcbiAgICAgICAgICAgIHJldC5xdW90ZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gJ3N0cmlrZXRocm91Z2gnKSB7XG4gICAgICAgICAgICByZXQuc3RyaWtldGhyb3VnaCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gJ2NvbW1lbnQnKSB7XG4gICAgICAgICAgICByZXQuY29kZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gJ2xpbmsnICYmICFyZXQuaW1hZ2UpIHtcbiAgICAgICAgICAgIHJldC5saW5rID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhID09PSAnaW1hZ2UnKSB7XG4gICAgICAgICAgICByZXQuaW1hZ2UgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEubWF0Y2goL15oZWFkZXIoLVsxLTZdKT8kLykpIHtcbiAgICAgICAgICAgIHJldFtkYXRhLnJlcGxhY2UoJ2hlYWRlcicsICdoZWFkaW5nJyldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5cbi8vIFNhdmVkIG92ZXJmbG93IHNldHRpbmdcbnZhciBzYXZlZF9vdmVyZmxvdyA9ICcnO1xuXG4vKipcbiAqIFRvZ2dsZSBmdWxsIHNjcmVlbiBvZiB0aGUgZWRpdG9yLlxuICogQHBhcmFtIHtFYXN5TURFfSBlZGl0b3JcbiAqL1xuZnVuY3Rpb24gdG9nZ2xlRnVsbFNjcmVlbihlZGl0b3IpIHtcbiAgICAvLyBTZXQgZnVsbHNjcmVlblxuICAgIHZhciBjbSA9IGVkaXRvci5jb2RlbWlycm9yO1xuICAgIGNtLnNldE9wdGlvbignZnVsbFNjcmVlbicsICFjbS5nZXRPcHRpb24oJ2Z1bGxTY3JlZW4nKSk7XG5cblxuICAgIC8vIFByZXZlbnQgc2Nyb2xsaW5nIG9uIGJvZHkgZHVyaW5nIGZ1bGxzY3JlZW4gYWN0aXZlXG4gICAgaWYgKGNtLmdldE9wdGlvbignZnVsbFNjcmVlbicpKSB7XG4gICAgICAgIHNhdmVkX292ZXJmbG93ID0gZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdztcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSBzYXZlZF9vdmVyZmxvdztcbiAgICB9XG5cbiAgICB2YXIgd3JhcHBlciA9IGNtLmdldFdyYXBwZXJFbGVtZW50KCk7XG4gICAgdmFyIHNpZGVieXNpZGUgPSB3cmFwcGVyLm5leHRTaWJsaW5nO1xuXG4gICAgaWYgKHNpZGVieXNpZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdlZGl0b3ItcHJldmlldy1hY3RpdmUtc2lkZScpKSB7XG4gICAgICAgIGlmIChlZGl0b3Iub3B0aW9ucy5zaWRlQnlTaWRlRnVsbHNjcmVlbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIGlmIHNpZGUtYnktc2lkZSBub3QtZnVsbHNjcmVlbiBvaywgYXBwbHkgY2xhc3NlcyBhcyBuZWVkZWRcbiAgICAgICAgICAgIHZhciBlYXN5TURFQ29udGFpbmVyID0gd3JhcHBlci5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKGNtLmdldE9wdGlvbignZnVsbFNjcmVlbicpKSB7XG4gICAgICAgICAgICAgICAgZWFzeU1ERUNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKCdzaWRlZC0tbm8tZnVsbHNjcmVlbicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlYXN5TURFQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3NpZGVkLS1uby1mdWxsc2NyZWVuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2dnbGVTaWRlQnlTaWRlKGVkaXRvcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZWRpdG9yLm9wdGlvbnMub25Ub2dnbGVGdWxsU2NyZWVuKSB7XG4gICAgICAgIGVkaXRvci5vcHRpb25zLm9uVG9nZ2xlRnVsbFNjcmVlbihjbS5nZXRPcHRpb24oJ2Z1bGxTY3JlZW4nKSB8fCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIG9yIHNldCBtYXhIZWlnaHRcbiAgICBpZiAodHlwZW9mIGVkaXRvci5vcHRpb25zLm1heEhlaWdodCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKGNtLmdldE9wdGlvbignZnVsbFNjcmVlbicpKSB7XG4gICAgICAgICAgICBjbS5nZXRTY3JvbGxlckVsZW1lbnQoKS5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnaGVpZ2h0Jyk7XG4gICAgICAgICAgICBzaWRlYnlzaWRlLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdoZWlnaHQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNtLmdldFNjcm9sbGVyRWxlbWVudCgpLnN0eWxlLmhlaWdodCA9IGVkaXRvci5vcHRpb25zLm1heEhlaWdodDtcbiAgICAgICAgICAgIGVkaXRvci5zZXRQcmV2aWV3TWF4SGVpZ2h0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdG9vbGJhciBjbGFzc1xuICAgIGVkaXRvci50b29sYmFyX2Rpdi5jbGFzc0xpc3QudG9nZ2xlKCdmdWxsc2NyZWVuJyk7XG5cbiAgICAvLyBVcGRhdGUgdG9vbGJhciBidXR0b25cbiAgICBpZiAoZWRpdG9yLnRvb2xiYXJFbGVtZW50cyAmJiBlZGl0b3IudG9vbGJhckVsZW1lbnRzLmZ1bGxzY3JlZW4pIHtcbiAgICAgICAgdmFyIHRvb2xiYXJCdXR0b24gPSBlZGl0b3IudG9vbGJhckVsZW1lbnRzLmZ1bGxzY3JlZW47XG4gICAgICAgIHRvb2xiYXJCdXR0b24uY2xhc3NMaXN0LnRvZ2dsZSgnYWN0aXZlJyk7XG4gICAgfVxufVxuXG5cbi8qKlxuICogQWN0aW9uIGZvciB0b2dnbGluZyBib2xkLlxuICogQHBhcmFtIHtFYXN5TURFfSBlZGl0b3JcbiAqL1xuZnVuY3Rpb24gdG9nZ2xlQm9sZChlZGl0b3IpIHtcbiAgICBfdG9nZ2xlQmxvY2soZWRpdG9yLCAnYm9sZCcsIGVkaXRvci5vcHRpb25zLmJsb2NrU3R5bGVzLmJvbGQpO1xufVxuXG5cbi8qKlxuICogQWN0aW9uIGZvciB0b2dnbGluZyBpdGFsaWMuXG4gKiBAcGFyYW0ge0Vhc3lNREV9IGVkaXRvclxuICovXG5mdW5jdGlvbiB0b2dnbGVJdGFsaWMoZWRpdG9yKSB7XG4gICAgX3RvZ2dsZUJsb2NrKGVkaXRvciwgJ2l0YWxpYycsIGVkaXRvci5vcHRpb25zLmJsb2NrU3R5bGVzLml0YWxpYyk7XG59XG5cblxuLyoqXG4gKiBBY3Rpb24gZm9yIHRvZ2dsaW5nIHN0cmlrZXRocm91Z2guXG4gKiBAcGFyYW0ge0Vhc3lNREV9IGVkaXRvclxuICovXG5mdW5jdGlvbiB0b2dnbGVTdHJpa2V0aHJvdWdoKGVkaXRvcikge1xuICAgIF90b2dnbGVCbG9jayhlZGl0b3IsICdzdHJpa2V0aHJvdWdoJywgJ35+Jyk7XG59XG5cbi8qKlxuICogQWN0aW9uIGZvciB0b2dnbGluZyBjb2RlIGJsb2NrLlxuICogQHBhcmFtIHtFYXN5TURFfSBlZGl0b3JcbiAqL1xuZnVuY3Rpb24gdG9nZ2xlQ29kZUJsb2NrKGVkaXRvcikge1xuICAgIHZhciBmZW5jZUNoYXJzVG9JbnNlcnQgPSBlZGl0b3Iub3B0aW9ucy5ibG9ja1N0eWxlcy5jb2RlO1xuXG4gICAgZnVuY3Rpb24gZmVuY2luZ19saW5lKGxpbmUpIHtcbiAgICAgICAgLyogcmV0dXJuIHRydWUsIGlmIHRoaXMgaXMgYSBgYGAgb3Igfn5+IGxpbmUgKi9cbiAgICAgICAgaWYgKHR5cGVvZiBsaW5lICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgJ2ZlbmNpbmdfbGluZSgpIHRha2VzIGEgXFwnbGluZVxcJyBvYmplY3QgKG5vdCBhIGxpbmUgbnVtYmVyLCBvciBsaW5lIHRleHQpLiAgR290OiAnICsgdHlwZW9mIGxpbmUgKyAnOiAnICsgbGluZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZS5zdHlsZXMgJiYgbGluZS5zdHlsZXNbMl0gJiYgbGluZS5zdHlsZXNbMl0uaW5kZXhPZignZm9ybWF0dGluZy1jb2RlLWJsb2NrJykgIT09IC0xO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRva2VuX3N0YXRlKHRva2VuKSB7XG4gICAgICAgIC8vIGJhc2UgZ29lcyBhbiBleHRyYSBsZXZlbCBkZWVwIHdoZW4gbW9kZSBiYWNrZHJvcHMgYXJlIHVzZWQsIGUuZy4gc3BlbGxjaGVja2VyIG9uXG4gICAgICAgIHJldHVybiB0b2tlbi5zdGF0ZS5iYXNlLmJhc2UgfHwgdG9rZW4uc3RhdGUuYmFzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb2RlX3R5cGUoY20sIGxpbmVfbnVtLCBsaW5lLCBmaXJzdFRvaywgbGFzdFRvaykge1xuICAgICAgICAvKlxuICAgICAgICAgKiBSZXR1cm4gXCJzaW5nbGVcIiwgXCJpbmRlbnRlZFwiLCBcImZlbmNlZFwiIG9yIGZhbHNlXG4gICAgICAgICAqXG4gICAgICAgICAqIGNtIGFuZCBsaW5lX251bSBhcmUgcmVxdWlyZWQuICBPdGhlcnMgYXJlIG9wdGlvbmFsIGZvciBlZmZpY2llbmN5XG4gICAgICAgICAqICAgVG8gY2hlY2sgaW4gdGhlIG1pZGRsZSBvZiBhIGxpbmUsIHBhc3MgaW4gZmlyc3RUb2sgeW91cnNlbGYuXG4gICAgICAgICAqL1xuICAgICAgICBsaW5lID0gbGluZSB8fCBjbS5nZXRMaW5lSGFuZGxlKGxpbmVfbnVtKTtcbiAgICAgICAgZmlyc3RUb2sgPSBmaXJzdFRvayB8fCBjbS5nZXRUb2tlbkF0KHtcbiAgICAgICAgICAgIGxpbmU6IGxpbmVfbnVtLFxuICAgICAgICAgICAgY2g6IDEsXG4gICAgICAgIH0pO1xuICAgICAgICBsYXN0VG9rID0gbGFzdFRvayB8fCAoISFsaW5lLnRleHQgJiYgY20uZ2V0VG9rZW5BdCh7XG4gICAgICAgICAgICBsaW5lOiBsaW5lX251bSxcbiAgICAgICAgICAgIGNoOiBsaW5lLnRleHQubGVuZ3RoIC0gMSxcbiAgICAgICAgfSkpO1xuICAgICAgICB2YXIgdHlwZXMgPSBmaXJzdFRvay50eXBlID8gZmlyc3RUb2sudHlwZS5zcGxpdCgnICcpIDogW107XG4gICAgICAgIGlmIChsYXN0VG9rICYmIHRva2VuX3N0YXRlKGxhc3RUb2spLmluZGVudGVkQ29kZSkge1xuICAgICAgICAgICAgLy8gaGF2ZSB0byBjaGVjayBsYXN0IGNoYXIsIHNpbmNlIGZpcnN0IGNoYXJzIG9mIGZpcnN0IGxpbmUgYXJlblwidCBtYXJrZWQgYXMgaW5kZW50ZWRcbiAgICAgICAgICAgIHJldHVybiAnaW5kZW50ZWQnO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVzLmluZGV4T2YoJ2NvbW1lbnQnKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIGhhcyB0byBiZSBhZnRlciBcImluZGVudGVkXCIgY2hlY2ssIHNpbmNlIGZpcnN0IGNoYXJzIG9mIGZpcnN0IGluZGVudGVkIGxpbmUgYXJlblwidCBtYXJrZWQgYXMgc3VjaFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHRva2VuX3N0YXRlKGZpcnN0VG9rKS5mZW5jZWRDaGFycyB8fCB0b2tlbl9zdGF0ZShsYXN0VG9rKS5mZW5jZWRDaGFycyB8fCBmZW5jaW5nX2xpbmUobGluZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnZmVuY2VkJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnc2luZ2xlJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc2VydEZlbmNpbmdBdFNlbGVjdGlvbihjbSwgY3VyX3N0YXJ0LCBjdXJfZW5kLCBmZW5jZUNoYXJzVG9JbnNlcnQpIHtcbiAgICAgICAgdmFyIHN0YXJ0X2xpbmVfc2VsID0gY3VyX3N0YXJ0LmxpbmUgKyAxLFxuICAgICAgICAgICAgZW5kX2xpbmVfc2VsID0gY3VyX2VuZC5saW5lICsgMSxcbiAgICAgICAgICAgIHNlbF9tdWx0aSA9IGN1cl9zdGFydC5saW5lICE9PSBjdXJfZW5kLmxpbmUsXG4gICAgICAgICAgICByZXBsX3N0YXJ0ID0gZmVuY2VDaGFyc1RvSW5zZXJ0ICsgJ1xcbicsXG4gICAgICAgICAgICByZXBsX2VuZCA9ICdcXG4nICsgZmVuY2VDaGFyc1RvSW5zZXJ0O1xuICAgICAgICBpZiAoc2VsX211bHRpKSB7XG4gICAgICAgICAgICBlbmRfbGluZV9zZWwrKztcbiAgICAgICAgfVxuICAgICAgICAvLyBoYW5kbGUgbGFzdCBjaGFyIGluY2x1ZGluZyBcXG4gb3Igbm90XG4gICAgICAgIGlmIChzZWxfbXVsdGkgJiYgY3VyX2VuZC5jaCA9PT0gMCkge1xuICAgICAgICAgICAgcmVwbF9lbmQgPSBmZW5jZUNoYXJzVG9JbnNlcnQgKyAnXFxuJztcbiAgICAgICAgICAgIGVuZF9saW5lX3NlbC0tO1xuICAgICAgICB9XG4gICAgICAgIF9yZXBsYWNlU2VsZWN0aW9uKGNtLCBmYWxzZSwgW3JlcGxfc3RhcnQsIHJlcGxfZW5kXSk7XG4gICAgICAgIGNtLnNldFNlbGVjdGlvbih7XG4gICAgICAgICAgICBsaW5lOiBzdGFydF9saW5lX3NlbCxcbiAgICAgICAgICAgIGNoOiAwLFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBsaW5lOiBlbmRfbGluZV9zZWwsXG4gICAgICAgICAgICBjaDogMCxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGNtID0gZWRpdG9yLmNvZGVtaXJyb3IsXG4gICAgICAgIGN1cl9zdGFydCA9IGNtLmdldEN1cnNvcignc3RhcnQnKSxcbiAgICAgICAgY3VyX2VuZCA9IGNtLmdldEN1cnNvcignZW5kJyksXG4gICAgICAgIHRvayA9IGNtLmdldFRva2VuQXQoe1xuICAgICAgICAgICAgbGluZTogY3VyX3N0YXJ0LmxpbmUsXG4gICAgICAgICAgICBjaDogY3VyX3N0YXJ0LmNoIHx8IDEsXG4gICAgICAgIH0pLCAvLyBhdm9pZCBjaCAwIHdoaWNoIGlzIGEgY3Vyc29yIHBvcyBidXQgbm90IHRva2VuXG4gICAgICAgIGxpbmUgPSBjbS5nZXRMaW5lSGFuZGxlKGN1cl9zdGFydC5saW5lKSxcbiAgICAgICAgaXNfY29kZSA9IGNvZGVfdHlwZShjbSwgY3VyX3N0YXJ0LmxpbmUsIGxpbmUsIHRvayk7XG4gICAgdmFyIGJsb2NrX3N0YXJ0LCBibG9ja19lbmQsIGxpbmVDb3VudDtcblxuICAgIGlmIChpc19jb2RlID09PSAnc2luZ2xlJykge1xuICAgICAgICAvLyBzaW1pbGFyIHRvIHNvbWUgRWFzeU1ERSBfdG9nZ2xlQmxvY2sgbG9naWNcbiAgICAgICAgdmFyIHN0YXJ0ID0gbGluZS50ZXh0LnNsaWNlKDAsIGN1cl9zdGFydC5jaCkucmVwbGFjZSgnYCcsICcnKSxcbiAgICAgICAgICAgIGVuZCA9IGxpbmUudGV4dC5zbGljZShjdXJfc3RhcnQuY2gpLnJlcGxhY2UoJ2AnLCAnJyk7XG4gICAgICAgIGNtLnJlcGxhY2VSYW5nZShzdGFydCArIGVuZCwge1xuICAgICAgICAgICAgbGluZTogY3VyX3N0YXJ0LmxpbmUsXG4gICAgICAgICAgICBjaDogMCxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbGluZTogY3VyX3N0YXJ0LmxpbmUsXG4gICAgICAgICAgICBjaDogOTk5OTk5OTk5OTk5OTksXG4gICAgICAgIH0pO1xuICAgICAgICBjdXJfc3RhcnQuY2gtLTtcbiAgICAgICAgaWYgKGN1cl9zdGFydCAhPT0gY3VyX2VuZCkge1xuICAgICAgICAgICAgY3VyX2VuZC5jaC0tO1xuICAgICAgICB9XG4gICAgICAgIGNtLnNldFNlbGVjdGlvbihjdXJfc3RhcnQsIGN1cl9lbmQpO1xuICAgICAgICBjbS5mb2N1cygpO1xuICAgIH0gZWxzZSBpZiAoaXNfY29kZSA9PT0gJ2ZlbmNlZCcpIHtcbiAgICAgICAgaWYgKGN1cl9zdGFydC5saW5lICE9PSBjdXJfZW5kLmxpbmUgfHwgY3VyX3N0YXJ0LmNoICE9PSBjdXJfZW5kLmNoKSB7XG4gICAgICAgICAgICAvLyB1c2Ugc2VsZWN0aW9uXG5cbiAgICAgICAgICAgIC8vIGZpbmQgdGhlIGZlbmNlZCBsaW5lIHNvIHdlIGtub3cgd2hhdCB0eXBlIGl0IGlzICh0aWxkZSwgYmFja3RpY2tzLCBudW1iZXIgb2YgdGhlbSlcbiAgICAgICAgICAgIGZvciAoYmxvY2tfc3RhcnQgPSBjdXJfc3RhcnQubGluZTsgYmxvY2tfc3RhcnQgPj0gMDsgYmxvY2tfc3RhcnQtLSkge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBjbS5nZXRMaW5lSGFuZGxlKGJsb2NrX3N0YXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoZmVuY2luZ19saW5lKGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmZW5jZWRUb2sgPSBjbS5nZXRUb2tlbkF0KHtcbiAgICAgICAgICAgICAgICBsaW5lOiBibG9ja19zdGFydCxcbiAgICAgICAgICAgICAgICBjaDogMSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGZlbmNlX2NoYXJzID0gdG9rZW5fc3RhdGUoZmVuY2VkVG9rKS5mZW5jZWRDaGFycztcbiAgICAgICAgICAgIHZhciBzdGFydF90ZXh0LCBzdGFydF9saW5lO1xuICAgICAgICAgICAgdmFyIGVuZF90ZXh0LCBlbmRfbGluZTtcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBzZWxlY3Rpb24gZ29pbmcgdXAgYWdhaW5zdCBmZW5jZWQgbGluZXMsIGluIHdoaWNoIGNhc2Ugd2UgZG9uJ3Qgd2FudCB0byBhZGQgbW9yZSBmZW5jaW5nXG4gICAgICAgICAgICBpZiAoZmVuY2luZ19saW5lKGNtLmdldExpbmVIYW5kbGUoY3VyX3N0YXJ0LmxpbmUpKSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0X3RleHQgPSAnJztcbiAgICAgICAgICAgICAgICBzdGFydF9saW5lID0gY3VyX3N0YXJ0LmxpbmU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZlbmNpbmdfbGluZShjbS5nZXRMaW5lSGFuZGxlKGN1cl9zdGFydC5saW5lIC0gMSkpKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRfdGV4dCA9ICcnO1xuICAgICAgICAgICAgICAgIHN0YXJ0X2xpbmUgPSBjdXJfc3RhcnQubGluZSAtIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXJ0X3RleHQgPSBmZW5jZV9jaGFycyArICdcXG4nO1xuICAgICAgICAgICAgICAgIHN0YXJ0X2xpbmUgPSBjdXJfc3RhcnQubGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmZW5jaW5nX2xpbmUoY20uZ2V0TGluZUhhbmRsZShjdXJfZW5kLmxpbmUpKSkge1xuICAgICAgICAgICAgICAgIGVuZF90ZXh0ID0gJyc7XG4gICAgICAgICAgICAgICAgZW5kX2xpbmUgPSBjdXJfZW5kLmxpbmU7XG4gICAgICAgICAgICAgICAgaWYgKGN1cl9lbmQuY2ggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kX2xpbmUgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1cl9lbmQuY2ggIT09IDAgJiYgZmVuY2luZ19saW5lKGNtLmdldExpbmVIYW5kbGUoY3VyX2VuZC5saW5lICsgMSkpKSB7XG4gICAgICAgICAgICAgICAgZW5kX3RleHQgPSAnJztcbiAgICAgICAgICAgICAgICBlbmRfbGluZSA9IGN1cl9lbmQubGluZSArIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZF90ZXh0ID0gZmVuY2VfY2hhcnMgKyAnXFxuJztcbiAgICAgICAgICAgICAgICBlbmRfbGluZSA9IGN1cl9lbmQubGluZSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VyX2VuZC5jaCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGZ1bGwgbGFzdCBsaW5lIHNlbGVjdGVkLCBwdXR0aW5nIGN1cnNvciBhdCBiZWdpbm5pbmcgb2YgbmV4dFxuICAgICAgICAgICAgICAgIGVuZF9saW5lIC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbS5vcGVyYXRpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIGVuZCBsaW5lIGZpcnN0LCBzbyB0aGF0IGxpbmUgbnVtYmVycyBkb24ndCBjaGFuZ2VcbiAgICAgICAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UoZW5kX3RleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZTogZW5kX2xpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNoOiAwLFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZTogZW5kX2xpbmUgKyAoZW5kX3RleHQgPyAwIDogMSksXG4gICAgICAgICAgICAgICAgICAgIGNoOiAwLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZShzdGFydF90ZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IHN0YXJ0X2xpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNoOiAwLFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZTogc3RhcnRfbGluZSArIChzdGFydF90ZXh0ID8gMCA6IDEpLFxuICAgICAgICAgICAgICAgICAgICBjaDogMCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY20uc2V0U2VsZWN0aW9uKHtcbiAgICAgICAgICAgICAgICBsaW5lOiBzdGFydF9saW5lICsgKHN0YXJ0X3RleHQgPyAxIDogMCksXG4gICAgICAgICAgICAgICAgY2g6IDAsXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbGluZTogZW5kX2xpbmUgKyAoc3RhcnRfdGV4dCA/IDEgOiAtMSksXG4gICAgICAgICAgICAgICAgY2g6IDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNtLmZvY3VzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBubyBzZWxlY3Rpb24sIHNlYXJjaCBmb3IgZW5kcyBvZiB0aGlzIGZlbmNlZCBibG9ja1xuICAgICAgICAgICAgdmFyIHNlYXJjaF9mcm9tID0gY3VyX3N0YXJ0LmxpbmU7XG4gICAgICAgICAgICBpZiAoZmVuY2luZ19saW5lKGNtLmdldExpbmVIYW5kbGUoY3VyX3N0YXJ0LmxpbmUpKSkgeyAvLyBnZXRzIGEgbGl0dGxlIHRyaWNreSBpZiBjdXJzb3IgaXMgcmlnaHQgb24gYSBmZW5jZWQgbGluZVxuICAgICAgICAgICAgICAgIGlmIChjb2RlX3R5cGUoY20sIGN1cl9zdGFydC5saW5lICsgMSkgPT09ICdmZW5jZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrX3N0YXJ0ID0gY3VyX3N0YXJ0LmxpbmU7XG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaF9mcm9tID0gY3VyX3N0YXJ0LmxpbmUgKyAxOyAvLyBmb3Igc2VhcmNoaW5nIGZvciBcImVuZFwiXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tfZW5kID0gY3VyX3N0YXJ0LmxpbmU7XG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaF9mcm9tID0gY3VyX3N0YXJ0LmxpbmUgLSAxOyAvLyBmb3Igc2VhcmNoaW5nIGZvciBcInN0YXJ0XCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmxvY2tfc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZvciAoYmxvY2tfc3RhcnQgPSBzZWFyY2hfZnJvbTsgYmxvY2tfc3RhcnQgPj0gMDsgYmxvY2tfc3RhcnQtLSkge1xuICAgICAgICAgICAgICAgICAgICBsaW5lID0gY20uZ2V0TGluZUhhbmRsZShibG9ja19zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmZW5jaW5nX2xpbmUobGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJsb2NrX2VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbGluZUNvdW50ID0gY20ubGluZUNvdW50KCk7XG4gICAgICAgICAgICAgICAgZm9yIChibG9ja19lbmQgPSBzZWFyY2hfZnJvbTsgYmxvY2tfZW5kIDwgbGluZUNvdW50OyBibG9ja19lbmQrKykge1xuICAgICAgICAgICAgICAgICAgICBsaW5lID0gY20uZ2V0TGluZUhhbmRsZShibG9ja19lbmQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmVuY2luZ19saW5lKGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNtLm9wZXJhdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY20ucmVwbGFjZVJhbmdlKCcnLCB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGJsb2NrX3N0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBjaDogMCxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGJsb2NrX3N0YXJ0ICsgMSxcbiAgICAgICAgICAgICAgICAgICAgY2g6IDAsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY20ucmVwbGFjZVJhbmdlKCcnLCB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGJsb2NrX2VuZCAtIDEsXG4gICAgICAgICAgICAgICAgICAgIGNoOiAwLFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZTogYmxvY2tfZW5kLFxuICAgICAgICAgICAgICAgICAgICBjaDogMCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY20uZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNfY29kZSA9PT0gJ2luZGVudGVkJykge1xuICAgICAgICBpZiAoY3VyX3N0YXJ0LmxpbmUgIT09IGN1cl9lbmQubGluZSB8fCBjdXJfc3RhcnQuY2ggIT09IGN1cl9lbmQuY2gpIHtcbiAgICAgICAgICAgIC8vIHVzZSBzZWxlY3Rpb25cbiAgICAgICAgICAgIGJsb2NrX3N0YXJ0ID0gY3VyX3N0YXJ0LmxpbmU7XG4gICAgICAgICAgICBibG9ja19lbmQgPSBjdXJfZW5kLmxpbmU7XG4gICAgICAgICAgICBpZiAoY3VyX2VuZC5jaCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJsb2NrX2VuZC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbm8gc2VsZWN0aW9uLCBzZWFyY2ggZm9yIGVuZHMgb2YgdGhpcyBpbmRlbnRlZCBibG9ja1xuICAgICAgICAgICAgZm9yIChibG9ja19zdGFydCA9IGN1cl9zdGFydC5saW5lOyBibG9ja19zdGFydCA+PSAwOyBibG9ja19zdGFydC0tKSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IGNtLmdldExpbmVIYW5kbGUoYmxvY2tfc3RhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lLnRleHQubWF0Y2goL15cXHMqJC8pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVtcHR5IG9yIGFsbCB3aGl0ZXNwYWNlIC0ga2VlcCBnb2luZ1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZV90eXBlKGNtLCBibG9ja19zdGFydCwgbGluZSkgIT09ICdpbmRlbnRlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrX3N0YXJ0ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmVDb3VudCA9IGNtLmxpbmVDb3VudCgpO1xuICAgICAgICAgICAgZm9yIChibG9ja19lbmQgPSBjdXJfc3RhcnQubGluZTsgYmxvY2tfZW5kIDwgbGluZUNvdW50OyBibG9ja19lbmQrKykge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBjbS5nZXRMaW5lSGFuZGxlKGJsb2NrX2VuZCk7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUudGV4dC5tYXRjaCgvXlxccyokLykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW1wdHkgb3IgYWxsIHdoaXRlc3BhY2UgLSBrZWVwIGdvaW5nXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlX3R5cGUoY20sIGJsb2NrX2VuZCwgbGluZSkgIT09ICdpbmRlbnRlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrX2VuZCAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgYXJlIGdvaW5nIHRvIHVuLWluZGVudCBiYXNlZCBvbiBhIHNlbGVjdGVkIHNldCBvZiBsaW5lcywgYW5kIHRoZSBuZXh0IGxpbmUgaXMgaW5kZW50ZWQgdG9vLCB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIGluc2VydCBhIGJsYW5rIGxpbmUgc28gdGhhdCB0aGUgbmV4dCBsaW5lKHMpIGNvbnRpbnVlIHRvIGJlIGluZGVudGVkIGNvZGVcbiAgICAgICAgdmFyIG5leHRfbGluZSA9IGNtLmdldExpbmVIYW5kbGUoYmxvY2tfZW5kICsgMSksXG4gICAgICAgICAgICBuZXh0X2xpbmVfbGFzdF90b2sgPSBuZXh0X2xpbmUgJiYgY20uZ2V0VG9rZW5BdCh7XG4gICAgICAgICAgICAgICAgbGluZTogYmxvY2tfZW5kICsgMSxcbiAgICAgICAgICAgICAgICBjaDogbmV4dF9saW5lLnRleHQubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbmV4dF9saW5lX2luZGVudGVkID0gbmV4dF9saW5lX2xhc3RfdG9rICYmIHRva2VuX3N0YXRlKG5leHRfbGluZV9sYXN0X3RvaykuaW5kZW50ZWRDb2RlO1xuICAgICAgICBpZiAobmV4dF9saW5lX2luZGVudGVkKSB7XG4gICAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UoJ1xcbicsIHtcbiAgICAgICAgICAgICAgICBsaW5lOiBibG9ja19lbmQgKyAxLFxuICAgICAgICAgICAgICAgIGNoOiAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gYmxvY2tfc3RhcnQ7IGkgPD0gYmxvY2tfZW5kOyBpKyspIHtcbiAgICAgICAgICAgIGNtLmluZGVudExpbmUoaSwgJ3N1YnRyYWN0Jyk7IC8vIFRPRE86IHRoaXMgZG9lc24ndCBnZXQgdHJhY2tlZCBpbiB0aGUgaGlzdG9yeSwgc28gY2FuJ3QgYmUgdW5kb25lIDooXG4gICAgICAgIH1cbiAgICAgICAgY20uZm9jdXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpbnNlcnQgY29kZSBmb3JtYXR0aW5nXG4gICAgICAgIHZhciBub19zZWxfYW5kX3N0YXJ0aW5nX29mX2xpbmUgPSAoY3VyX3N0YXJ0LmxpbmUgPT09IGN1cl9lbmQubGluZSAmJiBjdXJfc3RhcnQuY2ggPT09IGN1cl9lbmQuY2ggJiYgY3VyX3N0YXJ0LmNoID09PSAwKTtcbiAgICAgICAgdmFyIHNlbF9tdWx0aSA9IGN1cl9zdGFydC5saW5lICE9PSBjdXJfZW5kLmxpbmU7XG4gICAgICAgIGlmIChub19zZWxfYW5kX3N0YXJ0aW5nX29mX2xpbmUgfHwgc2VsX211bHRpKSB7XG4gICAgICAgICAgICBpbnNlcnRGZW5jaW5nQXRTZWxlY3Rpb24oY20sIGN1cl9zdGFydCwgY3VyX2VuZCwgZmVuY2VDaGFyc1RvSW5zZXJ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9yZXBsYWNlU2VsZWN0aW9uKGNtLCBmYWxzZSwgWydgJywgJ2AnXSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQWN0aW9uIGZvciB0b2dnbGluZyBibG9ja3F1b3RlLlxuICovXG5mdW5jdGlvbiB0b2dnbGVCbG9ja3F1b3RlKGVkaXRvcikge1xuICAgIF90b2dnbGVMaW5lKGVkaXRvci5jb2RlbWlycm9yLCAncXVvdGUnKTtcbn1cblxuLyoqXG4gKiBBY3Rpb24gZm9yIHRvZ2dsaW5nIGhlYWRpbmcgc2l6ZTogbm9ybWFsIC0+IGgxIC0+IGgyIC0+IGgzIC0+IGg0IC0+IGg1IC0+IGg2IC0+IG5vcm1hbFxuICovXG5mdW5jdGlvbiB0b2dnbGVIZWFkaW5nU21hbGxlcihlZGl0b3IpIHtcbiAgICBfdG9nZ2xlSGVhZGluZyhlZGl0b3IuY29kZW1pcnJvciwgJ3NtYWxsZXInKTtcbn1cblxuLyoqXG4gKiBBY3Rpb24gZm9yIHRvZ2dsaW5nIGhlYWRpbmcgc2l6ZTogbm9ybWFsIC0+IGg2IC0+IGg1IC0+IGg0IC0+IGgzIC0+IGgyIC0+IGgxIC0+IG5vcm1hbFxuICovXG5mdW5jdGlvbiB0b2dnbGVIZWFkaW5nQmlnZ2VyKGVkaXRvcikge1xuICAgIF90b2dnbGVIZWFkaW5nKGVkaXRvci5jb2RlbWlycm9yLCAnYmlnZ2VyJyk7XG59XG5cbi8qKlxuICogQWN0aW9uIGZvciB0b2dnbGluZyBoZWFkaW5nIHNpemUgMVxuICovXG5mdW5jdGlvbiB0b2dnbGVIZWFkaW5nMShlZGl0b3IpIHtcbiAgICBfdG9nZ2xlSGVhZGluZyhlZGl0b3IuY29kZW1pcnJvciwgdW5kZWZpbmVkLCAxKTtcbn1cblxuLyoqXG4gKiBBY3Rpb24gZm9yIHRvZ2dsaW5nIGhlYWRpbmcgc2l6ZSAyXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZUhlYWRpbmcyKGVkaXRvcikge1xuICAgIF90b2dnbGVIZWFkaW5nKGVkaXRvci5jb2RlbWlycm9yLCB1bmRlZmluZWQsIDIpO1xufVxuXG4vKipcbiAqIEFjdGlvbiBmb3IgdG9nZ2xpbmcgaGVhZGluZyBzaXplIDNcbiAqL1xuZnVuY3Rpb24gdG9nZ2xlSGVhZGluZzMoZWRpdG9yKSB7XG4gICAgX3RvZ2dsZUhlYWRpbmcoZWRpdG9yLmNvZGVtaXJyb3IsIHVuZGVmaW5lZCwgMyk7XG59XG5cbi8qKlxuICogQWN0aW9uIGZvciB0b2dnbGluZyBoZWFkaW5nIHNpemUgNFxuICovXG5mdW5jdGlvbiB0b2dnbGVIZWFkaW5nNChlZGl0b3IpIHtcbiAgICBfdG9nZ2xlSGVhZGluZyhlZGl0b3IuY29kZW1pcnJvciwgdW5kZWZpbmVkLCA0KTtcbn1cblxuLyoqXG4gKiBBY3Rpb24gZm9yIHRvZ2dsaW5nIGhlYWRpbmcgc2l6ZSA1XG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZUhlYWRpbmc1KGVkaXRvcikge1xuICAgIF90b2dnbGVIZWFkaW5nKGVkaXRvci5jb2RlbWlycm9yLCB1bmRlZmluZWQsIDUpO1xufVxuXG4vKipcbiAqIEFjdGlvbiBmb3IgdG9nZ2xpbmcgaGVhZGluZyBzaXplIDZcbiAqL1xuZnVuY3Rpb24gdG9nZ2xlSGVhZGluZzYoZWRpdG9yKSB7XG4gICAgX3RvZ2dsZUhlYWRpbmcoZWRpdG9yLmNvZGVtaXJyb3IsIHVuZGVmaW5lZCwgNik7XG59XG5cblxuLyoqXG4gKiBBY3Rpb24gZm9yIHRvZ2dsaW5nIHVsLlxuICovXG5mdW5jdGlvbiB0b2dnbGVVbm9yZGVyZWRMaXN0KGVkaXRvcikge1xuICAgIHZhciBjbSA9IGVkaXRvci5jb2RlbWlycm9yO1xuXG4gICAgdmFyIGxpc3RTdHlsZSA9ICcqJzsgLy8gRGVmYXVsdFxuICAgIGlmIChbJy0nLCAnKycsICcqJ10uaW5jbHVkZXMoZWRpdG9yLm9wdGlvbnMudW5vcmRlcmVkTGlzdFN0eWxlKSkge1xuICAgICAgICBsaXN0U3R5bGUgPSBlZGl0b3Iub3B0aW9ucy51bm9yZGVyZWRMaXN0U3R5bGU7XG4gICAgfVxuXG4gICAgX3RvZ2dsZUxpbmUoY20sICd1bm9yZGVyZWQtbGlzdCcsIGxpc3RTdHlsZSk7XG59XG5cblxuLyoqXG4gKiBBY3Rpb24gZm9yIHRvZ2dsaW5nIG9sLlxuICovXG5mdW5jdGlvbiB0b2dnbGVPcmRlcmVkTGlzdChlZGl0b3IpIHtcbiAgICBfdG9nZ2xlTGluZShlZGl0b3IuY29kZW1pcnJvciwgJ29yZGVyZWQtbGlzdCcpO1xufVxuXG4vKipcbiAqIEFjdGlvbiBmb3IgY2xlYW4gYmxvY2sgKHJlbW92ZSBoZWFkbGluZSwgbGlzdCwgYmxvY2txdW90ZSBjb2RlLCBtYXJrZXJzKVxuICovXG5mdW5jdGlvbiBjbGVhbkJsb2NrKGVkaXRvcikge1xuICAgIF9jbGVhbkJsb2NrKGVkaXRvci5jb2RlbWlycm9yKTtcbn1cblxuLyoqXG4gKiBBY3Rpb24gZm9yIGRyYXdpbmcgYSBsaW5rLlxuICogQHBhcmFtIHtFYXN5TURFfSBlZGl0b3JcbiAqL1xuZnVuY3Rpb24gZHJhd0xpbmsoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBlZGl0b3Iub3B0aW9ucztcbiAgICB2YXIgdXJsID0gJ2h0dHBzOi8vJztcbiAgICBpZiAob3B0aW9ucy5wcm9tcHRVUkxzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBwcm9tcHQob3B0aW9ucy5wcm9tcHRUZXh0cy5saW5rLCB1cmwpO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVybCA9IGVzY2FwZVByb21wdFVSTChyZXN1bHQpO1xuICAgIH1cbiAgICBfdG9nZ2xlTGluayhlZGl0b3IsICdsaW5rJywgb3B0aW9ucy5pbnNlcnRUZXh0cy5saW5rLCB1cmwpO1xufVxuXG4vKipcbiAqIEFjdGlvbiBmb3IgZHJhd2luZyBhbiBpbWcuXG4gKiBAcGFyYW0ge0Vhc3lNREV9IGVkaXRvclxuICovXG5mdW5jdGlvbiBkcmF3SW1hZ2UoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBlZGl0b3Iub3B0aW9ucztcbiAgICB2YXIgdXJsID0gJ2h0dHBzOi8vJztcbiAgICBpZiAob3B0aW9ucy5wcm9tcHRVUkxzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBwcm9tcHQob3B0aW9ucy5wcm9tcHRUZXh0cy5pbWFnZSwgdXJsKTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1cmwgPSBlc2NhcGVQcm9tcHRVUkwocmVzdWx0KTtcbiAgICB9XG4gICAgX3RvZ2dsZUxpbmsoZWRpdG9yLCAnaW1hZ2UnLCBvcHRpb25zLmluc2VydFRleHRzLmltYWdlLCB1cmwpO1xufVxuXG4vKipcbiAqIEVuY29kZSBhbmQgZXNjYXBlIFVSTHMgdG8gcHJldmVudCBicmVha2luZyB1cCByZW5kZXJlZCBNYXJrZG93biBsaW5rcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIHVybCBvZiB0aGUgbGluayBvciBpbWFnZVxuICovXG5mdW5jdGlvbiBlc2NhcGVQcm9tcHRVUkwodXJsKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSSh1cmwpLnJlcGxhY2UoLyhbXFxcXCgpXSkvZywgJ1xcXFwkMScpO1xufVxuXG4vKipcbiAqIEFjdGlvbiBmb3Igb3BlbmluZyB0aGUgYnJvd3NlLWZpbGUgd2luZG93IHRvIHVwbG9hZCBhbiBpbWFnZSB0byBhIHNlcnZlci5cbiAqIEBwYXJhbSB7RWFzeU1ERX0gZWRpdG9yIFRoZSBFYXN5TURFIG9iamVjdFxuICovXG5mdW5jdGlvbiBkcmF3VXBsb2FkZWRJbWFnZShlZGl0b3IpIHtcbiAgICAvLyBUT0RPOiBEcmF3IHRoZSBpbWFnZSB0ZW1wbGF0ZSB3aXRoIGEgZmFrZSB1cmw/IGllOiAnIVtdKGltcG9ydGluZyBmb28ucG5nLi4uKSdcbiAgICBlZGl0b3Iub3BlbkJyb3dzZUZpbGVXaW5kb3coKTtcbn1cblxuLyoqXG4gKiBBY3Rpb24gZXhlY3V0ZWQgYWZ0ZXIgYW4gaW1hZ2UgaGF2ZSBiZWVuIHN1Y2Nlc3NmdWxseSBpbXBvcnRlZCBvbiB0aGUgc2VydmVyLlxuICogQHBhcmFtIHtFYXN5TURFfSBlZGl0b3IgVGhlIEVhc3lNREUgb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSB1cmwgb2YgdGhlIHVwbG9hZGVkIGltYWdlXG4gKi9cbmZ1bmN0aW9uIGFmdGVySW1hZ2VVcGxvYWRlZChlZGl0b3IsIHVybCkge1xuICAgIHZhciBjbSA9IGVkaXRvci5jb2RlbWlycm9yO1xuICAgIHZhciBzdGF0ID0gZ2V0U3RhdGUoY20pO1xuICAgIHZhciBvcHRpb25zID0gZWRpdG9yLm9wdGlvbnM7XG4gICAgdmFyIGltYWdlTmFtZSA9IHVybC5zdWJzdHIodXJsLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbiAgICB2YXIgZXh0ID0gaW1hZ2VOYW1lLnN1YnN0cmluZyhpbWFnZU5hbWUubGFzdEluZGV4T2YoJy4nKSArIDEpLnJlcGxhY2UoL1xcPy4qJC8sICcnKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gQ2hlY2sgaWYgbWVkaWEgaXMgYW4gaW1hZ2VcbiAgICBpZiAoWydwbmcnLCAnanBnJywgJ2pwZWcnLCAnZ2lmJywgJ3N2ZycsICdhcG5nJywgJ2F2aWYnLCAnd2VicCddLmluY2x1ZGVzKGV4dCkpIHtcbiAgICAgICAgX3JlcGxhY2VTZWxlY3Rpb24oY20sIHN0YXQuaW1hZ2UsIG9wdGlvbnMuaW5zZXJ0VGV4dHMudXBsb2FkZWRJbWFnZSwgdXJsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdGV4dF9saW5rID0gb3B0aW9ucy5pbnNlcnRUZXh0cy5saW5rO1xuICAgICAgICB0ZXh0X2xpbmtbMF0gPSAnWycgKyBpbWFnZU5hbWU7XG4gICAgICAgIF9yZXBsYWNlU2VsZWN0aW9uKGNtLCBzdGF0LmxpbmssIHRleHRfbGluaywgdXJsKTtcbiAgICB9XG5cbiAgICAvLyBzaG93IHVwbG9hZGVkIGltYWdlIGZpbGVuYW1lIGZvciAxMDAwbXNcbiAgICBlZGl0b3IudXBkYXRlU3RhdHVzQmFyKCd1cGxvYWQtaW1hZ2UnLCBlZGl0b3Iub3B0aW9ucy5pbWFnZVRleHRzLnNiT25VcGxvYWRlZC5yZXBsYWNlKCcjaW1hZ2VfbmFtZSMnLCBpbWFnZU5hbWUpKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWRpdG9yLnVwZGF0ZVN0YXR1c0JhcigndXBsb2FkLWltYWdlJywgZWRpdG9yLm9wdGlvbnMuaW1hZ2VUZXh0cy5zYkluaXQpO1xuICAgIH0sIDEwMDApO1xufVxuXG4vKipcbiAqIEFjdGlvbiBmb3IgZHJhd2luZyBhIHRhYmxlLlxuICogQHBhcmFtIHtFYXN5TURFfSBlZGl0b3JcbiAqL1xuZnVuY3Rpb24gZHJhd1RhYmxlKGVkaXRvcikge1xuICAgIHZhciBjbSA9IGVkaXRvci5jb2RlbWlycm9yO1xuICAgIHZhciBzdGF0ID0gZ2V0U3RhdGUoY20pO1xuICAgIHZhciBvcHRpb25zID0gZWRpdG9yLm9wdGlvbnM7XG4gICAgX3JlcGxhY2VTZWxlY3Rpb24oY20sIHN0YXQudGFibGUsIG9wdGlvbnMuaW5zZXJ0VGV4dHMudGFibGUpO1xufVxuXG4vKipcbiAqIEFjdGlvbiBmb3IgZHJhd2luZyBhIGhvcml6b250YWwgcnVsZS5cbiAqIEBwYXJhbSB7RWFzeU1ERX0gZWRpdG9yXG4gKi9cbmZ1bmN0aW9uIGRyYXdIb3Jpem9udGFsUnVsZShlZGl0b3IpIHtcbiAgICB2YXIgY20gPSBlZGl0b3IuY29kZW1pcnJvcjtcbiAgICB2YXIgc3RhdCA9IGdldFN0YXRlKGNtKTtcbiAgICB2YXIgb3B0aW9ucyA9IGVkaXRvci5vcHRpb25zO1xuICAgIF9yZXBsYWNlU2VsZWN0aW9uKGNtLCBzdGF0LmltYWdlLCBvcHRpb25zLmluc2VydFRleHRzLmhvcml6b250YWxSdWxlKTtcbn1cblxuXG4vKipcbiAqIFVuZG8gYWN0aW9uLlxuICogQHBhcmFtIHtFYXN5TURFfSBlZGl0b3JcbiAqL1xuZnVuY3Rpb24gdW5kbyhlZGl0b3IpIHtcbiAgICB2YXIgY20gPSBlZGl0b3IuY29kZW1pcnJvcjtcbiAgICBjbS51bmRvKCk7XG4gICAgY20uZm9jdXMoKTtcbn1cblxuXG4vKipcbiAqIFJlZG8gYWN0aW9uLlxuICogQHBhcmFtIHtFYXN5TURFfSBlZGl0b3JcbiAqL1xuZnVuY3Rpb24gcmVkbyhlZGl0b3IpIHtcbiAgICB2YXIgY20gPSBlZGl0b3IuY29kZW1pcnJvcjtcbiAgICBjbS5yZWRvKCk7XG4gICAgY20uZm9jdXMoKTtcbn1cblxuXG4vKipcbiAqIFRvZ2dsZSBzaWRlIGJ5IHNpZGUgcHJldmlld1xuICogQHBhcmFtIHtFYXN5TURFfSBlZGl0b3JcbiAqL1xuZnVuY3Rpb24gdG9nZ2xlU2lkZUJ5U2lkZShlZGl0b3IpIHtcbiAgICB2YXIgY20gPSBlZGl0b3IuY29kZW1pcnJvcjtcbiAgICB2YXIgd3JhcHBlciA9IGNtLmdldFdyYXBwZXJFbGVtZW50KCk7XG4gICAgdmFyIHByZXZpZXcgPSB3cmFwcGVyLm5leHRTaWJsaW5nO1xuICAgIHZhciB0b29sYmFyQnV0dG9uID0gZWRpdG9yLnRvb2xiYXJFbGVtZW50cyAmJiBlZGl0b3IudG9vbGJhckVsZW1lbnRzWydzaWRlLWJ5LXNpZGUnXTtcbiAgICB2YXIgdXNlU2lkZUJ5U2lkZUxpc3RlbmVyID0gZmFsc2U7XG5cbiAgICB2YXIgZWFzeU1ERUNvbnRhaW5lciA9IHdyYXBwZXIucGFyZW50Tm9kZTtcblxuICAgIGlmIChwcmV2aWV3LmNsYXNzTGlzdC5jb250YWlucygnZWRpdG9yLXByZXZpZXctYWN0aXZlLXNpZGUnKSkge1xuICAgICAgICBpZiAoZWRpdG9yLm9wdGlvbnMuc2lkZUJ5U2lkZUZ1bGxzY3JlZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAvLyBpZiBzaWRlLWJ5LXNpZGUgbm90LWZ1bGxzY3JlZW4gb2ssIHJlbW92ZSBjbGFzc2VzIHdoZW4gaGlkaW5nIHNpZGVcbiAgICAgICAgICAgIGVhc3lNREVDb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSgnc2lkZWQtLW5vLWZ1bGxzY3JlZW4nKTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aWV3LmNsYXNzTGlzdC5yZW1vdmUoJ2VkaXRvci1wcmV2aWV3LWFjdGl2ZS1zaWRlJyk7XG4gICAgICAgIGlmICh0b29sYmFyQnV0dG9uKSB0b29sYmFyQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgICB3cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoJ0NvZGVNaXJyb3Itc2lkZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXaGVuIHRoZSBwcmV2aWV3IGJ1dHRvbiBpcyBjbGlja2VkIGZvciB0aGUgZmlyc3QgdGltZSxcbiAgICAgICAgLy8gZ2l2ZSBzb21lIHRpbWUgZm9yIHRoZSB0cmFuc2l0aW9uIGZyb20gZWRpdG9yLmNzcyB0byBmaXJlIGFuZCB0aGUgdmlldyB0byBzbGlkZSBmcm9tIHJpZ2h0IHRvIGxlZnQsXG4gICAgICAgIC8vIGluc3RlYWQgb2YganVzdCBhcHBlYXJpbmcuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFjbS5nZXRPcHRpb24oJ2Z1bGxTY3JlZW4nKSkge1xuICAgICAgICAgICAgICAgIGlmIChlZGl0b3Iub3B0aW9ucy5zaWRlQnlTaWRlRnVsbHNjcmVlbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgc2lkZS1ieS1zaWRlIG5vdC1mdWxsc2NyZWVuIG9rLCBhZGQgY2xhc3NlcyB3aGVuIG5vdCBmdWxsc2NyZWVuIGFuZCBzaG93aW5nIHNpZGVcbiAgICAgICAgICAgICAgICAgICAgZWFzeU1ERUNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdzaWRlZC0tbm8tZnVsbHNjcmVlbicpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRvZ2dsZUZ1bGxTY3JlZW4oZWRpdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2aWV3LmNsYXNzTGlzdC5hZGQoJ2VkaXRvci1wcmV2aWV3LWFjdGl2ZS1zaWRlJyk7XG4gICAgICAgIH0sIDEpO1xuICAgICAgICBpZiAodG9vbGJhckJ1dHRvbikgdG9vbGJhckJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgICAgd3JhcHBlci5jbGFzc0xpc3QuYWRkKCdDb2RlTWlycm9yLXNpZGVkJyk7XG4gICAgICAgIHVzZVNpZGVCeVNpZGVMaXN0ZW5lciA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gSGlkZSBub3JtYWwgcHJldmlldyBpZiBhY3RpdmVcbiAgICB2YXIgcHJldmlld05vcm1hbCA9IHdyYXBwZXIubGFzdENoaWxkO1xuICAgIGlmIChwcmV2aWV3Tm9ybWFsLmNsYXNzTGlzdC5jb250YWlucygnZWRpdG9yLXByZXZpZXctYWN0aXZlJykpIHtcbiAgICAgICAgcHJldmlld05vcm1hbC5jbGFzc0xpc3QucmVtb3ZlKCdlZGl0b3ItcHJldmlldy1hY3RpdmUnKTtcbiAgICAgICAgdmFyIHRvb2xiYXIgPSBlZGl0b3IudG9vbGJhckVsZW1lbnRzLnByZXZpZXc7XG4gICAgICAgIHZhciB0b29sYmFyX2RpdiA9IGVkaXRvci50b29sYmFyX2RpdjtcbiAgICAgICAgdG9vbGJhci5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgICAgdG9vbGJhcl9kaXYuY2xhc3NMaXN0LnJlbW92ZSgnZGlzYWJsZWQtZm9yLXByZXZpZXcnKTtcbiAgICB9XG5cbiAgICB2YXIgc2lkZUJ5U2lkZVJlbmRlcmluZ0Z1bmN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSBlZGl0b3Iub3B0aW9ucy5wcmV2aWV3UmVuZGVyKGVkaXRvci52YWx1ZSgpLCBwcmV2aWV3KTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHByZXZpZXcuaW5uZXJIVE1MID0gbmV3VmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKCFjbS5zaWRlQnlTaWRlUmVuZGVyaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgY20uc2lkZUJ5U2lkZVJlbmRlcmluZ0Z1bmN0aW9uID0gc2lkZUJ5U2lkZVJlbmRlcmluZ0Z1bmN0aW9uO1xuICAgIH1cblxuICAgIGlmICh1c2VTaWRlQnlTaWRlTGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gZWRpdG9yLm9wdGlvbnMucHJldmlld1JlbmRlcihlZGl0b3IudmFsdWUoKSwgcHJldmlldyk7XG4gICAgICAgIGlmIChuZXdWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBwcmV2aWV3LmlubmVySFRNTCA9IG5ld1ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGNtLm9uKCd1cGRhdGUnLCBjbS5zaWRlQnlTaWRlUmVuZGVyaW5nRnVuY3Rpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNtLm9mZigndXBkYXRlJywgY20uc2lkZUJ5U2lkZVJlbmRlcmluZ0Z1bmN0aW9uKTtcbiAgICB9XG5cbiAgICAvLyBSZWZyZXNoIHRvIGZpeCBzZWxlY3Rpb24gYmVpbmcgb2ZmICgjMzA5KVxuICAgIGNtLnJlZnJlc2goKTtcbn1cblxuXG4vKipcbiAqIFByZXZpZXcgYWN0aW9uLlxuICogQHBhcmFtIHtFYXN5TURFfSBlZGl0b3JcbiAqL1xuZnVuY3Rpb24gdG9nZ2xlUHJldmlldyhlZGl0b3IpIHtcbiAgICB2YXIgY20gPSBlZGl0b3IuY29kZW1pcnJvcjtcbiAgICB2YXIgd3JhcHBlciA9IGNtLmdldFdyYXBwZXJFbGVtZW50KCk7XG4gICAgdmFyIHRvb2xiYXJfZGl2ID0gZWRpdG9yLnRvb2xiYXJfZGl2O1xuICAgIHZhciB0b29sYmFyID0gZWRpdG9yLm9wdGlvbnMudG9vbGJhciA/IGVkaXRvci50b29sYmFyRWxlbWVudHMucHJldmlldyA6IGZhbHNlO1xuICAgIHZhciBwcmV2aWV3ID0gd3JhcHBlci5sYXN0Q2hpbGQ7XG5cbiAgICAvLyBUdXJuIG9mZiBzaWRlIGJ5IHNpZGUgaWYgbmVlZGVkXG4gICAgdmFyIHNpZGVieXNpZGUgPSBjbS5nZXRXcmFwcGVyRWxlbWVudCgpLm5leHRTaWJsaW5nO1xuICAgIGlmIChzaWRlYnlzaWRlLmNsYXNzTGlzdC5jb250YWlucygnZWRpdG9yLXByZXZpZXctYWN0aXZlLXNpZGUnKSlcbiAgICAgICAgdG9nZ2xlU2lkZUJ5U2lkZShlZGl0b3IpO1xuXG4gICAgaWYgKCFwcmV2aWV3IHx8ICFwcmV2aWV3LmNsYXNzTGlzdC5jb250YWlucygnZWRpdG9yLXByZXZpZXctZnVsbCcpKSB7XG5cbiAgICAgICAgcHJldmlldyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBwcmV2aWV3LmNsYXNzTmFtZSA9ICdlZGl0b3ItcHJldmlldy1mdWxsJztcblxuICAgICAgICBpZiAoZWRpdG9yLm9wdGlvbnMucHJldmlld0NsYXNzKSB7XG5cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVkaXRvci5vcHRpb25zLnByZXZpZXdDbGFzcykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkaXRvci5vcHRpb25zLnByZXZpZXdDbGFzcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aWV3LmNsYXNzTGlzdC5hZGQoZWRpdG9yLm9wdGlvbnMucHJldmlld0NsYXNzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVkaXRvci5vcHRpb25zLnByZXZpZXdDbGFzcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBwcmV2aWV3LmNsYXNzTGlzdC5hZGQoZWRpdG9yLm9wdGlvbnMucHJldmlld0NsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQocHJldmlldyk7XG4gICAgfVxuXG4gICAgaWYgKHByZXZpZXcuY2xhc3NMaXN0LmNvbnRhaW5zKCdlZGl0b3ItcHJldmlldy1hY3RpdmUnKSkge1xuICAgICAgICBwcmV2aWV3LmNsYXNzTGlzdC5yZW1vdmUoJ2VkaXRvci1wcmV2aWV3LWFjdGl2ZScpO1xuICAgICAgICBpZiAodG9vbGJhcikge1xuICAgICAgICAgICAgdG9vbGJhci5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgICAgICAgIHRvb2xiYXJfZGl2LmNsYXNzTGlzdC5yZW1vdmUoJ2Rpc2FibGVkLWZvci1wcmV2aWV3Jyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXaGVuIHRoZSBwcmV2aWV3IGJ1dHRvbiBpcyBjbGlja2VkIGZvciB0aGUgZmlyc3QgdGltZSxcbiAgICAgICAgLy8gZ2l2ZSBzb21lIHRpbWUgZm9yIHRoZSB0cmFuc2l0aW9uIGZyb20gZWRpdG9yLmNzcyB0byBmaXJlIGFuZCB0aGUgdmlldyB0byBzbGlkZSBmcm9tIHJpZ2h0IHRvIGxlZnQsXG4gICAgICAgIC8vIGluc3RlYWQgb2YganVzdCBhcHBlYXJpbmcuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcHJldmlldy5jbGFzc0xpc3QuYWRkKCdlZGl0b3ItcHJldmlldy1hY3RpdmUnKTtcbiAgICAgICAgfSwgMSk7XG4gICAgICAgIGlmICh0b29sYmFyKSB7XG4gICAgICAgICAgICB0b29sYmFyLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgdG9vbGJhcl9kaXYuY2xhc3NMaXN0LmFkZCgnZGlzYWJsZWQtZm9yLXByZXZpZXcnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aWV3X3Jlc3VsdCA9IGVkaXRvci5vcHRpb25zLnByZXZpZXdSZW5kZXIoZWRpdG9yLnZhbHVlKCksIHByZXZpZXcpO1xuICAgIGlmIChwcmV2aWV3X3Jlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICBwcmV2aWV3LmlubmVySFRNTCA9IHByZXZpZXdfcmVzdWx0O1xuICAgIH1cblxufVxuXG5mdW5jdGlvbiBfcmVwbGFjZVNlbGVjdGlvbihjbSwgYWN0aXZlLCBzdGFydEVuZCwgdXJsKSB7XG4gICAgaWYgKGNtLmdldFdyYXBwZXJFbGVtZW50KCkubGFzdENoaWxkLmNsYXNzTGlzdC5jb250YWlucygnZWRpdG9yLXByZXZpZXctYWN0aXZlJykpXG4gICAgICAgIHJldHVybjtcblxuICAgIHZhciB0ZXh0O1xuICAgIHZhciBzdGFydCA9IHN0YXJ0RW5kWzBdO1xuICAgIHZhciBlbmQgPSBzdGFydEVuZFsxXTtcbiAgICB2YXIgc3RhcnRQb2ludCA9IHt9LFxuICAgICAgICBlbmRQb2ludCA9IHt9O1xuICAgIE9iamVjdC5hc3NpZ24oc3RhcnRQb2ludCwgY20uZ2V0Q3Vyc29yKCdzdGFydCcpKTtcbiAgICBPYmplY3QuYXNzaWduKGVuZFBvaW50LCBjbS5nZXRDdXJzb3IoJ2VuZCcpKTtcbiAgICBpZiAodXJsKSB7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnQucmVwbGFjZSgnI3VybCMnLCB1cmwpOyAgLy8gdXJsIGlzIGluIHN0YXJ0IGZvciB1cGxvYWQtaW1hZ2VcbiAgICAgICAgZW5kID0gZW5kLnJlcGxhY2UoJyN1cmwjJywgdXJsKTtcbiAgICB9XG4gICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICB0ZXh0ID0gY20uZ2V0TGluZShzdGFydFBvaW50LmxpbmUpO1xuICAgICAgICBzdGFydCA9IHRleHQuc2xpY2UoMCwgc3RhcnRQb2ludC5jaCk7XG4gICAgICAgIGVuZCA9IHRleHQuc2xpY2Uoc3RhcnRQb2ludC5jaCk7XG4gICAgICAgIGNtLnJlcGxhY2VSYW5nZShzdGFydCArIGVuZCwge1xuICAgICAgICAgICAgbGluZTogc3RhcnRQb2ludC5saW5lLFxuICAgICAgICAgICAgY2g6IDAsXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBjbS5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbihzdGFydCArIHRleHQgKyBlbmQpO1xuXG4gICAgICAgIHN0YXJ0UG9pbnQuY2ggKz0gc3RhcnQubGVuZ3RoO1xuICAgICAgICBpZiAoc3RhcnRQb2ludCAhPT0gZW5kUG9pbnQpIHtcbiAgICAgICAgICAgIGVuZFBvaW50LmNoICs9IHN0YXJ0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbS5zZXRTZWxlY3Rpb24oc3RhcnRQb2ludCwgZW5kUG9pbnQpO1xuICAgIGNtLmZvY3VzKCk7XG59XG5cblxuZnVuY3Rpb24gX3RvZ2dsZUhlYWRpbmcoY20sIGRpcmVjdGlvbiwgc2l6ZSkge1xuICAgIGlmIChjbS5nZXRXcmFwcGVyRWxlbWVudCgpLmxhc3RDaGlsZC5jbGFzc0xpc3QuY29udGFpbnMoJ2VkaXRvci1wcmV2aWV3LWFjdGl2ZScpKVxuICAgICAgICByZXR1cm47XG5cbiAgICB2YXIgc3RhcnRQb2ludCA9IGNtLmdldEN1cnNvcignc3RhcnQnKTtcbiAgICB2YXIgZW5kUG9pbnQgPSBjbS5nZXRDdXJzb3IoJ2VuZCcpO1xuICAgIGZvciAodmFyIGkgPSBzdGFydFBvaW50LmxpbmU7IGkgPD0gZW5kUG9pbnQubGluZTsgaSsrKSB7XG4gICAgICAgIChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgdmFyIHRleHQgPSBjbS5nZXRMaW5lKGkpO1xuICAgICAgICAgICAgdmFyIGN1cnJIZWFkaW5nTGV2ZWwgPSB0ZXh0LnNlYXJjaCgvW14jXS8pO1xuXG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyckhlYWRpbmdMZXZlbCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT0gJ2JpZ2dlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSAnIyMjIyMjICcgKyB0ZXh0O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9ICcjICcgKyB0ZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJySGVhZGluZ0xldmVsID09IDYgJiYgZGlyZWN0aW9uID09ICdzbWFsbGVyJykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHIoNyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJySGVhZGluZ0xldmVsID09IDEgJiYgZGlyZWN0aW9uID09ICdiaWdnZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cigyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09ICdiaWdnZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gJyMnICsgdGV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJIZWFkaW5nTGV2ZWwgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gJyMnLnJlcGVhdChzaXplKSArICcgJyArIHRleHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJySGVhZGluZ0xldmVsID09IHNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyKGN1cnJIZWFkaW5nTGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gJyMnLnJlcGVhdChzaXplKSArICcgJyArIHRleHQuc3Vic3RyKGN1cnJIZWFkaW5nTGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZSh0ZXh0LCB7XG4gICAgICAgICAgICAgICAgbGluZTogaSxcbiAgICAgICAgICAgICAgICBjaDogMCxcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBsaW5lOiBpLFxuICAgICAgICAgICAgICAgIGNoOiA5OTk5OTk5OTk5OTk5OSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KShpKTtcbiAgICB9XG4gICAgY20uZm9jdXMoKTtcbn1cblxuXG5mdW5jdGlvbiBfdG9nZ2xlTGluZShjbSwgbmFtZSwgbGlzdHN0eWxlKSB7XG4gICAgaWYgKGNtLmdldFdyYXBwZXJFbGVtZW50KCkubGFzdENoaWxkLmNsYXNzTGlzdC5jb250YWlucygnZWRpdG9yLXByZXZpZXctYWN0aXZlJykpXG4gICAgICAgIHJldHVybjtcblxuICAgIHZhciBsaXN0UmVnZXhwID0gL14oXFxzKikoXFwqfC18XFwrfFxcZCpcXC4pKFxccyspLztcbiAgICB2YXIgd2hpdGVzcGFjZXNSZWdleHAgPSAvXlxccyovO1xuXG4gICAgdmFyIHN0YXQgPSBnZXRTdGF0ZShjbSk7XG4gICAgdmFyIHN0YXJ0UG9pbnQgPSBjbS5nZXRDdXJzb3IoJ3N0YXJ0Jyk7XG4gICAgdmFyIGVuZFBvaW50ID0gY20uZ2V0Q3Vyc29yKCdlbmQnKTtcbiAgICB2YXIgcmVwbCA9IHtcbiAgICAgICAgJ3F1b3RlJzogL14oXFxzKik+XFxzKy8sXG4gICAgICAgICd1bm9yZGVyZWQtbGlzdCc6IGxpc3RSZWdleHAsXG4gICAgICAgICdvcmRlcmVkLWxpc3QnOiBsaXN0UmVnZXhwLFxuICAgIH07XG5cbiAgICB2YXIgX2dldENoYXIgPSBmdW5jdGlvbiAobmFtZSwgaSkge1xuICAgICAgICB2YXIgbWFwID0ge1xuICAgICAgICAgICAgJ3F1b3RlJzogJz4nLFxuICAgICAgICAgICAgJ3Vub3JkZXJlZC1saXN0JzogbGlzdHN0eWxlLFxuICAgICAgICAgICAgJ29yZGVyZWQtbGlzdCc6ICclJWkuJyxcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbWFwW25hbWVdLnJlcGxhY2UoJyUlaScsIGkpO1xuICAgIH07XG5cbiAgICB2YXIgX2NoZWNrQ2hhciA9IGZ1bmN0aW9uIChuYW1lLCBjaGFyKSB7XG4gICAgICAgIHZhciBtYXAgPSB7XG4gICAgICAgICAgICAncXVvdGUnOiAnPicsXG4gICAgICAgICAgICAndW5vcmRlcmVkLWxpc3QnOiAnXFxcXCcgKyBsaXN0c3R5bGUsXG4gICAgICAgICAgICAnb3JkZXJlZC1saXN0JzogJ1xcXFxkKy4nLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgcnQgPSBuZXcgUmVnRXhwKG1hcFtuYW1lXSk7XG5cbiAgICAgICAgcmV0dXJuIGNoYXIgJiYgcnQudGVzdChjaGFyKTtcbiAgICB9O1xuXG4gICAgdmFyIF90b2dnbGUgPSBmdW5jdGlvbiAobmFtZSwgdGV4dCwgdW50b2dnbGVPbmx5KSB7XG4gICAgICAgIHZhciBhcnIgPSBsaXN0UmVnZXhwLmV4ZWModGV4dCk7XG4gICAgICAgIHZhciBjaGFyID0gX2dldENoYXIobmFtZSwgbGluZSk7XG4gICAgICAgIGlmIChhcnIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChfY2hlY2tDaGFyKG5hbWUsIGFyclsyXSkpIHtcbiAgICAgICAgICAgICAgICBjaGFyID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0ID0gYXJyWzFdICsgY2hhciArIGFyclszXSArIHRleHQucmVwbGFjZSh3aGl0ZXNwYWNlc1JlZ2V4cCwgJycpLnJlcGxhY2UocmVwbFtuYW1lXSwgJyQxJyk7XG4gICAgICAgIH0gZWxzZSBpZiAodW50b2dnbGVPbmx5ID09IGZhbHNlKSB7XG4gICAgICAgICAgICB0ZXh0ID0gY2hhciArICcgJyArIHRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcblxuICAgIHZhciBsaW5lID0gMTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnRQb2ludC5saW5lOyBpIDw9IGVuZFBvaW50LmxpbmU7IGkrKykge1xuICAgICAgICAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gY20uZ2V0TGluZShpKTtcbiAgICAgICAgICAgIGlmIChzdGF0W25hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShyZXBsW25hbWVdLCAnJDEnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgdG9nZ2xpbmcgdW5vcmRlcmVkLWxpc3QgZm9ybWF0dGluZywgY2hlY2sgaWYgdGhlIGN1cnJlbnQgbGluZVxuICAgICAgICAgICAgICAgIC8vIGlzIHBhcnQgb2YgYW4gb3JkZXJlZC1saXN0LCBhbmQgaWYgc28sIHVudG9nZ2xlIHRoYXQgZmlyc3QuXG4gICAgICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL0lvbmFydS9lYXN5LW1hcmtkb3duLWVkaXRvci9pc3N1ZXMvOTJcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PSAndW5vcmRlcmVkLWxpc3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSBfdG9nZ2xlKCdvcmRlcmVkLWxpc3QnLCB0ZXh0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGV4dCA9IF90b2dnbGUobmFtZSwgdGV4dCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGxpbmUgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZSh0ZXh0LCB7XG4gICAgICAgICAgICAgICAgbGluZTogaSxcbiAgICAgICAgICAgICAgICBjaDogMCxcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBsaW5lOiBpLFxuICAgICAgICAgICAgICAgIGNoOiA5OTk5OTk5OTk5OTk5OSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KShpKTtcbiAgICB9XG4gICAgY20uZm9jdXMoKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Vhc3lNREV9IGVkaXRvclxuICogQHBhcmFtIHsnbGluaycgfCAnaW1hZ2UnfSB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RhcnRFbmRcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqL1xuZnVuY3Rpb24gX3RvZ2dsZUxpbmsoZWRpdG9yLCB0eXBlLCBzdGFydEVuZCwgdXJsKSB7XG4gICAgaWYgKCFlZGl0b3IuY29kZW1pcnJvciB8fCBlZGl0b3IuaXNQcmV2aWV3QWN0aXZlKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjbSA9IGVkaXRvci5jb2RlbWlycm9yO1xuICAgIHZhciBzdGF0ID0gZ2V0U3RhdGUoY20pO1xuICAgIHZhciBhY3RpdmUgPSBzdGF0W3R5cGVdO1xuICAgIGlmICghYWN0aXZlKSB7XG4gICAgICAgIF9yZXBsYWNlU2VsZWN0aW9uKGNtLCBhY3RpdmUsIHN0YXJ0RW5kLCB1cmwpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0UG9pbnQgPSBjbS5nZXRDdXJzb3IoJ3N0YXJ0Jyk7XG4gICAgdmFyIGVuZFBvaW50ID0gY20uZ2V0Q3Vyc29yKCdlbmQnKTtcbiAgICB2YXIgdGV4dCA9IGNtLmdldExpbmUoc3RhcnRQb2ludC5saW5lKTtcbiAgICB2YXIgc3RhcnQgPSB0ZXh0LnNsaWNlKDAsIHN0YXJ0UG9pbnQuY2gpO1xuICAgIHZhciBlbmQgPSB0ZXh0LnNsaWNlKHN0YXJ0UG9pbnQuY2gpO1xuXG4gICAgaWYgKHR5cGUgPT0gJ2xpbmsnKSB7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnQucmVwbGFjZSgvKC4qKVteIV1cXFsvLCAnJDEnKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ2ltYWdlJykge1xuICAgICAgICBzdGFydCA9IHN0YXJ0LnJlcGxhY2UoLyguKikhXFxbJC8sICckMScpO1xuICAgIH1cbiAgICBlbmQgPSBlbmQucmVwbGFjZSgvXVxcKC4qP1xcKS8sICcnKTtcblxuICAgIGNtLnJlcGxhY2VSYW5nZShzdGFydCArIGVuZCwge1xuICAgICAgICBsaW5lOiBzdGFydFBvaW50LmxpbmUsXG4gICAgICAgIGNoOiAwLFxuICAgIH0sIHtcbiAgICAgICAgbGluZTogc3RhcnRQb2ludC5saW5lLFxuICAgICAgICBjaDogOTk5OTk5OTk5OTk5OTksXG4gICAgfSk7XG5cbiAgICBzdGFydFBvaW50LmNoIC09IHN0YXJ0RW5kWzBdLmxlbmd0aDtcbiAgICBpZiAoc3RhcnRQb2ludCAhPT0gZW5kUG9pbnQpIHtcbiAgICAgICAgZW5kUG9pbnQuY2ggLT0gc3RhcnRFbmRbMF0ubGVuZ3RoO1xuICAgIH1cbiAgICBjbS5zZXRTZWxlY3Rpb24oc3RhcnRQb2ludCwgZW5kUG9pbnQpO1xuICAgIGNtLmZvY3VzKCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFYXN5TURFfSBlZGl0b3JcbiAqL1xuZnVuY3Rpb24gX3RvZ2dsZUJsb2NrKGVkaXRvciwgdHlwZSwgc3RhcnRfY2hhcnMsIGVuZF9jaGFycykge1xuICAgIGlmICghZWRpdG9yLmNvZGVtaXJyb3IgfHwgZWRpdG9yLmlzUHJldmlld0FjdGl2ZSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbmRfY2hhcnMgPSAodHlwZW9mIGVuZF9jaGFycyA9PT0gJ3VuZGVmaW5lZCcpID8gc3RhcnRfY2hhcnMgOiBlbmRfY2hhcnM7XG4gICAgdmFyIGNtID0gZWRpdG9yLmNvZGVtaXJyb3I7XG4gICAgdmFyIHN0YXQgPSBnZXRTdGF0ZShjbSk7XG5cbiAgICB2YXIgdGV4dDtcbiAgICB2YXIgc3RhcnQgPSBzdGFydF9jaGFycztcbiAgICB2YXIgZW5kID0gZW5kX2NoYXJzO1xuXG4gICAgdmFyIHN0YXJ0UG9pbnQgPSBjbS5nZXRDdXJzb3IoJ3N0YXJ0Jyk7XG4gICAgdmFyIGVuZFBvaW50ID0gY20uZ2V0Q3Vyc29yKCdlbmQnKTtcblxuICAgIGlmIChzdGF0W3R5cGVdKSB7XG4gICAgICAgIHRleHQgPSBjbS5nZXRMaW5lKHN0YXJ0UG9pbnQubGluZSk7XG4gICAgICAgIHN0YXJ0ID0gdGV4dC5zbGljZSgwLCBzdGFydFBvaW50LmNoKTtcbiAgICAgICAgZW5kID0gdGV4dC5zbGljZShzdGFydFBvaW50LmNoKTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ2JvbGQnKSB7XG4gICAgICAgICAgICBzdGFydCA9IHN0YXJ0LnJlcGxhY2UoLyhcXCpcXCp8X18pKD8hW1xcc1xcU10qKFxcKlxcKnxfXykpLywgJycpO1xuICAgICAgICAgICAgZW5kID0gZW5kLnJlcGxhY2UoLyhcXCpcXCp8X18pLywgJycpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ2l0YWxpYycpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnQucmVwbGFjZSgvKFxcKnxfKSg/IVtcXHNcXFNdKihcXCp8XykpLywgJycpO1xuICAgICAgICAgICAgZW5kID0gZW5kLnJlcGxhY2UoLyhcXCp8XykvLCAnJyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSAnc3RyaWtldGhyb3VnaCcpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnQucmVwbGFjZSgvKFxcKlxcKnx+fikoPyFbXFxzXFxTXSooXFwqXFwqfH5+KSkvLCAnJyk7XG4gICAgICAgICAgICBlbmQgPSBlbmQucmVwbGFjZSgvKFxcKlxcKnx+fikvLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgY20ucmVwbGFjZVJhbmdlKHN0YXJ0ICsgZW5kLCB7XG4gICAgICAgICAgICBsaW5lOiBzdGFydFBvaW50LmxpbmUsXG4gICAgICAgICAgICBjaDogMCxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbGluZTogc3RhcnRQb2ludC5saW5lLFxuICAgICAgICAgICAgY2g6IDk5OTk5OTk5OTk5OTk5LFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodHlwZSA9PSAnYm9sZCcgfHwgdHlwZSA9PSAnc3RyaWtldGhyb3VnaCcpIHtcbiAgICAgICAgICAgIHN0YXJ0UG9pbnQuY2ggLT0gMjtcbiAgICAgICAgICAgIGlmIChzdGFydFBvaW50ICE9PSBlbmRQb2ludCkge1xuICAgICAgICAgICAgICAgIGVuZFBvaW50LmNoIC09IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSAnaXRhbGljJykge1xuICAgICAgICAgICAgc3RhcnRQb2ludC5jaCAtPSAxO1xuICAgICAgICAgICAgaWYgKHN0YXJ0UG9pbnQgIT09IGVuZFBvaW50KSB7XG4gICAgICAgICAgICAgICAgZW5kUG9pbnQuY2ggLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBjbS5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ2JvbGQnKSB7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5zcGxpdCgnKionKS5qb2luKCcnKTtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNwbGl0KCdfXycpLmpvaW4oJycpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ2l0YWxpYycpIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNwbGl0KCcqJykuam9pbignJyk7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5zcGxpdCgnXycpLmpvaW4oJycpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ3N0cmlrZXRocm91Z2gnKSB7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5zcGxpdCgnfn4nKS5qb2luKCcnKTtcbiAgICAgICAgfVxuICAgICAgICBjbS5yZXBsYWNlU2VsZWN0aW9uKHN0YXJ0ICsgdGV4dCArIGVuZCk7XG5cbiAgICAgICAgc3RhcnRQb2ludC5jaCArPSBzdGFydF9jaGFycy5sZW5ndGg7XG4gICAgICAgIGVuZFBvaW50LmNoID0gc3RhcnRQb2ludC5jaCArIHRleHQubGVuZ3RoO1xuICAgIH1cblxuICAgIGNtLnNldFNlbGVjdGlvbihzdGFydFBvaW50LCBlbmRQb2ludCk7XG4gICAgY20uZm9jdXMoKTtcbn1cblxuZnVuY3Rpb24gX2NsZWFuQmxvY2soY20pIHtcbiAgICBpZiAoY20uZ2V0V3JhcHBlckVsZW1lbnQoKS5sYXN0Q2hpbGQuY2xhc3NMaXN0LmNvbnRhaW5zKCdlZGl0b3ItcHJldmlldy1hY3RpdmUnKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIHN0YXJ0UG9pbnQgPSBjbS5nZXRDdXJzb3IoJ3N0YXJ0Jyk7XG4gICAgdmFyIGVuZFBvaW50ID0gY20uZ2V0Q3Vyc29yKCdlbmQnKTtcbiAgICB2YXIgdGV4dDtcblxuICAgIGZvciAodmFyIGxpbmUgPSBzdGFydFBvaW50LmxpbmU7IGxpbmUgPD0gZW5kUG9pbnQubGluZTsgbGluZSsrKSB7XG4gICAgICAgIHRleHQgPSBjbS5nZXRMaW5lKGxpbmUpO1xuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9eWyBdKihbIyBdK3xcXCp8LXxbPiBdK3xbMC05XSsoLnxcXCkpKVsgXSovLCAnJyk7XG5cbiAgICAgICAgY20ucmVwbGFjZVJhbmdlKHRleHQsIHtcbiAgICAgICAgICAgIGxpbmU6IGxpbmUsXG4gICAgICAgICAgICBjaDogMCxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbGluZTogbGluZSxcbiAgICAgICAgICAgIGNoOiA5OTk5OTk5OTk5OTk5OSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSBudW1iZXIgb2YgYnl0ZXMgdG8gYSBodW1hbi1yZWFkYWJsZSBmaWxlIHNpemUuIElmIHlvdSBkZXNpcmVcbiAqIHRvIGFkZCBhIHNwYWNlIGJldHdlZW4gdGhlIHZhbHVlIGFuZCB0aGUgdW5pdCwgeW91IG5lZWQgdG8gYWRkIHRoaXMgc3BhY2VcbiAqIHRvIHRoZSBnaXZlbiB1bml0cy5cbiAqIEBwYXJhbSBieXRlcyB7bnVtYmVyfSBBIG51bWJlciBvZiBieXRlcywgYXMgaW50ZWdlci4gRXg6IDQyMTEzN1xuICogQHBhcmFtIHVuaXRzIHtudW1iZXJbXX0gQW4gYXJyYXkgb2YgaHVtYW4tcmVhZGFibGUgdW5pdHMsIGllLiBbJyBCJywgJyBLJywgJyBNQiddXG4gKiBAcmV0dXJucyBzdHJpbmcgQSBodW1hbi1yZWFkYWJsZSBmaWxlIHNpemUuIEV4OiAnNDEyIEtCJ1xuICovXG5mdW5jdGlvbiBodW1hbkZpbGVTaXplKGJ5dGVzLCB1bml0cykge1xuICAgIGlmIChNYXRoLmFicyhieXRlcykgPCAxMDI0KSB7XG4gICAgICAgIHJldHVybiAnJyArIGJ5dGVzICsgdW5pdHNbMF07XG4gICAgfVxuICAgIHZhciB1ID0gMDtcbiAgICBkbyB7XG4gICAgICAgIGJ5dGVzIC89IDEwMjQ7XG4gICAgICAgICsrdTtcbiAgICB9IHdoaWxlIChNYXRoLmFicyhieXRlcykgPj0gMTAyNCAmJiB1IDwgdW5pdHMubGVuZ3RoKTtcbiAgICByZXR1cm4gJycgKyBieXRlcy50b0ZpeGVkKDEpICsgdW5pdHNbdV07XG59XG5cbi8vIE1lcmdlIHRoZSBwcm9wZXJ0aWVzIG9mIG9uZSBvYmplY3QgaW50byBhbm90aGVyLlxuZnVuY3Rpb24gX21lcmdlUHJvcGVydGllcyh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlW3Byb3BlcnR5XSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3Byb3BlcnR5XSA9IHNvdXJjZVtwcm9wZXJ0eV0uY29uY2F0KHRhcmdldFtwcm9wZXJ0eV0gaW5zdGFuY2VvZiBBcnJheSA/IHRhcmdldFtwcm9wZXJ0eV0gOiBbXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHNvdXJjZVtwcm9wZXJ0eV0gIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2Ygc291cmNlW3Byb3BlcnR5XSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICBzb3VyY2VbcHJvcGVydHldLmNvbnN0cnVjdG9yID09PSBPYmplY3RcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtwcm9wZXJ0eV0gPSBfbWVyZ2VQcm9wZXJ0aWVzKHRhcmdldFtwcm9wZXJ0eV0gfHwge30sIHNvdXJjZVtwcm9wZXJ0eV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbcHJvcGVydHldID0gc291cmNlW3Byb3BlcnR5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbi8vIE1lcmdlIGFuIGFyYml0cmFyeSBudW1iZXIgb2Ygb2JqZWN0cyBpbnRvIG9uZS5cbmZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0YXJnZXQgPSBfbWVyZ2VQcm9wZXJ0aWVzKHRhcmdldCwgYXJndW1lbnRzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKiBUaGUgcmlnaHQgd29yZCBjb3VudCBpbiByZXNwZWN0IGZvciBDSksuICovXG5mdW5jdGlvbiB3b3JkQ291bnQoZGF0YSkge1xuICAgIHZhciBwYXR0ZXJuID0gL1thLXpBLVowLTlfXFx1MDBBMC1cXHUwMkFGXFx1MDM5Mi1cXHUwM2M5XFx1MDQxMC1cXHUwNEY5XSt8W1xcdTRFMDAtXFx1OUZGRlxcdTM0MDAtXFx1NGRiZlxcdWY5MDAtXFx1ZmFmZlxcdTMwNDAtXFx1MzA5ZlxcdWFjMDAtXFx1ZDdhZl0rL2c7XG4gICAgdmFyIG0gPSBkYXRhLm1hdGNoKHBhdHRlcm4pO1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgaWYgKG0gPT09IG51bGwpIHJldHVybiBjb3VudDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKG1baV0uY2hhckNvZGVBdCgwKSA+PSAweDRFMDApIHtcbiAgICAgICAgICAgIGNvdW50ICs9IG1baV0ubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY291bnQ7XG59XG5cbnZhciBpY29uQ2xhc3NNYXAgPSB7XG4gICAgJ2JvbGQnOiAnZmEgZmEtYm9sZCcsXG4gICAgJ2l0YWxpYyc6ICdmYSBmYS1pdGFsaWMnLFxuICAgICdzdHJpa2V0aHJvdWdoJzogJ2ZhIGZhLXN0cmlrZXRocm91Z2gnLFxuICAgICdoZWFkaW5nJzogJ2ZhIGZhLWhlYWRlciBmYS1oZWFkaW5nJyxcbiAgICAnaGVhZGluZy1zbWFsbGVyJzogJ2ZhIGZhLWhlYWRlciBmYS1oZWFkaW5nIGhlYWRlci1zbWFsbGVyJyxcbiAgICAnaGVhZGluZy1iaWdnZXInOiAnZmEgZmEtaGVhZGVyIGZhLWhlYWRpbmcgaGVhZGVyLWJpZ2dlcicsXG4gICAgJ2hlYWRpbmctMSc6ICdmYSBmYS1oZWFkZXIgZmEtaGVhZGluZyBoZWFkZXItMScsXG4gICAgJ2hlYWRpbmctMic6ICdmYSBmYS1oZWFkZXIgZmEtaGVhZGluZyBoZWFkZXItMicsXG4gICAgJ2hlYWRpbmctMyc6ICdmYSBmYS1oZWFkZXIgZmEtaGVhZGluZyBoZWFkZXItMycsXG4gICAgJ2NvZGUnOiAnZmEgZmEtY29kZScsXG4gICAgJ3F1b3RlJzogJ2ZhIGZhLXF1b3RlLWxlZnQnLFxuICAgICdvcmRlcmVkLWxpc3QnOiAnZmEgZmEtbGlzdC1vbCcsXG4gICAgJ3Vub3JkZXJlZC1saXN0JzogJ2ZhIGZhLWxpc3QtdWwnLFxuICAgICdjbGVhbi1ibG9jayc6ICdmYSBmYS1lcmFzZXInLFxuICAgICdsaW5rJzogJ2ZhIGZhLWxpbmsnLFxuICAgICdpbWFnZSc6ICdmYSBmYS1pbWFnZScsXG4gICAgJ3VwbG9hZC1pbWFnZSc6ICdmYSBmYS1pbWFnZScsXG4gICAgJ3RhYmxlJzogJ2ZhIGZhLXRhYmxlJyxcbiAgICAnaG9yaXpvbnRhbC1ydWxlJzogJ2ZhIGZhLW1pbnVzJyxcbiAgICAncHJldmlldyc6ICdmYSBmYS1leWUnLFxuICAgICdzaWRlLWJ5LXNpZGUnOiAnZmEgZmEtY29sdW1ucycsXG4gICAgJ2Z1bGxzY3JlZW4nOiAnZmEgZmEtYXJyb3dzLWFsdCcsXG4gICAgJ2d1aWRlJzogJ2ZhIGZhLXF1ZXN0aW9uLWNpcmNsZScsXG4gICAgJ3VuZG8nOiAnZmEgZmEtdW5kbycsXG4gICAgJ3JlZG8nOiAnZmEgZmEtcmVwZWF0IGZhLXJlZG8nLFxufTtcblxudmFyIHRvb2xiYXJCdWlsdEluQnV0dG9ucyA9IHtcbiAgICAnYm9sZCc6IHtcbiAgICAgICAgbmFtZTogJ2JvbGQnLFxuICAgICAgICBhY3Rpb246IHRvZ2dsZUJvbGQsXG4gICAgICAgIGNsYXNzTmFtZTogaWNvbkNsYXNzTWFwWydib2xkJ10sXG4gICAgICAgIHRpdGxlOiAnQm9sZCcsXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgfSxcbiAgICAnaXRhbGljJzoge1xuICAgICAgICBuYW1lOiAnaXRhbGljJyxcbiAgICAgICAgYWN0aW9uOiB0b2dnbGVJdGFsaWMsXG4gICAgICAgIGNsYXNzTmFtZTogaWNvbkNsYXNzTWFwWydpdGFsaWMnXSxcbiAgICAgICAgdGl0bGU6ICdJdGFsaWMnLFxuICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgIH0sXG4gICAgJ3N0cmlrZXRocm91Z2gnOiB7XG4gICAgICAgIG5hbWU6ICdzdHJpa2V0aHJvdWdoJyxcbiAgICAgICAgYWN0aW9uOiB0b2dnbGVTdHJpa2V0aHJvdWdoLFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsnc3RyaWtldGhyb3VnaCddLFxuICAgICAgICB0aXRsZTogJ1N0cmlrZXRocm91Z2gnLFxuICAgIH0sXG4gICAgJ2hlYWRpbmcnOiB7XG4gICAgICAgIG5hbWU6ICdoZWFkaW5nJyxcbiAgICAgICAgYWN0aW9uOiB0b2dnbGVIZWFkaW5nU21hbGxlcixcbiAgICAgICAgY2xhc3NOYW1lOiBpY29uQ2xhc3NNYXBbJ2hlYWRpbmcnXSxcbiAgICAgICAgdGl0bGU6ICdIZWFkaW5nJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB9LFxuICAgICdoZWFkaW5nLXNtYWxsZXInOiB7XG4gICAgICAgIG5hbWU6ICdoZWFkaW5nLXNtYWxsZXInLFxuICAgICAgICBhY3Rpb246IHRvZ2dsZUhlYWRpbmdTbWFsbGVyLFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsnaGVhZGluZy1zbWFsbGVyJ10sXG4gICAgICAgIHRpdGxlOiAnU21hbGxlciBIZWFkaW5nJyxcbiAgICB9LFxuICAgICdoZWFkaW5nLWJpZ2dlcic6IHtcbiAgICAgICAgbmFtZTogJ2hlYWRpbmctYmlnZ2VyJyxcbiAgICAgICAgYWN0aW9uOiB0b2dnbGVIZWFkaW5nQmlnZ2VyLFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsnaGVhZGluZy1iaWdnZXInXSxcbiAgICAgICAgdGl0bGU6ICdCaWdnZXIgSGVhZGluZycsXG4gICAgfSxcbiAgICAnaGVhZGluZy0xJzoge1xuICAgICAgICBuYW1lOiAnaGVhZGluZy0xJyxcbiAgICAgICAgYWN0aW9uOiB0b2dnbGVIZWFkaW5nMSxcbiAgICAgICAgY2xhc3NOYW1lOiBpY29uQ2xhc3NNYXBbJ2hlYWRpbmctMSddLFxuICAgICAgICB0aXRsZTogJ0JpZyBIZWFkaW5nJyxcbiAgICB9LFxuICAgICdoZWFkaW5nLTInOiB7XG4gICAgICAgIG5hbWU6ICdoZWFkaW5nLTInLFxuICAgICAgICBhY3Rpb246IHRvZ2dsZUhlYWRpbmcyLFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsnaGVhZGluZy0yJ10sXG4gICAgICAgIHRpdGxlOiAnTWVkaXVtIEhlYWRpbmcnLFxuICAgIH0sXG4gICAgJ2hlYWRpbmctMyc6IHtcbiAgICAgICAgbmFtZTogJ2hlYWRpbmctMycsXG4gICAgICAgIGFjdGlvbjogdG9nZ2xlSGVhZGluZzMsXG4gICAgICAgIGNsYXNzTmFtZTogaWNvbkNsYXNzTWFwWydoZWFkaW5nLTMnXSxcbiAgICAgICAgdGl0bGU6ICdTbWFsbCBIZWFkaW5nJyxcbiAgICB9LFxuICAgICdzZXBhcmF0b3ItMSc6IHtcbiAgICAgICAgbmFtZTogJ3NlcGFyYXRvci0xJyxcbiAgICB9LFxuICAgICdjb2RlJzoge1xuICAgICAgICBuYW1lOiAnY29kZScsXG4gICAgICAgIGFjdGlvbjogdG9nZ2xlQ29kZUJsb2NrLFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsnY29kZSddLFxuICAgICAgICB0aXRsZTogJ0NvZGUnLFxuICAgIH0sXG4gICAgJ3F1b3RlJzoge1xuICAgICAgICBuYW1lOiAncXVvdGUnLFxuICAgICAgICBhY3Rpb246IHRvZ2dsZUJsb2NrcXVvdGUsXG4gICAgICAgIGNsYXNzTmFtZTogaWNvbkNsYXNzTWFwWydxdW90ZSddLFxuICAgICAgICB0aXRsZTogJ1F1b3RlJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB9LFxuICAgICd1bm9yZGVyZWQtbGlzdCc6IHtcbiAgICAgICAgbmFtZTogJ3Vub3JkZXJlZC1saXN0JyxcbiAgICAgICAgYWN0aW9uOiB0b2dnbGVVbm9yZGVyZWRMaXN0LFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsndW5vcmRlcmVkLWxpc3QnXSxcbiAgICAgICAgdGl0bGU6ICdHZW5lcmljIExpc3QnLFxuICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgIH0sXG4gICAgJ29yZGVyZWQtbGlzdCc6IHtcbiAgICAgICAgbmFtZTogJ29yZGVyZWQtbGlzdCcsXG4gICAgICAgIGFjdGlvbjogdG9nZ2xlT3JkZXJlZExpc3QsXG4gICAgICAgIGNsYXNzTmFtZTogaWNvbkNsYXNzTWFwWydvcmRlcmVkLWxpc3QnXSxcbiAgICAgICAgdGl0bGU6ICdOdW1iZXJlZCBMaXN0JyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB9LFxuICAgICdjbGVhbi1ibG9jayc6IHtcbiAgICAgICAgbmFtZTogJ2NsZWFuLWJsb2NrJyxcbiAgICAgICAgYWN0aW9uOiBjbGVhbkJsb2NrLFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsnY2xlYW4tYmxvY2snXSxcbiAgICAgICAgdGl0bGU6ICdDbGVhbiBibG9jaycsXG4gICAgfSxcbiAgICAnc2VwYXJhdG9yLTInOiB7XG4gICAgICAgIG5hbWU6ICdzZXBhcmF0b3ItMicsXG4gICAgfSxcbiAgICAnbGluayc6IHtcbiAgICAgICAgbmFtZTogJ2xpbmsnLFxuICAgICAgICBhY3Rpb246IGRyYXdMaW5rLFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsnbGluayddLFxuICAgICAgICB0aXRsZTogJ0NyZWF0ZSBMaW5rJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB9LFxuICAgICdpbWFnZSc6IHtcbiAgICAgICAgbmFtZTogJ2ltYWdlJyxcbiAgICAgICAgYWN0aW9uOiBkcmF3SW1hZ2UsXG4gICAgICAgIGNsYXNzTmFtZTogaWNvbkNsYXNzTWFwWydpbWFnZSddLFxuICAgICAgICB0aXRsZTogJ0luc2VydCBJbWFnZScsXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgfSxcbiAgICAndXBsb2FkLWltYWdlJzoge1xuICAgICAgICBuYW1lOiAndXBsb2FkLWltYWdlJyxcbiAgICAgICAgYWN0aW9uOiBkcmF3VXBsb2FkZWRJbWFnZSxcbiAgICAgICAgY2xhc3NOYW1lOiBpY29uQ2xhc3NNYXBbJ3VwbG9hZC1pbWFnZSddLFxuICAgICAgICB0aXRsZTogJ0ltcG9ydCBhbiBpbWFnZScsXG4gICAgfSxcbiAgICAndGFibGUnOiB7XG4gICAgICAgIG5hbWU6ICd0YWJsZScsXG4gICAgICAgIGFjdGlvbjogZHJhd1RhYmxlLFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsndGFibGUnXSxcbiAgICAgICAgdGl0bGU6ICdJbnNlcnQgVGFibGUnLFxuICAgIH0sXG4gICAgJ2hvcml6b250YWwtcnVsZSc6IHtcbiAgICAgICAgbmFtZTogJ2hvcml6b250YWwtcnVsZScsXG4gICAgICAgIGFjdGlvbjogZHJhd0hvcml6b250YWxSdWxlLFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsnaG9yaXpvbnRhbC1ydWxlJ10sXG4gICAgICAgIHRpdGxlOiAnSW5zZXJ0IEhvcml6b250YWwgTGluZScsXG4gICAgfSxcbiAgICAnc2VwYXJhdG9yLTMnOiB7XG4gICAgICAgIG5hbWU6ICdzZXBhcmF0b3ItMycsXG4gICAgfSxcbiAgICAncHJldmlldyc6IHtcbiAgICAgICAgbmFtZTogJ3ByZXZpZXcnLFxuICAgICAgICBhY3Rpb246IHRvZ2dsZVByZXZpZXcsXG4gICAgICAgIGNsYXNzTmFtZTogaWNvbkNsYXNzTWFwWydwcmV2aWV3J10sXG4gICAgICAgIG5vRGlzYWJsZTogdHJ1ZSxcbiAgICAgICAgdGl0bGU6ICdUb2dnbGUgUHJldmlldycsXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgfSxcbiAgICAnc2lkZS1ieS1zaWRlJzoge1xuICAgICAgICBuYW1lOiAnc2lkZS1ieS1zaWRlJyxcbiAgICAgICAgYWN0aW9uOiB0b2dnbGVTaWRlQnlTaWRlLFxuICAgICAgICBjbGFzc05hbWU6IGljb25DbGFzc01hcFsnc2lkZS1ieS1zaWRlJ10sXG4gICAgICAgIG5vRGlzYWJsZTogdHJ1ZSxcbiAgICAgICAgbm9Nb2JpbGU6IHRydWUsXG4gICAgICAgIHRpdGxlOiAnVG9nZ2xlIFNpZGUgYnkgU2lkZScsXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgfSxcbiAgICAnZnVsbHNjcmVlbic6IHtcbiAgICAgICAgbmFtZTogJ2Z1bGxzY3JlZW4nLFxuICAgICAgICBhY3Rpb246IHRvZ2dsZUZ1bGxTY3JlZW4sXG4gICAgICAgIGNsYXNzTmFtZTogaWNvbkNsYXNzTWFwWydmdWxsc2NyZWVuJ10sXG4gICAgICAgIG5vRGlzYWJsZTogdHJ1ZSxcbiAgICAgICAgbm9Nb2JpbGU6IHRydWUsXG4gICAgICAgIHRpdGxlOiAnVG9nZ2xlIEZ1bGxzY3JlZW4nLFxuICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgIH0sXG4gICAgJ3NlcGFyYXRvci00Jzoge1xuICAgICAgICBuYW1lOiAnc2VwYXJhdG9yLTQnLFxuICAgIH0sXG4gICAgJ2d1aWRlJzoge1xuICAgICAgICBuYW1lOiAnZ3VpZGUnLFxuICAgICAgICBhY3Rpb246ICdodHRwczovL3d3dy5tYXJrZG93bmd1aWRlLm9yZy9iYXNpYy1zeW50YXgvJyxcbiAgICAgICAgY2xhc3NOYW1lOiBpY29uQ2xhc3NNYXBbJ2d1aWRlJ10sXG4gICAgICAgIG5vRGlzYWJsZTogdHJ1ZSxcbiAgICAgICAgdGl0bGU6ICdNYXJrZG93biBHdWlkZScsXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgfSxcbiAgICAnc2VwYXJhdG9yLTUnOiB7XG4gICAgICAgIG5hbWU6ICdzZXBhcmF0b3ItNScsXG4gICAgfSxcbiAgICAndW5kbyc6IHtcbiAgICAgICAgbmFtZTogJ3VuZG8nLFxuICAgICAgICBhY3Rpb246IHVuZG8sXG4gICAgICAgIGNsYXNzTmFtZTogaWNvbkNsYXNzTWFwWyd1bmRvJ10sXG4gICAgICAgIG5vRGlzYWJsZTogdHJ1ZSxcbiAgICAgICAgdGl0bGU6ICdVbmRvJyxcbiAgICB9LFxuICAgICdyZWRvJzoge1xuICAgICAgICBuYW1lOiAncmVkbycsXG4gICAgICAgIGFjdGlvbjogcmVkbyxcbiAgICAgICAgY2xhc3NOYW1lOiBpY29uQ2xhc3NNYXBbJ3JlZG8nXSxcbiAgICAgICAgbm9EaXNhYmxlOiB0cnVlLFxuICAgICAgICB0aXRsZTogJ1JlZG8nLFxuICAgIH0sXG59O1xuXG52YXIgaW5zZXJ0VGV4dHMgPSB7XG4gICAgbGluazogWydbJywgJ10oI3VybCMpJ10sXG4gICAgaW1hZ2U6IFsnIVsnLCAnXSgjdXJsIyknXSxcbiAgICB1cGxvYWRlZEltYWdlOiBbJyFbXSgjdXJsIyknLCAnJ10sXG4gICAgLy8gdXBsb2FkZWRJbWFnZTogWychW10oI3VybCMpXFxuJywgJyddLCAvLyBUT0RPOiBOZXcgbGluZSBpbnNlcnRpb24gZG9lc24ndCB3b3JrIGhlcmUuXG4gICAgdGFibGU6IFsnJywgJ1xcblxcbnwgQ29sdW1uIDEgfCBDb2x1bW4gMiB8IENvbHVtbiAzIHxcXG58IC0tLS0tLS0tIHwgLS0tLS0tLS0gfCAtLS0tLS0tLSB8XFxufCBUZXh0ICAgICB8IFRleHQgICAgIHwgVGV4dCAgICAgfFxcblxcbiddLFxuICAgIGhvcml6b250YWxSdWxlOiBbJycsICdcXG5cXG4tLS0tLVxcblxcbiddLFxufTtcblxudmFyIHByb21wdFRleHRzID0ge1xuICAgIGxpbms6ICdVUkwgZm9yIHRoZSBsaW5rOicsXG4gICAgaW1hZ2U6ICdVUkwgb2YgdGhlIGltYWdlOicsXG59O1xuXG52YXIgdGltZUZvcm1hdCA9IHtcbiAgICBsb2NhbGU6ICdlbi1VUycsXG4gICAgZm9ybWF0OiB7XG4gICAgICAgIGhvdXI6ICcyLWRpZ2l0JyxcbiAgICAgICAgbWludXRlOiAnMi1kaWdpdCcsXG4gICAgfSxcbn07XG5cbnZhciBibG9ja1N0eWxlcyA9IHtcbiAgICAnYm9sZCc6ICcqKicsXG4gICAgJ2NvZGUnOiAnYGBgJyxcbiAgICAnaXRhbGljJzogJyonLFxufTtcblxuLyoqXG4gKiBUZXh0cyBkaXNwbGF5ZWQgdG8gdGhlIHVzZXIgKG1haW5seSBvbiB0aGUgc3RhdHVzIGJhcikgZm9yIHRoZSBpbXBvcnQgaW1hZ2VcbiAqIGZlYXR1cmUuIENhbiBiZSB1c2VkIGZvciBjdXN0b21pemF0aW9uIG9yIGludGVybmF0aW9uYWxpemF0aW9uLlxuICovXG52YXIgaW1hZ2VUZXh0cyA9IHtcbiAgICBzYkluaXQ6ICdBdHRhY2ggZmlsZXMgYnkgZHJhZyBhbmQgZHJvcHBpbmcgb3IgcGFzdGluZyBmcm9tIGNsaXBib2FyZC4nLFxuICAgIHNiT25EcmFnRW50ZXI6ICdEcm9wIGltYWdlIHRvIHVwbG9hZCBpdC4nLFxuICAgIHNiT25Ecm9wOiAnVXBsb2FkaW5nIGltYWdlICNpbWFnZXNfbmFtZXMjLi4uJyxcbiAgICBzYlByb2dyZXNzOiAnVXBsb2FkaW5nICNmaWxlX25hbWUjOiAjcHJvZ3Jlc3MjJScsXG4gICAgc2JPblVwbG9hZGVkOiAnVXBsb2FkZWQgI2ltYWdlX25hbWUjJyxcbiAgICBzaXplVW5pdHM6ICcgQiwgS0IsIE1CJyxcbn07XG5cbi8qKlxuICogRXJyb3JzIGRpc3BsYXllZCB0byB0aGUgdXNlciwgdXNpbmcgdGhlIGBlcnJvckNhbGxiYWNrYCBvcHRpb24uIENhbiBiZSB1c2VkIGZvclxuICogY3VzdG9taXphdGlvbiBvciBpbnRlcm5hdGlvbmFsaXphdGlvbi5cbiAqL1xudmFyIGVycm9yTWVzc2FnZXMgPSB7XG4gICAgbm9GaWxlR2l2ZW46ICdZb3UgbXVzdCBzZWxlY3QgYSBmaWxlLicsXG4gICAgdHlwZU5vdEFsbG93ZWQ6ICdUaGlzIGltYWdlIHR5cGUgaXMgbm90IGFsbG93ZWQuJyxcbiAgICBmaWxlVG9vTGFyZ2U6ICdJbWFnZSAjaW1hZ2VfbmFtZSMgaXMgdG9vIGJpZyAoI2ltYWdlX3NpemUjKS5cXG4nICtcbiAgICAgICAgJ01heGltdW0gZmlsZSBzaXplIGlzICNpbWFnZV9tYXhfc2l6ZSMuJyxcbiAgICBpbXBvcnRFcnJvcjogJ1NvbWV0aGluZyB3ZW50IHdyb25nIHdoZW4gdXBsb2FkaW5nIHRoZSBpbWFnZSAjaW1hZ2VfbmFtZSMuJyxcbn07XG5cbi8qKlxuICogSW50ZXJmYWNlIG9mIEVhc3lNREUuXG4gKi9cbmZ1bmN0aW9uIEVhc3lNREUob3B0aW9ucykge1xuICAgIC8vIEhhbmRsZSBvcHRpb25zIHBhcmFtZXRlclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gVXNlZCBsYXRlciB0byByZWZlciB0byBpdFwicyBwYXJlbnRcbiAgICBvcHRpb25zLnBhcmVudCA9IHRoaXM7XG5cbiAgICAvLyBDaGVjayBpZiBGb250IEF3ZXNvbWUgbmVlZHMgdG8gYmUgYXV0byBkb3dubG9hZGVkXG4gICAgdmFyIGF1dG9Eb3dubG9hZEZBID0gdHJ1ZTtcblxuICAgIGlmIChvcHRpb25zLmF1dG9Eb3dubG9hZEZvbnRBd2Vzb21lID09PSBmYWxzZSkge1xuICAgICAgICBhdXRvRG93bmxvYWRGQSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmF1dG9Eb3dubG9hZEZvbnRBd2Vzb21lICE9PSB0cnVlKSB7XG4gICAgICAgIHZhciBzdHlsZVNoZWV0cyA9IGRvY3VtZW50LnN0eWxlU2hlZXRzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlU2hlZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXN0eWxlU2hlZXRzW2ldLmhyZWYpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIGlmIChzdHlsZVNoZWV0c1tpXS5ocmVmLmluZGV4T2YoJy8vbWF4Y2RuLmJvb3RzdHJhcGNkbi5jb20vZm9udC1hd2Vzb21lLycpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBhdXRvRG93bmxvYWRGQSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGF1dG9Eb3dubG9hZEZBKSB7XG4gICAgICAgIHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuICAgICAgICBsaW5rLnJlbCA9ICdzdHlsZXNoZWV0JztcbiAgICAgICAgbGluay5ocmVmID0gJ2h0dHBzOi8vbWF4Y2RuLmJvb3RzdHJhcGNkbi5jb20vZm9udC1hd2Vzb21lL2xhdGVzdC9jc3MvZm9udC1hd2Vzb21lLm1pbi5jc3MnO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKGxpbmspO1xuICAgIH1cblxuXG4gICAgLy8gRmluZCB0aGUgdGV4dGFyZWEgdG8gdXNlXG4gICAgaWYgKG9wdGlvbnMuZWxlbWVudCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQ7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyBtZWFucyB0aGF0IHRoZSBlbGVtZW50IG9wdGlvbiB3YXMgc3BlY2lmaWVkLCBidXQgbm8gZWxlbWVudCB3YXMgZm91bmRcbiAgICAgICAgY29uc29sZS5sb2coJ0Vhc3lNREU6IEVycm9yLiBObyBlbGVtZW50IHdhcyBmb3VuZC4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuXG4gICAgLy8gSGFuZGxlIHRvb2xiYXJcbiAgICBpZiAob3B0aW9ucy50b29sYmFyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZVxuICAgICAgICBvcHRpb25zLnRvb2xiYXIgPSBbXTtcblxuXG4gICAgICAgIC8vIExvb3Agb3ZlciB0aGUgYnVpbHQgaW4gYnV0dG9ucywgdG8gZ2V0IHRoZSBwcmVmZXJyZWQgb3JkZXJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRvb2xiYXJCdWlsdEluQnV0dG9ucykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0b29sYmFyQnVpbHRJbkJ1dHRvbnMsIGtleSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5LmluZGV4T2YoJ3NlcGFyYXRvci0nKSAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnRvb2xiYXIucHVzaCgnfCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0b29sYmFyQnVpbHRJbkJ1dHRvbnNba2V5XS5kZWZhdWx0ID09PSB0cnVlIHx8IChvcHRpb25zLnNob3dJY29ucyAmJiBvcHRpb25zLnNob3dJY29ucy5jb25zdHJ1Y3RvciA9PT0gQXJyYXkgJiYgb3B0aW9ucy5zaG93SWNvbnMuaW5kZXhPZihrZXkpICE9IC0xKSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnRvb2xiYXIucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEVkaXRvciBwcmV2aWV3IHN0eWxpbmcgY2xhc3MuXG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3ByZXZpZXdDbGFzcycpKSB7XG4gICAgICAgIG9wdGlvbnMucHJldmlld0NsYXNzID0gJ2VkaXRvci1wcmV2aWV3JztcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgc3RhdHVzIGJhclxuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICdzdGF0dXMnKSkge1xuICAgICAgICBvcHRpb25zLnN0YXR1cyA9IFsnYXV0b3NhdmUnLCAnbGluZXMnLCAnd29yZHMnLCAnY3Vyc29yJ107XG5cbiAgICAgICAgaWYgKG9wdGlvbnMudXBsb2FkSW1hZ2UpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc3RhdHVzLnVuc2hpZnQoJ3VwbG9hZC1pbWFnZScpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyBBZGQgZGVmYXVsdCBwcmV2aWV3IHJlbmRlcmluZyBmdW5jdGlvblxuICAgIGlmICghb3B0aW9ucy5wcmV2aWV3UmVuZGVyKSB7XG4gICAgICAgIG9wdGlvbnMucHJldmlld1JlbmRlciA9IGZ1bmN0aW9uIChwbGFpblRleHQpIHtcbiAgICAgICAgICAgIC8vIE5vdGU6IFwidGhpc1wiIHJlZmVycyB0byB0aGUgb3B0aW9ucyBvYmplY3RcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5tYXJrZG93bihwbGFpblRleHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuXG4gICAgLy8gU2V0IGRlZmF1bHQgb3B0aW9ucyBmb3IgcGFyc2luZyBjb25maWdcbiAgICBvcHRpb25zLnBhcnNpbmdDb25maWcgPSBleHRlbmQoe1xuICAgICAgICBoaWdobGlnaHRGb3JtYXR0aW5nOiB0cnVlLCAvLyBuZWVkZWQgZm9yIHRvZ2dsZUNvZGVCbG9jayB0byBkZXRlY3QgdHlwZXMgb2YgY29kZVxuICAgIH0sIG9wdGlvbnMucGFyc2luZ0NvbmZpZyB8fCB7fSk7XG5cblxuICAgIC8vIE1lcmdpbmcgdGhlIGluc2VydFRleHRzLCB3aXRoIHRoZSBnaXZlbiBvcHRpb25zXG4gICAgb3B0aW9ucy5pbnNlcnRUZXh0cyA9IGV4dGVuZCh7fSwgaW5zZXJ0VGV4dHMsIG9wdGlvbnMuaW5zZXJ0VGV4dHMgfHwge30pO1xuXG5cbiAgICAvLyBNZXJnaW5nIHRoZSBwcm9tcHRUZXh0cywgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9uc1xuICAgIG9wdGlvbnMucHJvbXB0VGV4dHMgPSBleHRlbmQoe30sIHByb21wdFRleHRzLCBvcHRpb25zLnByb21wdFRleHRzIHx8IHt9KTtcblxuXG4gICAgLy8gTWVyZ2luZyB0aGUgYmxvY2tTdHlsZXMsIHdpdGggdGhlIGdpdmVuIG9wdGlvbnNcbiAgICBvcHRpb25zLmJsb2NrU3R5bGVzID0gZXh0ZW5kKHt9LCBibG9ja1N0eWxlcywgb3B0aW9ucy5ibG9ja1N0eWxlcyB8fCB7fSk7XG5cblxuICAgIGlmIChvcHRpb25zLmF1dG9zYXZlICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBNZXJnaW5nIHRoZSBBdXRvc2F2ZSB0aW1lRm9ybWF0LCB3aXRoIHRoZSBnaXZlbiBvcHRpb25zXG4gICAgICAgIG9wdGlvbnMuYXV0b3NhdmUudGltZUZvcm1hdCA9IGV4dGVuZCh7fSwgdGltZUZvcm1hdCwgb3B0aW9ucy5hdXRvc2F2ZS50aW1lRm9ybWF0IHx8IHt9KTtcbiAgICB9XG5cbiAgICBvcHRpb25zLmljb25DbGFzc01hcCA9IGV4dGVuZCh7fSwgaWNvbkNsYXNzTWFwLCBvcHRpb25zLmljb25DbGFzc01hcCB8fCB7fSk7XG5cbiAgICAvLyBNZXJnaW5nIHRoZSBzaG9ydGN1dHMsIHdpdGggdGhlIGdpdmVuIG9wdGlvbnNcbiAgICBvcHRpb25zLnNob3J0Y3V0cyA9IGV4dGVuZCh7fSwgc2hvcnRjdXRzLCBvcHRpb25zLnNob3J0Y3V0cyB8fCB7fSk7XG5cbiAgICBvcHRpb25zLm1heEhlaWdodCA9IG9wdGlvbnMubWF4SGVpZ2h0IHx8IHVuZGVmaW5lZDtcblxuICAgIG9wdGlvbnMuZGlyZWN0aW9uID0gb3B0aW9ucy5kaXJlY3Rpb24gfHwgJ2x0cic7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMubWF4SGVpZ2h0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBNaW4gYW5kIG1heCBoZWlnaHQgYXJlIGVxdWFsIGlmIG1heEhlaWdodCBpcyBzZXRcbiAgICAgICAgb3B0aW9ucy5taW5IZWlnaHQgPSBvcHRpb25zLm1heEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLm1pbkhlaWdodCA9IG9wdGlvbnMubWluSGVpZ2h0IHx8ICczMDBweCc7XG4gICAgfVxuXG4gICAgb3B0aW9ucy5lcnJvckNhbGxiYWNrID0gb3B0aW9ucy5lcnJvckNhbGxiYWNrIHx8IGZ1bmN0aW9uIChlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgYWxlcnQoZXJyb3JNZXNzYWdlKTtcbiAgICB9O1xuXG4gICAgLy8gSW1wb3J0LWltYWdlIGRlZmF1bHQgY29uZmlndXJhdGlvblxuICAgIG9wdGlvbnMudXBsb2FkSW1hZ2UgPSBvcHRpb25zLnVwbG9hZEltYWdlIHx8IGZhbHNlO1xuICAgIG9wdGlvbnMuaW1hZ2VNYXhTaXplID0gb3B0aW9ucy5pbWFnZU1heFNpemUgfHwgMjA5NzE1MjsgLy8gMTAyNCAqIDEwMjQgKiAyXG4gICAgb3B0aW9ucy5pbWFnZUFjY2VwdCA9IG9wdGlvbnMuaW1hZ2VBY2NlcHQgfHwgJ2ltYWdlL3BuZywgaW1hZ2UvanBlZywgaW1hZ2UvZ2lmLCBpbWFnZS9hdmlmJztcbiAgICBvcHRpb25zLmltYWdlVGV4dHMgPSBleHRlbmQoe30sIGltYWdlVGV4dHMsIG9wdGlvbnMuaW1hZ2VUZXh0cyB8fCB7fSk7XG4gICAgb3B0aW9ucy5lcnJvck1lc3NhZ2VzID0gZXh0ZW5kKHt9LCBlcnJvck1lc3NhZ2VzLCBvcHRpb25zLmVycm9yTWVzc2FnZXMgfHwge30pO1xuICAgIG9wdGlvbnMuaW1hZ2VQYXRoQWJzb2x1dGUgPSBvcHRpb25zLmltYWdlUGF0aEFic29sdXRlIHx8IGZhbHNlO1xuICAgIG9wdGlvbnMuaW1hZ2VDU1JGTmFtZSA9IG9wdGlvbnMuaW1hZ2VDU1JGTmFtZSB8fCAnY3NyZm1pZGRsZXdhcmV0b2tlbic7XG4gICAgb3B0aW9ucy5pbWFnZUNTUkZIZWFkZXIgPSBvcHRpb25zLmltYWdlQ1NSRkhlYWRlciB8fCBmYWxzZTtcblxuXG4gICAgLy8gQ2hhbmdlIHVuaXF1ZV9pZCB0byB1bmlxdWVJZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICBpZiAob3B0aW9ucy5hdXRvc2F2ZSAhPSB1bmRlZmluZWQgJiYgb3B0aW9ucy5hdXRvc2F2ZS51bmlxdWVfaWQgIT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuYXV0b3NhdmUudW5pcXVlX2lkICE9ICcnKVxuICAgICAgICBvcHRpb25zLmF1dG9zYXZlLnVuaXF1ZUlkID0gb3B0aW9ucy5hdXRvc2F2ZS51bmlxdWVfaWQ7XG5cbiAgICAvLyBJZiBvdmVybGF5IG1vZGUgaXMgc3BlY2lmaWVkIGFuZCBjb21iaW5lIGlzIG5vdCBwcm92aWRlZCwgZGVmYXVsdCBpdCB0byB0cnVlXG4gICAgaWYgKG9wdGlvbnMub3ZlcmxheU1vZGUgJiYgb3B0aW9ucy5vdmVybGF5TW9kZS5jb21iaW5lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5vdmVybGF5TW9kZS5jb21iaW5lID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhpcyBvcHRpb25zXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuXG4gICAgLy8gQXV0byByZW5kZXJcbiAgICB0aGlzLnJlbmRlcigpO1xuXG5cbiAgICAvLyBUaGUgY29kZW1pcnJvciBjb21wb25lbnQgaXMgb25seSBhdmFpbGFibGUgYWZ0ZXIgcmVuZGVyaW5nXG4gICAgLy8gc28sIHRoZSBzZXR0ZXIgZm9yIHRoZSBpbml0aWFsVmFsdWUgY2FuIG9ubHkgcnVuIGFmdGVyXG4gICAgLy8gdGhlIGVsZW1lbnQgaGFzIGJlZW4gcmVuZGVyZWRcbiAgICBpZiAob3B0aW9ucy5pbml0aWFsVmFsdWUgJiYgKCF0aGlzLm9wdGlvbnMuYXV0b3NhdmUgfHwgdGhpcy5vcHRpb25zLmF1dG9zYXZlLmZvdW5kU2F2ZWRWYWx1ZSAhPT0gdHJ1ZSkpIHtcbiAgICAgICAgdGhpcy52YWx1ZShvcHRpb25zLmluaXRpYWxWYWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMudXBsb2FkSW1hZ2UpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuY29kZW1pcnJvci5vbignZHJhZ2VudGVyJywgZnVuY3Rpb24gKGNtLCBldmVudCkge1xuICAgICAgICAgICAgc2VsZi51cGRhdGVTdGF0dXNCYXIoJ3VwbG9hZC1pbWFnZScsIHNlbGYub3B0aW9ucy5pbWFnZVRleHRzLnNiT25EcmFnRW50ZXIpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb2RlbWlycm9yLm9uKCdkcmFnZW5kJywgZnVuY3Rpb24gKGNtLCBldmVudCkge1xuICAgICAgICAgICAgc2VsZi51cGRhdGVTdGF0dXNCYXIoJ3VwbG9hZC1pbWFnZScsIHNlbGYub3B0aW9ucy5pbWFnZVRleHRzLnNiSW5pdCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvZGVtaXJyb3Iub24oJ2RyYWdsZWF2ZScsIGZ1bmN0aW9uIChjbSwgZXZlbnQpIHtcbiAgICAgICAgICAgIHNlbGYudXBkYXRlU3RhdHVzQmFyKCd1cGxvYWQtaW1hZ2UnLCBzZWxmLm9wdGlvbnMuaW1hZ2VUZXh0cy5zYkluaXQpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmNvZGVtaXJyb3Iub24oJ2RyYWdvdmVyJywgZnVuY3Rpb24gKGNtLCBldmVudCkge1xuICAgICAgICAgICAgc2VsZi51cGRhdGVTdGF0dXNCYXIoJ3VwbG9hZC1pbWFnZScsIHNlbGYub3B0aW9ucy5pbWFnZVRleHRzLnNiT25EcmFnRW50ZXIpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmNvZGVtaXJyb3Iub24oJ2Ryb3AnLCBmdW5jdGlvbiAoY20sIGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pbWFnZVVwbG9hZEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgc2VsZi51cGxvYWRJbWFnZXNVc2luZ0N1c3RvbUZ1bmN0aW9uKG9wdGlvbnMuaW1hZ2VVcGxvYWRGdW5jdGlvbiwgZXZlbnQuZGF0YVRyYW5zZmVyLmZpbGVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi51cGxvYWRJbWFnZXMoZXZlbnQuZGF0YVRyYW5zZmVyLmZpbGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5jb2RlbWlycm9yLm9uKCdwYXN0ZScsIGZ1bmN0aW9uIChjbSwgZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmltYWdlVXBsb2FkRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBzZWxmLnVwbG9hZEltYWdlc1VzaW5nQ3VzdG9tRnVuY3Rpb24ob3B0aW9ucy5pbWFnZVVwbG9hZEZ1bmN0aW9uLCBldmVudC5jbGlwYm9hcmREYXRhLmZpbGVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi51cGxvYWRJbWFnZXMoZXZlbnQuY2xpcGJvYXJkRGF0YS5maWxlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBVcGxvYWQgYXN5bmNocm9ub3VzbHkgYSBsaXN0IG9mIGltYWdlcyB0byBhIHNlcnZlci5cbiAqXG4gKiBDYW4gYmUgdHJpZ2dlcmVkIGJ5OlxuICogLSBkcmFnJmRyb3A7XG4gKiAtIGNvcHktcGFzdGU7XG4gKiAtIHRoZSBicm93c2UtZmlsZSB3aW5kb3cgKG9wZW5lZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgKnVwbG9hZC1pbWFnZSogaWNvbikuXG4gKiBAcGFyYW0ge0ZpbGVMaXN0fSBmaWxlcyBUaGUgZmlsZXMgdG8gdXBsb2FkIHRoZSB0aGUgc2VydmVyLlxuICogQHBhcmFtIFtvblN1Y2Nlc3NdIHtmdW5jdGlvbn0gc2VlIEVhc3lNREUucHJvdG90eXBlLnVwbG9hZEltYWdlXG4gKiBAcGFyYW0gW29uRXJyb3JdIHtmdW5jdGlvbn0gc2VlIEVhc3lNREUucHJvdG90eXBlLnVwbG9hZEltYWdlXG4gKi9cbkVhc3lNREUucHJvdG90eXBlLnVwbG9hZEltYWdlcyA9IGZ1bmN0aW9uIChmaWxlcywgb25TdWNjZXNzLCBvbkVycm9yKSB7XG4gICAgaWYgKGZpbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmFtZXMucHVzaChmaWxlc1tpXS5uYW1lKTtcbiAgICAgICAgdGhpcy51cGxvYWRJbWFnZShmaWxlc1tpXSwgb25TdWNjZXNzLCBvbkVycm9yKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVTdGF0dXNCYXIoJ3VwbG9hZC1pbWFnZScsIHRoaXMub3B0aW9ucy5pbWFnZVRleHRzLnNiT25Ecm9wLnJlcGxhY2UoJyNpbWFnZXNfbmFtZXMjJywgbmFtZXMuam9pbignLCAnKSkpO1xufTtcblxuLyoqXG4gKiBVcGxvYWQgYXN5bmNocm9ub3VzbHkgYSBsaXN0IG9mIGltYWdlcyB0byBhIHNlcnZlci5cbiAqXG4gKiBDYW4gYmUgdHJpZ2dlcmVkIGJ5OlxuICogLSBkcmFnJmRyb3A7XG4gKiAtIGNvcHktcGFzdGU7XG4gKiAtIHRoZSBicm93c2UtZmlsZSB3aW5kb3cgKG9wZW5lZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgKnVwbG9hZC1pbWFnZSogaWNvbikuXG4gKiBAcGFyYW0gaW1hZ2VVcGxvYWRGdW5jdGlvbiB7RnVuY3Rpb259IFRoZSBjdXN0b20gZnVuY3Rpb24gdG8gdXBsb2FkIHRoZSBpbWFnZSBwYXNzZWQgaW4gb3B0aW9ucy5cbiAqIEBwYXJhbSB7RmlsZUxpc3R9IGZpbGVzIFRoZSBmaWxlcyB0byB1cGxvYWQgdGhlIHRoZSBzZXJ2ZXIuXG4gKi9cbkVhc3lNREUucHJvdG90eXBlLnVwbG9hZEltYWdlc1VzaW5nQ3VzdG9tRnVuY3Rpb24gPSBmdW5jdGlvbiAoaW1hZ2VVcGxvYWRGdW5jdGlvbiwgZmlsZXMpIHtcbiAgICBpZiAoZmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5hbWVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBuYW1lcy5wdXNoKGZpbGVzW2ldLm5hbWUpO1xuICAgICAgICB0aGlzLnVwbG9hZEltYWdlVXNpbmdDdXN0b21GdW5jdGlvbihpbWFnZVVwbG9hZEZ1bmN0aW9uLCBmaWxlc1tpXSk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlU3RhdHVzQmFyKCd1cGxvYWQtaW1hZ2UnLCB0aGlzLm9wdGlvbnMuaW1hZ2VUZXh0cy5zYk9uRHJvcC5yZXBsYWNlKCcjaW1hZ2VzX25hbWVzIycsIG5hbWVzLmpvaW4oJywgJykpKTtcbn07XG5cbi8qKlxuICogVXBkYXRlIGFuIGl0ZW0gaW4gdGhlIHN0YXR1cyBiYXIuXG4gKiBAcGFyYW0gaXRlbU5hbWUge3N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIGl0ZW0gdG8gdXBkYXRlIChpZS4gJ3VwbG9hZC1pbWFnZScsICdhdXRvc2F2ZScsIGV0Yy4pLlxuICogQHBhcmFtIGNvbnRlbnQge3N0cmluZ30gdGhlIG5ldyBjb250ZW50IG9mIHRoZSBpdGVtIHRvIHdyaXRlIGluIHRoZSBzdGF0dXMgYmFyLlxuICovXG5FYXN5TURFLnByb3RvdHlwZS51cGRhdGVTdGF0dXNCYXIgPSBmdW5jdGlvbiAoaXRlbU5hbWUsIGNvbnRlbnQpIHtcbiAgICBpZiAoIXRoaXMuZ3VpLnN0YXR1c2Jhcikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoaW5nQ2xhc3NlcyA9IHRoaXMuZ3VpLnN0YXR1c2Jhci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGl0ZW1OYW1lKTtcbiAgICBpZiAobWF0Y2hpbmdDbGFzc2VzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0aGlzLmd1aS5zdGF0dXNiYXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShpdGVtTmFtZSlbMF0udGV4dENvbnRlbnQgPSBjb250ZW50O1xuICAgIH0gZWxzZSBpZiAobWF0Y2hpbmdDbGFzc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLmxvZygnRWFzeU1ERTogc3RhdHVzIGJhciBpdGVtICcgKyBpdGVtTmFtZSArICcgd2FzIG5vdCBmb3VuZC4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygnRWFzeU1ERTogU2V2ZXJhbCBzdGF0dXMgYmFyIGl0ZW1zIG5hbWVkICcgKyBpdGVtTmFtZSArICcgd2FzIGZvdW5kLicpO1xuICAgIH1cbn07XG5cbi8qKlxuICogRGVmYXVsdCBtYXJrZG93biByZW5kZXIuXG4gKi9cbkVhc3lNREUucHJvdG90eXBlLm1hcmtkb3duID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICBpZiAobWFya2VkKSB7XG4gICAgICAgIC8vIEluaXRpYWxpemVcbiAgICAgICAgdmFyIG1hcmtlZE9wdGlvbnM7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnJlbmRlcmluZ0NvbmZpZyAmJiB0aGlzLm9wdGlvbnMucmVuZGVyaW5nQ29uZmlnLm1hcmtlZE9wdGlvbnMpIHtcbiAgICAgICAgICAgIG1hcmtlZE9wdGlvbnMgPSB0aGlzLm9wdGlvbnMucmVuZGVyaW5nQ29uZmlnLm1hcmtlZE9wdGlvbnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXJrZWRPcHRpb25zID0ge307XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgb3B0aW9uc1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5yZW5kZXJpbmdDb25maWcgJiYgdGhpcy5vcHRpb25zLnJlbmRlcmluZ0NvbmZpZy5zaW5nbGVMaW5lQnJlYWtzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgbWFya2VkT3B0aW9ucy5icmVha3MgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hcmtlZE9wdGlvbnMuYnJlYWtzID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnJlbmRlcmluZ0NvbmZpZyAmJiB0aGlzLm9wdGlvbnMucmVuZGVyaW5nQ29uZmlnLmNvZGVTeW50YXhIaWdobGlnaHRpbmcgPT09IHRydWUpIHtcblxuICAgICAgICAgICAgLyogR2V0IEhMSlMgZnJvbSBjb25maWcgb3Igd2luZG93ICovXG4gICAgICAgICAgICB2YXIgaGxqcyA9IHRoaXMub3B0aW9ucy5yZW5kZXJpbmdDb25maWcuaGxqcyB8fCB3aW5kb3cuaGxqcztcblxuICAgICAgICAgICAgLyogQ2hlY2sgaWYgSExKUyBsb2FkZWQgKi9cbiAgICAgICAgICAgIGlmIChobGpzKSB7XG4gICAgICAgICAgICAgICAgbWFya2VkT3B0aW9ucy5oaWdobGlnaHQgPSBmdW5jdGlvbiAoY29kZSwgbGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhbmd1YWdlICYmIGhsanMuZ2V0TGFuZ3VhZ2UobGFuZ3VhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGxqcy5oaWdobGlnaHQobGFuZ3VhZ2UsIGNvZGUpLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhsanMuaGlnaGxpZ2h0QXV0byhjb2RlKS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgb3B0aW9uc1xuICAgICAgICBtYXJrZWQuc2V0T3B0aW9ucyhtYXJrZWRPcHRpb25zKTtcblxuICAgICAgICAvLyBDb252ZXJ0IHRoZSBtYXJrZG93biB0byBIVE1MXG4gICAgICAgIHZhciBodG1sVGV4dCA9IG1hcmtlZC5wYXJzZSh0ZXh0KTtcblxuICAgICAgICAvLyBTYW5pdGl6ZSBIVE1MXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVuZGVyaW5nQ29uZmlnICYmIHR5cGVvZiB0aGlzLm9wdGlvbnMucmVuZGVyaW5nQ29uZmlnLnNhbml0aXplckZ1bmN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBodG1sVGV4dCA9IHRoaXMub3B0aW9ucy5yZW5kZXJpbmdDb25maWcuc2FuaXRpemVyRnVuY3Rpb24uY2FsbCh0aGlzLCBodG1sVGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFZGl0IHRoZSBIVE1MIGFuY2hvcnMgdG8gYWRkICd0YXJnZXQ9XCJfYmxhbmtcIicgYnkgZGVmYXVsdC5cbiAgICAgICAgaHRtbFRleHQgPSBhZGRBbmNob3JUYXJnZXRCbGFuayhodG1sVGV4dCk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIGxpc3Qtc3R5bGUgd2hlbiByZW5kZXJpbmcgY2hlY2tib3hlc1xuICAgICAgICBodG1sVGV4dCA9IHJlbW92ZUxpc3RTdHlsZVdoZW5DaGVja2JveChodG1sVGV4dCk7XG5cbiAgICAgICAgcmV0dXJuIGh0bWxUZXh0O1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVuZGVyIGVkaXRvciB0byB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAqL1xuRWFzeU1ERS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKCFlbCkge1xuICAgICAgICBlbCA9IHRoaXMuZWxlbWVudCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndGV4dGFyZWEnKVswXTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVuZGVyZWQgJiYgdGhpcy5fcmVuZGVyZWQgPT09IGVsKSB7XG4gICAgICAgIC8vIEFscmVhZHkgcmVuZGVyZWQuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnQgPSBlbDtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIga2V5TWFwcyA9IHt9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMuc2hvcnRjdXRzKSB7XG4gICAgICAgIC8vIG51bGwgc3RhbmRzIGZvciBcImRvIG5vdCBiaW5kIHRoaXMgY29tbWFuZFwiXG4gICAgICAgIGlmIChvcHRpb25zLnNob3J0Y3V0c1trZXldICE9PSBudWxsICYmIGJpbmRpbmdzW2tleV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgIChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAga2V5TWFwc1tmaXhTaG9ydGN1dChvcHRpb25zLnNob3J0Y3V0c1trZXldKV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3Rpb24gPSBiaW5kaW5nc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uKHNlbGYpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cub3BlbihhY3Rpb24sICdfYmxhbmsnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KShrZXkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAga2V5TWFwc1snRW50ZXInXSA9ICduZXdsaW5lQW5kSW5kZW50Q29udGludWVNYXJrZG93bkxpc3QnO1xuICAgIGtleU1hcHNbJ1RhYiddID0gJ3RhYkFuZEluZGVudE1hcmtkb3duTGlzdCc7XG4gICAga2V5TWFwc1snU2hpZnQtVGFiJ10gPSAnc2hpZnRUYWJBbmRVbmluZGVudE1hcmtkb3duTGlzdCc7XG4gICAga2V5TWFwc1snRXNjJ10gPSBmdW5jdGlvbiAoY20pIHtcbiAgICAgICAgaWYgKGNtLmdldE9wdGlvbignZnVsbFNjcmVlbicpKSB0b2dnbGVGdWxsU2NyZWVuKHNlbGYpO1xuICAgIH07XG5cbiAgICB0aGlzLmRvY3VtZW50T25LZXlEb3duID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZSA9IGUgfHwgd2luZG93LmV2ZW50O1xuXG4gICAgICAgIGlmIChlLmtleUNvZGUgPT0gMjcpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvZGVtaXJyb3IuZ2V0T3B0aW9uKCdmdWxsU2NyZWVuJykpIHRvZ2dsZUZ1bGxTY3JlZW4oc2VsZik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmRvY3VtZW50T25LZXlEb3duLCBmYWxzZSk7XG5cbiAgICB2YXIgbW9kZSwgYmFja2Ryb3A7XG5cbiAgICAvLyBDb2RlTWlycm9yIG92ZXJsYXkgbW9kZVxuICAgIGlmIChvcHRpb25zLm92ZXJsYXlNb2RlKSB7XG4gICAgICAgIENvZGVNaXJyb3IuZGVmaW5lTW9kZSgnb3ZlcmxheS1tb2RlJywgZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuIENvZGVNaXJyb3Iub3ZlcmxheU1vZGUoQ29kZU1pcnJvci5nZXRNb2RlKGNvbmZpZywgb3B0aW9ucy5zcGVsbENoZWNrZXIgIT09IGZhbHNlID8gJ3NwZWxsLWNoZWNrZXInIDogJ2dmbScpLCBvcHRpb25zLm92ZXJsYXlNb2RlLm1vZGUsIG9wdGlvbnMub3ZlcmxheU1vZGUuY29tYmluZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1vZGUgPSAnb3ZlcmxheS1tb2RlJztcbiAgICAgICAgYmFja2Ryb3AgPSBvcHRpb25zLnBhcnNpbmdDb25maWc7XG4gICAgICAgIGJhY2tkcm9wLmdpdEh1YlNwaWNlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbW9kZSA9IG9wdGlvbnMucGFyc2luZ0NvbmZpZztcbiAgICAgICAgbW9kZS5uYW1lID0gJ2dmbSc7XG4gICAgICAgIG1vZGUuZ2l0SHViU3BpY2UgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc3BlbGxDaGVja2VyICE9PSBmYWxzZSkge1xuICAgICAgICBtb2RlID0gJ3NwZWxsLWNoZWNrZXInO1xuICAgICAgICBiYWNrZHJvcCA9IG9wdGlvbnMucGFyc2luZ0NvbmZpZztcbiAgICAgICAgYmFja2Ryb3AubmFtZSA9ICdnZm0nO1xuICAgICAgICBiYWNrZHJvcC5naXRIdWJTcGljZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5zcGVsbENoZWNrZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc3BlbGxDaGVja2VyKHtcbiAgICAgICAgICAgICAgICBjb2RlTWlycm9ySW5zdGFuY2U6IENvZGVNaXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIENvZGVNaXJyb3JTcGVsbENoZWNrZXIoe1xuICAgICAgICAgICAgICAgIGNvZGVNaXJyb3JJbnN0YW5jZTogQ29kZU1pcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgZnVuY3Rpb24gY29uZmlndXJlTW91c2UoY20sIHJlcGVhdCwgZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZE5ldzogZmFsc2UsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5jb2RlbWlycm9yID0gQ29kZU1pcnJvci5mcm9tVGV4dEFyZWEoZWwsIHtcbiAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgYmFja2Ryb3A6IGJhY2tkcm9wLFxuICAgICAgICB0aGVtZTogKG9wdGlvbnMudGhlbWUgIT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMudGhlbWUgOiAnZWFzeW1kZScsXG4gICAgICAgIHRhYlNpemU6IChvcHRpb25zLnRhYlNpemUgIT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMudGFiU2l6ZSA6IDIsXG4gICAgICAgIGluZGVudFVuaXQ6IChvcHRpb25zLnRhYlNpemUgIT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMudGFiU2l6ZSA6IDIsXG4gICAgICAgIGluZGVudFdpdGhUYWJzOiAob3B0aW9ucy5pbmRlbnRXaXRoVGFicyA9PT0gZmFsc2UpID8gZmFsc2UgOiB0cnVlLFxuICAgICAgICBsaW5lTnVtYmVyczogKG9wdGlvbnMubGluZU51bWJlcnMgPT09IHRydWUpID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgICBhdXRvZm9jdXM6IChvcHRpb25zLmF1dG9mb2N1cyA9PT0gdHJ1ZSkgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgIGV4dHJhS2V5czoga2V5TWFwcyxcbiAgICAgICAgZGlyZWN0aW9uOiBvcHRpb25zLmRpcmVjdGlvbixcbiAgICAgICAgbGluZVdyYXBwaW5nOiAob3B0aW9ucy5saW5lV3JhcHBpbmcgPT09IGZhbHNlKSA/IGZhbHNlIDogdHJ1ZSxcbiAgICAgICAgYWxsb3dEcm9wRmlsZVR5cGVzOiBbJ3RleHQvcGxhaW4nXSxcbiAgICAgICAgcGxhY2Vob2xkZXI6IG9wdGlvbnMucGxhY2Vob2xkZXIgfHwgZWwuZ2V0QXR0cmlidXRlKCdwbGFjZWhvbGRlcicpIHx8ICcnLFxuICAgICAgICBzdHlsZVNlbGVjdGVkVGV4dDogKG9wdGlvbnMuc3R5bGVTZWxlY3RlZFRleHQgIT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMuc3R5bGVTZWxlY3RlZFRleHQgOiAhaXNNb2JpbGUoKSxcbiAgICAgICAgc2Nyb2xsYmFyU3R5bGU6IChvcHRpb25zLnNjcm9sbGJhclN0eWxlICE9IHVuZGVmaW5lZCkgPyBvcHRpb25zLnNjcm9sbGJhclN0eWxlIDogJ25hdGl2ZScsXG4gICAgICAgIGNvbmZpZ3VyZU1vdXNlOiBjb25maWd1cmVNb3VzZSxcbiAgICAgICAgaW5wdXRTdHlsZTogKG9wdGlvbnMuaW5wdXRTdHlsZSAhPSB1bmRlZmluZWQpID8gb3B0aW9ucy5pbnB1dFN0eWxlIDogaXNNb2JpbGUoKSA/ICdjb250ZW50ZWRpdGFibGUnIDogJ3RleHRhcmVhJyxcbiAgICAgICAgc3BlbGxjaGVjazogKG9wdGlvbnMubmF0aXZlU3BlbGxjaGVjayAhPSB1bmRlZmluZWQpID8gb3B0aW9ucy5uYXRpdmVTcGVsbGNoZWNrIDogdHJ1ZSxcbiAgICAgICAgYXV0b1JlZnJlc2g6IChvcHRpb25zLmF1dG9SZWZyZXNoICE9IHVuZGVmaW5lZCkgPyBvcHRpb25zLmF1dG9SZWZyZXNoIDogZmFsc2UsXG4gICAgfSk7XG5cbiAgICB0aGlzLmNvZGVtaXJyb3IuZ2V0U2Nyb2xsZXJFbGVtZW50KCkuc3R5bGUubWluSGVpZ2h0ID0gb3B0aW9ucy5taW5IZWlnaHQ7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMubWF4SGVpZ2h0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLmNvZGVtaXJyb3IuZ2V0U2Nyb2xsZXJFbGVtZW50KCkuc3R5bGUuaGVpZ2h0ID0gb3B0aW9ucy5tYXhIZWlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuZm9yY2VTeW5jID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBjbSA9IHRoaXMuY29kZW1pcnJvcjtcbiAgICAgICAgY20ub24oJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNtLnNhdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5ndWkgPSB7fTtcblxuICAgIC8vIFdyYXAgQ29kZW1pcnJvciB3aXRoIGNvbnRhaW5lciBiZWZvcmUgY3JlYXRlIHRvb2xiYXIsIGV0YyxcbiAgICAvLyB0byB1c2Ugd2l0aCBzaWRlQnlTaWRlRnVsbHNjcmVlbiBvcHRpb24uXG4gICAgdmFyIGVhc3lNREVDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlYXN5TURFQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ0Vhc3lNREVDb250YWluZXInKTtcbiAgICBlYXN5TURFQ29udGFpbmVyLnNldEF0dHJpYnV0ZSgncm9sZScsICdhcHBsaWNhdGlvbicpO1xuICAgIHZhciBjbVdyYXBwZXIgPSB0aGlzLmNvZGVtaXJyb3IuZ2V0V3JhcHBlckVsZW1lbnQoKTtcbiAgICBjbVdyYXBwZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWFzeU1ERUNvbnRhaW5lciwgY21XcmFwcGVyKTtcbiAgICBlYXN5TURFQ29udGFpbmVyLmFwcGVuZENoaWxkKGNtV3JhcHBlcik7XG5cbiAgICBpZiAob3B0aW9ucy50b29sYmFyICE9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmd1aS50b29sYmFyID0gdGhpcy5jcmVhdGVUb29sYmFyKCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnN0YXR1cyAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5ndWkuc3RhdHVzYmFyID0gdGhpcy5jcmVhdGVTdGF0dXNiYXIoKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYXV0b3NhdmUgIT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuYXV0b3NhdmUuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmF1dG9zYXZlKCk7IC8vIHVzZSB0byBsb2FkIGxvY2Fsc3RvcmFnZSBjb250ZW50XG4gICAgICAgIHRoaXMuY29kZW1pcnJvci5vbignY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuX2F1dG9zYXZlX3RpbWVvdXQpO1xuICAgICAgICAgICAgc2VsZi5fYXV0b3NhdmVfdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuYXV0b3NhdmUoKTtcbiAgICAgICAgICAgIH0sIHNlbGYub3B0aW9ucy5hdXRvc2F2ZS5zdWJtaXRfZGVsYXkgfHwgc2VsZi5vcHRpb25zLmF1dG9zYXZlLmRlbGF5IHx8IDEwMDApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxjSGVpZ2h0KG5hdHVyYWxXaWR0aCwgbmF0dXJhbEhlaWdodCkge1xuICAgICAgICB2YXIgaGVpZ2h0O1xuICAgICAgICB2YXIgdmlld3BvcnRXaWR0aCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5Db2RlTWlycm9yLXNpemVyJykpLndpZHRoLnJlcGxhY2UoJ3B4JywgJycpO1xuICAgICAgICBpZiAobmF0dXJhbFdpZHRoIDwgdmlld3BvcnRXaWR0aCkge1xuICAgICAgICAgICAgaGVpZ2h0ID0gbmF0dXJhbEhlaWdodCArICdweCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoZWlnaHQgPSAobmF0dXJhbEhlaWdodCAvIG5hdHVyYWxXaWR0aCAqIDEwMCkgKyAnJSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICB9XG5cbiAgICB2YXIgX3ZtID0gdGhpcztcblxuXG4gICAgZnVuY3Rpb24gYXNzaWduSW1hZ2VCbG9ja0F0dHJpYnV0ZXMocGFyZW50RWwsIGltZykge1xuICAgICAgICBwYXJlbnRFbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtaW1nLXNyYycsIGltZy51cmwpO1xuICAgICAgICBwYXJlbnRFbC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJy0tYmctaW1hZ2U6dXJsKCcgKyBpbWcudXJsICsgJyk7LS13aWR0aDonICsgaW1nLm5hdHVyYWxXaWR0aCArICdweDstLWhlaWdodDonICsgY2FsY0hlaWdodChpbWcubmF0dXJhbFdpZHRoLCBpbWcubmF0dXJhbEhlaWdodCkpO1xuICAgICAgICBfdm0uY29kZW1pcnJvci5zZXRTaXplKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlSW1hZ2VzKCkge1xuICAgICAgICBpZiAoIW9wdGlvbnMucHJldmlld0ltYWdlc0luRWRpdG9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBlYXN5TURFQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJy5jbS1pbWFnZS1tYXJrZXInKS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50RWwgPSBlLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoIXBhcmVudEVsLmlubmVyVGV4dC5tYXRjaCgvXiFcXFsuKj9cXF1cXCguKlxcKS9nKSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIGltZyBwYXN0ZWQgb24gdGhlIHNhbWUgbGluZSB3aXRoIG90aGVyIHRleHQsIGRvbid0IHByZXZpZXcsIHByZXZpZXcgb25seSBpbWFnZXMgb24gc2VwYXJhdGUgbGluZVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcGFyZW50RWwuaGFzQXR0cmlidXRlKCdkYXRhLWltZy1zcmMnKSkge1xuICAgICAgICAgICAgICAgIHZhciBzcmNBdHRyID0gcGFyZW50RWwuaW5uZXJUZXh0Lm1hdGNoKCdcXFxcKCguKilcXFxcKScpOyAvLyBtaWdodCByZXF1aXJlIGJldHRlciBwYXJzaW5nIGFjY29yZGluZyB0byBtYXJrZG93biBzcGVjXG4gICAgICAgICAgICAgICAgaWYgKCF3aW5kb3cuRU1ERWltYWdlc0NhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5FTURFaW1hZ2VzQ2FjaGUgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc3JjQXR0ciAmJiBzcmNBdHRyLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlTcmMgPSBzcmNBdHRyWzFdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmltYWdlc1ByZXZpZXdIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3U3JjID0gb3B0aW9ucy5pbWFnZXNQcmV2aWV3SGFuZGxlcihzcmNBdHRyWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlZmVuc2l2ZSBjaGVjayBtYWtpbmcgc3VyZSB0aGUgaGFuZGxlciBwcm92aWRlZCBieSB0aGUgdXNlciByZXR1cm5zIGEgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5ld1NyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlTcmMgPSBuZXdTcmM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXdpbmRvdy5FTURFaW1hZ2VzQ2FjaGVba2V5U3JjXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuRU1ERWltYWdlc0NhY2hlW2tleVNyY10gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdHVyYWxXaWR0aDogaW1nLm5hdHVyYWxXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF0dXJhbEhlaWdodDogaW1nLm5hdHVyYWxIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDoga2V5U3JjLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzaWduSW1hZ2VCbG9ja0F0dHJpYnV0ZXMocGFyZW50RWwsIHdpbmRvdy5FTURFaW1hZ2VzQ2FjaGVba2V5U3JjXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1nLnNyYyA9IGtleVNyYztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2lnbkltYWdlQmxvY2tBdHRyaWJ1dGVzKHBhcmVudEVsLCB3aW5kb3cuRU1ERWltYWdlc0NhY2hlW2tleVNyY10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmNvZGVtaXJyb3Iub24oJ3VwZGF0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaGFuZGxlSW1hZ2VzKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmd1aS5zaWRlQnlTaWRlID0gdGhpcy5jcmVhdGVTaWRlQnlTaWRlKCk7XG4gICAgdGhpcy5fcmVuZGVyZWQgPSB0aGlzLmVsZW1lbnQ7XG5cbiAgICBpZiAob3B0aW9ucy5hdXRvZm9jdXMgPT09IHRydWUgfHwgZWwuYXV0b2ZvY3VzKSB7XG4gICAgICAgIHRoaXMuY29kZW1pcnJvci5mb2N1cygpO1xuICAgIH1cblxuICAgIC8vIEZpeGVzIENvZGVNaXJyb3IgYnVnICgjMzQ0KVxuICAgIHZhciB0ZW1wX2NtID0gdGhpcy5jb2RlbWlycm9yO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB0ZW1wX2NtLnJlZnJlc2goKTtcbiAgICB9LmJpbmQodGVtcF9jbSksIDApO1xufTtcblxuRWFzeU1ERS5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5kb2N1bWVudE9uS2V5RG93bik7XG59O1xuXG4vLyBTYWZhcmksIGluIFByaXZhdGUgQnJvd3NpbmcgTW9kZSwgbG9va3MgbGlrZSBpdCBzdXBwb3J0cyBsb2NhbFN0b3JhZ2UgYnV0IGFsbCBjYWxscyB0byBzZXRJdGVtIHRocm93IFF1b3RhRXhjZWVkZWRFcnJvci4gV2UncmUgZ29pbmcgdG8gZGV0ZWN0IHRoaXMgYW5kIHNldCBhIHZhcmlhYmxlIGFjY29yZGluZ2x5LlxuZnVuY3Rpb24gaXNMb2NhbFN0b3JhZ2VBdmFpbGFibGUoKSB7XG4gICAgaWYgKHR5cGVvZiBsb2NhbFN0b3JhZ2UgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnc21kZV9sb2NhbFN0b3JhZ2UnLCAxKTtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdzbWRlX2xvY2FsU3RvcmFnZScpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbkVhc3lNREUucHJvdG90eXBlLmF1dG9zYXZlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChpc0xvY2FsU3RvcmFnZUF2YWlsYWJsZSgpKSB7XG4gICAgICAgIHZhciBlYXN5TURFID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9zYXZlLnVuaXF1ZUlkID09IHVuZGVmaW5lZCB8fCB0aGlzLm9wdGlvbnMuYXV0b3NhdmUudW5pcXVlSWQgPT0gJycpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFYXN5TURFOiBZb3UgbXVzdCBzZXQgYSB1bmlxdWVJZCB0byB1c2UgdGhlIGF1dG9zYXZlIGZlYXR1cmUnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b3NhdmUuYmluZGVkICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoZWFzeU1ERS5lbGVtZW50LmZvcm0gIT0gbnVsbCAmJiBlYXN5TURFLmVsZW1lbnQuZm9ybSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBlYXN5TURFLmVsZW1lbnQuZm9ybS5hZGRFdmVudExpc3RlbmVyKCdzdWJtaXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChlYXN5TURFLmF1dG9zYXZlVGltZW91dElkKTtcbiAgICAgICAgICAgICAgICAgICAgZWFzeU1ERS5hdXRvc2F2ZVRpbWVvdXRJZCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnc21kZV8nICsgZWFzeU1ERS5vcHRpb25zLmF1dG9zYXZlLnVuaXF1ZUlkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmF1dG9zYXZlLmJpbmRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9zYXZlLmxvYWRlZCAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnc21kZV8nICsgdGhpcy5vcHRpb25zLmF1dG9zYXZlLnVuaXF1ZUlkKSA9PSAnc3RyaW5nJyAmJiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnc21kZV8nICsgdGhpcy5vcHRpb25zLmF1dG9zYXZlLnVuaXF1ZUlkKSAhPSAnJykge1xuICAgICAgICAgICAgICAgIHRoaXMuY29kZW1pcnJvci5zZXRWYWx1ZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnc21kZV8nICsgdGhpcy5vcHRpb25zLmF1dG9zYXZlLnVuaXF1ZUlkKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmF1dG9zYXZlLmZvdW5kU2F2ZWRWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5hdXRvc2F2ZS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbHVlID0gZWFzeU1ERS52YWx1ZSgpO1xuICAgICAgICBpZiAodmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnc21kZV8nICsgdGhpcy5vcHRpb25zLmF1dG9zYXZlLnVuaXF1ZUlkLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnc21kZV8nICsgdGhpcy5vcHRpb25zLmF1dG9zYXZlLnVuaXF1ZUlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhdXRvc2F2ZWQnKTtcbiAgICAgICAgaWYgKGVsICE9IG51bGwgJiYgZWwgIT0gdW5kZWZpbmVkICYmIGVsICE9ICcnKSB7XG4gICAgICAgICAgICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICB2YXIgZGQgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChbdGhpcy5vcHRpb25zLmF1dG9zYXZlLnRpbWVGb3JtYXQubG9jYWxlLCAnZW4tVVMnXSwgdGhpcy5vcHRpb25zLmF1dG9zYXZlLnRpbWVGb3JtYXQuZm9ybWF0KS5mb3JtYXQoZCk7XG4gICAgICAgICAgICB2YXIgc2F2ZSA9IHRoaXMub3B0aW9ucy5hdXRvc2F2ZS50ZXh0ID09IHVuZGVmaW5lZCA/ICdBdXRvc2F2ZWQ6ICcgOiB0aGlzLm9wdGlvbnMuYXV0b3NhdmUudGV4dDtcblxuICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gc2F2ZSArIGRkO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0Vhc3lNREU6IGxvY2FsU3RvcmFnZSBub3QgYXZhaWxhYmxlLCBjYW5ub3QgYXV0b3NhdmUnKTtcbiAgICB9XG59O1xuXG5FYXN5TURFLnByb3RvdHlwZS5jbGVhckF1dG9zYXZlZFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChpc0xvY2FsU3RvcmFnZUF2YWlsYWJsZSgpKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b3NhdmUgPT0gdW5kZWZpbmVkIHx8IHRoaXMub3B0aW9ucy5hdXRvc2F2ZS51bmlxdWVJZCA9PSB1bmRlZmluZWQgfHwgdGhpcy5vcHRpb25zLmF1dG9zYXZlLnVuaXF1ZUlkID09ICcnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRWFzeU1ERTogWW91IG11c3Qgc2V0IGEgdW5pcXVlSWQgdG8gY2xlYXIgdGhlIGF1dG9zYXZlIHZhbHVlJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnc21kZV8nICsgdGhpcy5vcHRpb25zLmF1dG9zYXZlLnVuaXF1ZUlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygnRWFzeU1ERTogbG9jYWxTdG9yYWdlIG5vdCBhdmFpbGFibGUsIGNhbm5vdCBhdXRvc2F2ZScpO1xuICAgIH1cbn07XG5cbi8qKlxuICogT3BlbiB0aGUgYnJvd3NlLWZpbGUgd2luZG93IHRvIHVwbG9hZCBhbiBpbWFnZSB0byBhIHNlcnZlci5cbiAqIEBwYXJhbSBbb25TdWNjZXNzXSB7ZnVuY3Rpb259IHNlZSBFYXN5TURFLnByb3RvdHlwZS51cGxvYWRJbWFnZVxuICogQHBhcmFtIFtvbkVycm9yXSB7ZnVuY3Rpb259IHNlZSBFYXN5TURFLnByb3RvdHlwZS51cGxvYWRJbWFnZVxuICovXG5FYXN5TURFLnByb3RvdHlwZS5vcGVuQnJvd3NlRmlsZVdpbmRvdyA9IGZ1bmN0aW9uIChvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGltYWdlSW5wdXQgPSB0aGlzLmd1aS50b29sYmFyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2ltYWdlSW5wdXQnKVswXTtcbiAgICBpbWFnZUlucHV0LmNsaWNrKCk7IC8vZGlzcGF0Y2hFdmVudChuZXcgTW91c2VFdmVudCgnY2xpY2snKSk7ICAvLyByZXBsYWNlZCB3aXRoIGNsaWNrKCkgZm9yIElFMTEgY29tcGF0aWJpbGl0eS5cbiAgICBmdW5jdGlvbiBvbkNoYW5nZShldmVudCkge1xuICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmltYWdlVXBsb2FkRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHNlbGYudXBsb2FkSW1hZ2VzVXNpbmdDdXN0b21GdW5jdGlvbihzZWxmLm9wdGlvbnMuaW1hZ2VVcGxvYWRGdW5jdGlvbiwgZXZlbnQudGFyZ2V0LmZpbGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYudXBsb2FkSW1hZ2VzKGV2ZW50LnRhcmdldC5maWxlcywgb25TdWNjZXNzLCBvbkVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBpbWFnZUlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ2hhbmdlKTtcbiAgICB9XG5cbiAgICBpbWFnZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ2hhbmdlKTtcbn07XG5cbi8qKlxuICogVXBsb2FkIGFuIGltYWdlIHRvIHRoZSBzZXJ2ZXIuXG4gKlxuICogQHBhcmFtIGZpbGUge0ZpbGV9IFRoZSBpbWFnZSB0byB1cGxvYWQsIGFzIGEgSFRNTDUgRmlsZSBvYmplY3QgKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GaWxlKVxuICogQHBhcmFtIFtvblN1Y2Nlc3NdIHtmdW5jdGlvbn0gQSBjYWxsYmFjayBmdW5jdGlvbiB0byBleGVjdXRlIGFmdGVyIHRoZSBpbWFnZSBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgdXBsb2FkZWQsIHdpdGggb25lIHBhcmFtZXRlcjpcbiAqIC0gdXJsIChzdHJpbmcpOiBUaGUgVVJMIG9mIHRoZSB1cGxvYWRlZCBpbWFnZS5cbiAqIEBwYXJhbSBbb25FcnJvcl0ge2Z1bmN0aW9ufSBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgaW1hZ2UgdXBsb2FkIGZhaWxzLCB3aXRoIG9uZSBwYXJhbWV0ZXI6XG4gKiAtIGVycm9yIChzdHJpbmcpOiB0aGUgZGV0YWlsZWQgZXJyb3IgdG8gZGlzcGxheSB0byB0aGUgdXNlciAoYmFzZWQgb24gbWVzc2FnZXMgZnJvbSBvcHRpb25zLmVycm9yTWVzc2FnZXMpLlxuICovXG5FYXN5TURFLnByb3RvdHlwZS51cGxvYWRJbWFnZSA9IGZ1bmN0aW9uIChmaWxlLCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgb25TdWNjZXNzID0gb25TdWNjZXNzIHx8IGZ1bmN0aW9uIG9uU3VjY2VzcyhpbWFnZVVybCkge1xuICAgICAgICBhZnRlckltYWdlVXBsb2FkZWQoc2VsZiwgaW1hZ2VVcmwpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBvbkVycm9yU3VwKGVycm9yTWVzc2FnZSkge1xuICAgICAgICAvLyBzaG93IGVycm9yIG9uIHN0YXR1cyBiYXIgYW5kIHJlc2V0IGFmdGVyIDEwMDAwbXNcbiAgICAgICAgc2VsZi51cGRhdGVTdGF0dXNCYXIoJ3VwbG9hZC1pbWFnZScsIGVycm9yTWVzc2FnZSk7XG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLnVwZGF0ZVN0YXR1c0JhcigndXBsb2FkLWltYWdlJywgc2VsZi5vcHRpb25zLmltYWdlVGV4dHMuc2JJbml0KTtcbiAgICAgICAgfSwgMTAwMDApO1xuXG4gICAgICAgIC8vIHJ1biBjdXN0b20gZXJyb3IgaGFuZGxlclxuICAgICAgICBpZiAob25FcnJvciAmJiB0eXBlb2Ygb25FcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb25FcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJ1biBlcnJvciBoYW5kbGVyIGZyb20gb3B0aW9ucywgdGhpcyBhbGVydHMgdGhlIG1lc3NhZ2UuXG4gICAgICAgIHNlbGYub3B0aW9ucy5lcnJvckNhbGxiYWNrKGVycm9yTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlsbEVycm9yTWVzc2FnZShlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIHVuaXRzID0gc2VsZi5vcHRpb25zLmltYWdlVGV4dHMuc2l6ZVVuaXRzLnNwbGl0KCcsJyk7XG4gICAgICAgIHJldHVybiBlcnJvck1lc3NhZ2VcbiAgICAgICAgICAgIC5yZXBsYWNlKCcjaW1hZ2VfbmFtZSMnLCBmaWxlLm5hbWUpXG4gICAgICAgICAgICAucmVwbGFjZSgnI2ltYWdlX3NpemUjJywgaHVtYW5GaWxlU2l6ZShmaWxlLnNpemUsIHVuaXRzKSlcbiAgICAgICAgICAgIC5yZXBsYWNlKCcjaW1hZ2VfbWF4X3NpemUjJywgaHVtYW5GaWxlU2l6ZShzZWxmLm9wdGlvbnMuaW1hZ2VNYXhTaXplLCB1bml0cykpO1xuICAgIH1cblxuICAgIGlmIChmaWxlLnNpemUgPiB0aGlzLm9wdGlvbnMuaW1hZ2VNYXhTaXplKSB7XG4gICAgICAgIG9uRXJyb3JTdXAoZmlsbEVycm9yTWVzc2FnZSh0aGlzLm9wdGlvbnMuZXJyb3JNZXNzYWdlcy5maWxlVG9vTGFyZ2UpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIGZvcm1EYXRhLmFwcGVuZCgnaW1hZ2UnLCBmaWxlKTtcblxuICAgIC8vIGluc2VydCBDU1JGIGJvZHkgdG9rZW4gaWYgcHJvdmlkZWQgaW4gY29uZmlnLlxuICAgIGlmIChzZWxmLm9wdGlvbnMuaW1hZ2VDU1JGVG9rZW4gJiYgIXNlbGYub3B0aW9ucy5pbWFnZUNTUkZIZWFkZXIpIHtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKHNlbGYub3B0aW9ucy5pbWFnZUNTUkZOYW1lLCBzZWxmLm9wdGlvbnMuaW1hZ2VDU1JGVG9rZW4pO1xuICAgIH1cblxuICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgcmVxdWVzdC51cGxvYWQub25wcm9ncmVzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQubGVuZ3RoQ29tcHV0YWJsZSkge1xuICAgICAgICAgICAgdmFyIHByb2dyZXNzID0gJycgKyBNYXRoLnJvdW5kKChldmVudC5sb2FkZWQgKiAxMDApIC8gZXZlbnQudG90YWwpO1xuICAgICAgICAgICAgc2VsZi51cGRhdGVTdGF0dXNCYXIoJ3VwbG9hZC1pbWFnZScsIHNlbGYub3B0aW9ucy5pbWFnZVRleHRzLnNiUHJvZ3Jlc3MucmVwbGFjZSgnI2ZpbGVfbmFtZSMnLCBmaWxlLm5hbWUpLnJlcGxhY2UoJyNwcm9ncmVzcyMnLCBwcm9ncmVzcykpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXF1ZXN0Lm9wZW4oJ1BPU1QnLCB0aGlzLm9wdGlvbnMuaW1hZ2VVcGxvYWRFbmRwb2ludCk7XG5cbiAgICAvLyBpbnNlcnQgQ1NSRiBoZWFkZXIgdG9rZW4gaWYgcHJvdmlkZWQgaW4gY29uZmlnLlxuICAgIGlmIChzZWxmLm9wdGlvbnMuaW1hZ2VDU1JGVG9rZW4gJiYgc2VsZi5vcHRpb25zLmltYWdlQ1NSRkhlYWRlcikge1xuICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoc2VsZi5vcHRpb25zLmltYWdlQ1NSRk5hbWUsIHNlbGYub3B0aW9ucy5pbWFnZUNTUkZUb2tlbik7XG4gICAgfVxuXG4gICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSBKU09OLnBhcnNlKHRoaXMucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vhc3lNREU6IFRoZSBzZXJ2ZXIgZGlkIG5vdCByZXR1cm4gYSB2YWxpZCBqc29uLicpO1xuICAgICAgICAgICAgb25FcnJvclN1cChmaWxsRXJyb3JNZXNzYWdlKHNlbGYub3B0aW9ucy5lcnJvck1lc3NhZ2VzLmltcG9ydEVycm9yKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSAyMDAgJiYgcmVzcG9uc2UgJiYgIXJlc3BvbnNlLmVycm9yICYmIHJlc3BvbnNlLmRhdGEgJiYgcmVzcG9uc2UuZGF0YS5maWxlUGF0aCkge1xuICAgICAgICAgICAgb25TdWNjZXNzKChzZWxmLm9wdGlvbnMuaW1hZ2VQYXRoQWJzb2x1dGUgPyAnJyA6ICh3aW5kb3cubG9jYXRpb24ub3JpZ2luICsgJy8nKSkgKyByZXNwb25zZS5kYXRhLmZpbGVQYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5lcnJvciAmJiByZXNwb25zZS5lcnJvciBpbiBzZWxmLm9wdGlvbnMuZXJyb3JNZXNzYWdlcykgeyAgLy8gcHJlZm9ybWF0dGVkIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICBvbkVycm9yU3VwKGZpbGxFcnJvck1lc3NhZ2Uoc2VsZi5vcHRpb25zLmVycm9yTWVzc2FnZXNbcmVzcG9uc2UuZXJyb3JdKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLmVycm9yKSB7ICAvLyBzZXJ2ZXIgc2lkZSBnZW5lcmF0ZWQgZXJyb3IgbWVzc2FnZVxuICAgICAgICAgICAgICAgIG9uRXJyb3JTdXAoZmlsbEVycm9yTWVzc2FnZShyZXNwb25zZS5lcnJvcikpO1xuICAgICAgICAgICAgfSBlbHNlIHsgIC8vdW5rbm93biBlcnJvclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vhc3lNREU6IFJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgcmVzcG9uc2UgYWZ0ZXIgdXBsb2FkaW5nIHRoZSBpbWFnZS4nXG4gICAgICAgICAgICAgICAgICAgICsgdGhpcy5zdGF0dXMgKyAnICgnICsgdGhpcy5zdGF0dXNUZXh0ICsgJyknKTtcbiAgICAgICAgICAgICAgICBvbkVycm9yU3VwKGZpbGxFcnJvck1lc3NhZ2Uoc2VsZi5vcHRpb25zLmVycm9yTWVzc2FnZXMuaW1wb3J0RXJyb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRWFzeU1ERTogQW4gdW5leHBlY3RlZCBlcnJvciBvY2N1cnJlZCB3aGVuIHRyeWluZyB0byB1cGxvYWQgdGhlIGltYWdlLidcbiAgICAgICAgICAgICsgZXZlbnQudGFyZ2V0LnN0YXR1cyArICcgKCcgKyBldmVudC50YXJnZXQuc3RhdHVzVGV4dCArICcpJyk7XG4gICAgICAgIG9uRXJyb3JTdXAoc2VsZi5vcHRpb25zLmVycm9yTWVzc2FnZXMuaW1wb3J0RXJyb3IpO1xuICAgIH07XG5cbiAgICByZXF1ZXN0LnNlbmQoZm9ybURhdGEpO1xuXG59O1xuXG4vKipcbiAqIFVwbG9hZCBhbiBpbWFnZSB0byB0aGUgc2VydmVyIHVzaW5nIGEgY3VzdG9tIHVwbG9hZCBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gaW1hZ2VVcGxvYWRGdW5jdGlvbiB7RnVuY3Rpb259IFRoZSBjdXN0b20gZnVuY3Rpb24gdG8gdXBsb2FkIHRoZSBpbWFnZSBwYXNzZWQgaW4gb3B0aW9uc1xuICogQHBhcmFtIGZpbGUge0ZpbGV9IFRoZSBpbWFnZSB0byB1cGxvYWQsIGFzIGEgSFRNTDUgRmlsZSBvYmplY3QgKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GaWxlKS5cbiAqL1xuRWFzeU1ERS5wcm90b3R5cGUudXBsb2FkSW1hZ2VVc2luZ0N1c3RvbUZ1bmN0aW9uID0gZnVuY3Rpb24gKGltYWdlVXBsb2FkRnVuY3Rpb24sIGZpbGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiBvblN1Y2Nlc3MoaW1hZ2VVcmwpIHtcbiAgICAgICAgYWZ0ZXJJbWFnZVVwbG9hZGVkKHNlbGYsIGltYWdlVXJsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkVycm9yKGVycm9yTWVzc2FnZSkge1xuICAgICAgICB2YXIgZmlsbGVkRXJyb3JNZXNzYWdlID0gZmlsbEVycm9yTWVzc2FnZShlcnJvck1lc3NhZ2UpO1xuICAgICAgICAvLyBzaG93IGVycm9yIG9uIHN0YXR1cyBiYXIgYW5kIHJlc2V0IGFmdGVyIDEwMDAwbXNcbiAgICAgICAgc2VsZi51cGRhdGVTdGF0dXNCYXIoJ3VwbG9hZC1pbWFnZScsIGZpbGxlZEVycm9yTWVzc2FnZSk7XG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLnVwZGF0ZVN0YXR1c0JhcigndXBsb2FkLWltYWdlJywgc2VsZi5vcHRpb25zLmltYWdlVGV4dHMuc2JJbml0KTtcbiAgICAgICAgfSwgMTAwMDApO1xuXG4gICAgICAgIC8vIHJ1biBlcnJvciBoYW5kbGVyIGZyb20gb3B0aW9ucywgdGhpcyBhbGVydHMgdGhlIG1lc3NhZ2UuXG4gICAgICAgIHNlbGYub3B0aW9ucy5lcnJvckNhbGxiYWNrKGZpbGxlZEVycm9yTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlsbEVycm9yTWVzc2FnZShlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIHVuaXRzID0gc2VsZi5vcHRpb25zLmltYWdlVGV4dHMuc2l6ZVVuaXRzLnNwbGl0KCcsJyk7XG4gICAgICAgIHJldHVybiBlcnJvck1lc3NhZ2VcbiAgICAgICAgICAgIC5yZXBsYWNlKCcjaW1hZ2VfbmFtZSMnLCBmaWxlLm5hbWUpXG4gICAgICAgICAgICAucmVwbGFjZSgnI2ltYWdlX3NpemUjJywgaHVtYW5GaWxlU2l6ZShmaWxlLnNpemUsIHVuaXRzKSlcbiAgICAgICAgICAgIC5yZXBsYWNlKCcjaW1hZ2VfbWF4X3NpemUjJywgaHVtYW5GaWxlU2l6ZShzZWxmLm9wdGlvbnMuaW1hZ2VNYXhTaXplLCB1bml0cykpO1xuICAgIH1cblxuICAgIGltYWdlVXBsb2FkRnVuY3Rpb24uYXBwbHkodGhpcywgW2ZpbGUsIG9uU3VjY2Vzcywgb25FcnJvcl0pO1xufTtcblxuRWFzeU1ERS5wcm90b3R5cGUuc2V0UHJldmlld01heEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY20gPSB0aGlzLmNvZGVtaXJyb3I7XG4gICAgdmFyIHdyYXBwZXIgPSBjbS5nZXRXcmFwcGVyRWxlbWVudCgpO1xuICAgIHZhciBwcmV2aWV3ID0gd3JhcHBlci5uZXh0U2libGluZztcblxuICAgIC8vIENhbGMgcHJldmlldyBtYXggaGVpZ2h0XG4gICAgdmFyIHBhZGRpbmdUb3AgPSBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh3cmFwcGVyKS5wYWRkaW5nVG9wKTtcbiAgICB2YXIgYm9yZGVyVG9wV2lkdGggPSBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh3cmFwcGVyKS5ib3JkZXJUb3BXaWR0aCk7XG4gICAgdmFyIG9wdGlvbnNNYXhIZWlnaHQgPSBwYXJzZUludCh0aGlzLm9wdGlvbnMubWF4SGVpZ2h0KTtcbiAgICB2YXIgd3JhcHBlck1heEhlaWdodCA9IG9wdGlvbnNNYXhIZWlnaHQgKyBwYWRkaW5nVG9wICogMiArIGJvcmRlclRvcFdpZHRoICogMjtcbiAgICB2YXIgcHJldmlld01heEhlaWdodCA9IHdyYXBwZXJNYXhIZWlnaHQudG9TdHJpbmcoKSArICdweCc7XG5cbiAgICBwcmV2aWV3LnN0eWxlLmhlaWdodCA9IHByZXZpZXdNYXhIZWlnaHQ7XG59O1xuXG5FYXN5TURFLnByb3RvdHlwZS5jcmVhdGVTaWRlQnlTaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjbSA9IHRoaXMuY29kZW1pcnJvcjtcbiAgICB2YXIgd3JhcHBlciA9IGNtLmdldFdyYXBwZXJFbGVtZW50KCk7XG4gICAgdmFyIHByZXZpZXcgPSB3cmFwcGVyLm5leHRTaWJsaW5nO1xuXG4gICAgaWYgKCFwcmV2aWV3IHx8ICFwcmV2aWV3LmNsYXNzTGlzdC5jb250YWlucygnZWRpdG9yLXByZXZpZXctc2lkZScpKSB7XG4gICAgICAgIHByZXZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgcHJldmlldy5jbGFzc05hbWUgPSAnZWRpdG9yLXByZXZpZXctc2lkZSc7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wcmV2aWV3Q2xhc3MpIHtcblxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5vcHRpb25zLnByZXZpZXdDbGFzcykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3B0aW9ucy5wcmV2aWV3Q2xhc3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlldy5jbGFzc0xpc3QuYWRkKHRoaXMub3B0aW9ucy5wcmV2aWV3Q2xhc3NbaV0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnByZXZpZXdDbGFzcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBwcmV2aWV3LmNsYXNzTGlzdC5hZGQodGhpcy5vcHRpb25zLnByZXZpZXdDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3cmFwcGVyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHByZXZpZXcsIHdyYXBwZXIubmV4dFNpYmxpbmcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLm1heEhlaWdodCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5zZXRQcmV2aWV3TWF4SGVpZ2h0KCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5zeW5jU2lkZUJ5U2lkZVByZXZpZXdTY3JvbGwgPT09IGZhbHNlKSByZXR1cm4gcHJldmlldztcbiAgICAvLyBTeW5jcyBzY3JvbGwgIGVkaXRvciAtPiBwcmV2aWV3XG4gICAgdmFyIGNTY3JvbGwgPSBmYWxzZTtcbiAgICB2YXIgcFNjcm9sbCA9IGZhbHNlO1xuICAgIGNtLm9uKCdzY3JvbGwnLCBmdW5jdGlvbiAodikge1xuICAgICAgICBpZiAoY1Njcm9sbCkge1xuICAgICAgICAgICAgY1Njcm9sbCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBTY3JvbGwgPSB0cnVlO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdi5nZXRTY3JvbGxJbmZvKCkuaGVpZ2h0IC0gdi5nZXRTY3JvbGxJbmZvKCkuY2xpZW50SGVpZ2h0O1xuICAgICAgICB2YXIgcmF0aW8gPSBwYXJzZUZsb2F0KHYuZ2V0U2Nyb2xsSW5mbygpLnRvcCkgLyBoZWlnaHQ7XG4gICAgICAgIHZhciBtb3ZlID0gKHByZXZpZXcuc2Nyb2xsSGVpZ2h0IC0gcHJldmlldy5jbGllbnRIZWlnaHQpICogcmF0aW87XG4gICAgICAgIHByZXZpZXcuc2Nyb2xsVG9wID0gbW92ZTtcbiAgICB9KTtcblxuICAgIC8vIFN5bmNzIHNjcm9sbCAgcHJldmlldyAtPiBlZGl0b3JcbiAgICBwcmV2aWV3Lm9uc2Nyb2xsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocFNjcm9sbCkge1xuICAgICAgICAgICAgcFNjcm9sbCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNTY3JvbGwgPSB0cnVlO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gcHJldmlldy5zY3JvbGxIZWlnaHQgLSBwcmV2aWV3LmNsaWVudEhlaWdodDtcbiAgICAgICAgdmFyIHJhdGlvID0gcGFyc2VGbG9hdChwcmV2aWV3LnNjcm9sbFRvcCkgLyBoZWlnaHQ7XG4gICAgICAgIHZhciBtb3ZlID0gKGNtLmdldFNjcm9sbEluZm8oKS5oZWlnaHQgLSBjbS5nZXRTY3JvbGxJbmZvKCkuY2xpZW50SGVpZ2h0KSAqIHJhdGlvO1xuICAgICAgICBjbS5zY3JvbGxUbygwLCBtb3ZlKTtcbiAgICB9O1xuICAgIHJldHVybiBwcmV2aWV3O1xufTtcblxuRWFzeU1ERS5wcm90b3R5cGUuY3JlYXRlVG9vbGJhciA9IGZ1bmN0aW9uIChpdGVtcykge1xuICAgIGl0ZW1zID0gaXRlbXMgfHwgdGhpcy5vcHRpb25zLnRvb2xiYXI7XG5cbiAgICBpZiAoIWl0ZW1zIHx8IGl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodG9vbGJhckJ1aWx0SW5CdXR0b25zW2l0ZW1zW2ldXSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGl0ZW1zW2ldID0gdG9vbGJhckJ1aWx0SW5CdXR0b25zW2l0ZW1zW2ldXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBiYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBiYXIuY2xhc3NOYW1lID0gJ2VkaXRvci10b29sYmFyJztcbiAgICBiYXIuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3Rvb2xiYXInKTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciB0b29sYmFyRGF0YSA9IHt9O1xuICAgIHNlbGYudG9vbGJhciA9IGl0ZW1zO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpdGVtc1tpXS5uYW1lID09ICdndWlkZScgJiYgc2VsZi5vcHRpb25zLnRvb2xiYXJHdWlkZUljb24gPT09IGZhbHNlKVxuICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5oaWRlSWNvbnMgJiYgc2VsZi5vcHRpb25zLmhpZGVJY29ucy5pbmRleE9mKGl0ZW1zW2ldLm5hbWUpICE9IC0xKVxuICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgLy8gRnVsbHNjcmVlbiBkb2VzIG5vdCB3b3JrIHdlbGwgb24gbW9iaWxlIGRldmljZXMgKGV2ZW4gdGFibGV0cylcbiAgICAgICAgLy8gSW4gdGhlIGZ1dHVyZSwgaG9wZWZ1bGx5IHRoaXMgY2FuIGJlIHJlc29sdmVkXG4gICAgICAgIGlmICgoaXRlbXNbaV0ubmFtZSA9PSAnZnVsbHNjcmVlbicgfHwgaXRlbXNbaV0ubmFtZSA9PSAnc2lkZS1ieS1zaWRlJykgJiYgaXNNb2JpbGUoKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG5cbiAgICAgICAgLy8gRG9uJ3QgaW5jbHVkZSB0cmFpbGluZyBzZXBhcmF0b3JzXG4gICAgICAgIGlmIChpdGVtc1tpXSA9PT0gJ3wnKSB7XG4gICAgICAgICAgICB2YXIgbm9uU2VwYXJhdG9ySWNvbnNGb2xsb3cgPSBmYWxzZTtcblxuICAgICAgICAgICAgZm9yICh2YXIgeCA9IChpICsgMSk7IHggPCBpdGVtcy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtc1t4XSAhPT0gJ3wnICYmICghc2VsZi5vcHRpb25zLmhpZGVJY29ucyB8fCBzZWxmLm9wdGlvbnMuaGlkZUljb25zLmluZGV4T2YoaXRlbXNbeF0ubmFtZSkgPT0gLTEpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vblNlcGFyYXRvckljb25zRm9sbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghbm9uU2VwYXJhdG9ySWNvbnNGb2xsb3cpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgaWNvbiBhbmQgYXBwZW5kIHRvIHRoZSB0b29sYmFyXG4gICAgICAgIChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgdmFyIGVsO1xuICAgICAgICAgICAgaWYgKGl0ZW0gPT09ICd8Jykge1xuICAgICAgICAgICAgICAgIGVsID0gY3JlYXRlU2VwKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBlbCA9IGNyZWF0ZVRvb2xiYXJEcm9wZG93bihpdGVtLCBzZWxmLm9wdGlvbnMudG9vbGJhclRpcHMsIHNlbGYub3B0aW9ucy5zaG9ydGN1dHMsIHNlbGYpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbCA9IGNyZWF0ZVRvb2xiYXJCdXR0b24oaXRlbSwgdHJ1ZSwgc2VsZi5vcHRpb25zLnRvb2xiYXJUaXBzLCBzZWxmLm9wdGlvbnMuc2hvcnRjdXRzLCAnYnV0dG9uJywgc2VsZik7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgdG9vbGJhckRhdGFbaXRlbS5uYW1lIHx8IGl0ZW1dID0gZWw7XG4gICAgICAgICAgICBiYXIuYXBwZW5kQ2hpbGQoZWwpO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIGlucHV0IGVsZW1lbnQgKGllLiA8aW5wdXQgdHlwZT0nZmlsZSc+KSwgdXNlZCBhbW9uZ1xuICAgICAgICAgICAgLy8gd2l0aCB0aGUgJ2ltcG9ydC1pbWFnZScgaWNvbiB0byBvcGVuIHRoZSBicm93c2UtZmlsZSB3aW5kb3cuXG4gICAgICAgICAgICBpZiAoaXRlbS5uYW1lID09PSAndXBsb2FkLWltYWdlJykge1xuICAgICAgICAgICAgICAgIHZhciBpbWFnZUlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgICAgICAgICBpbWFnZUlucHV0LmNsYXNzTmFtZSA9ICdpbWFnZUlucHV0JztcbiAgICAgICAgICAgICAgICBpbWFnZUlucHV0LnR5cGUgPSAnZmlsZSc7XG4gICAgICAgICAgICAgICAgaW1hZ2VJbnB1dC5tdWx0aXBsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaW1hZ2VJbnB1dC5uYW1lID0gJ2ltYWdlJztcbiAgICAgICAgICAgICAgICBpbWFnZUlucHV0LmFjY2VwdCA9IHNlbGYub3B0aW9ucy5pbWFnZUFjY2VwdDtcbiAgICAgICAgICAgICAgICBpbWFnZUlucHV0LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgaW1hZ2VJbnB1dC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgICAgICAgICBiYXIuYXBwZW5kQ2hpbGQoaW1hZ2VJbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKGl0ZW1zW2ldKTtcbiAgICB9XG5cbiAgICBzZWxmLnRvb2xiYXJfZGl2ID0gYmFyO1xuICAgIHNlbGYudG9vbGJhckVsZW1lbnRzID0gdG9vbGJhckRhdGE7XG5cbiAgICB2YXIgY20gPSB0aGlzLmNvZGVtaXJyb3I7XG4gICAgY20ub24oJ2N1cnNvckFjdGl2aXR5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdCA9IGdldFN0YXRlKGNtKTtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdG9vbGJhckRhdGEpIHtcbiAgICAgICAgICAgIChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gdG9vbGJhckRhdGFba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdFtrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ICE9ICdmdWxsc2NyZWVuJyAmJiBrZXkgIT0gJ3NpZGUtYnktc2lkZScpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoa2V5KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIGNtV3JhcHBlciA9IGNtLmdldFdyYXBwZXJFbGVtZW50KCk7XG4gICAgY21XcmFwcGVyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGJhciwgY21XcmFwcGVyKTtcbiAgICByZXR1cm4gYmFyO1xufTtcblxuRWFzeU1ERS5wcm90b3R5cGUuY3JlYXRlU3RhdHVzYmFyID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAgIC8vIEluaXRpYWxpemVcbiAgICBzdGF0dXMgPSBzdGF0dXMgfHwgdGhpcy5vcHRpb25zLnN0YXR1cztcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgY20gPSB0aGlzLmNvZGVtaXJyb3I7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlIHN0YXR1cyB2YXJpYWJsZSBpcyB2YWxpZFxuICAgIGlmICghc3RhdHVzIHx8IHN0YXR1cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNldCB1cCB0aGUgYnVpbHQtaW4gaXRlbXNcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB2YXIgaSwgb25VcGRhdGUsIG9uQWN0aXZpdHksIGRlZmF1bHRWYWx1ZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzdGF0dXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gUmVzZXQgc29tZSB2YWx1ZXNcbiAgICAgICAgb25VcGRhdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIG9uQWN0aXZpdHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9IHVuZGVmaW5lZDtcblxuXG4gICAgICAgIC8vIEhhbmRsZSBpZiBjdXN0b20gb3Igbm90XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdHVzW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBzdGF0dXNbaV0uY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogc3RhdHVzW2ldLmRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICAgICAgICBvblVwZGF0ZTogc3RhdHVzW2ldLm9uVXBkYXRlLFxuICAgICAgICAgICAgICAgIG9uQWN0aXZpdHk6IHN0YXR1c1tpXS5vbkFjdGl2aXR5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHN0YXR1c1tpXTtcblxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICd3b3JkcycpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gd29yZENvdW50KGNtLmdldFZhbHVlKCkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgb25VcGRhdGUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gd29yZENvdW50KGNtLmdldFZhbHVlKCkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdsaW5lcycpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gY20ubGluZUNvdW50KCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBvblVwZGF0ZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBjbS5saW5lQ291bnQoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAnY3Vyc29yJykge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICBlbC5pbm5lckhUTUwgPSAnMToxJztcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG9uQWN0aXZpdHkgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IGNtLmdldEN1cnNvcigpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zTGluZSA9IHBvcy5saW5lICsgMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvc0NvbHVtbiA9IHBvcy5jaCArIDE7XG4gICAgICAgICAgICAgICAgICAgIGVsLmlubmVySFRNTCA9IHBvc0xpbmUgKyAnOicgKyBwb3NDb2x1bW47XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2F1dG9zYXZlJykge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hdXRvc2F2ZSAhPSB1bmRlZmluZWQgJiYgb3B0aW9ucy5hdXRvc2F2ZS5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2F1dG9zYXZlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3VwbG9hZC1pbWFnZScpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gb3B0aW9ucy5pbWFnZVRleHRzLnNiSW5pdDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBkZWZhdWx0VmFsdWUsXG4gICAgICAgICAgICAgICAgb25VcGRhdGU6IG9uVXBkYXRlLFxuICAgICAgICAgICAgICAgIG9uQWN0aXZpdHk6IG9uQWN0aXZpdHksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gQ3JlYXRlIGVsZW1lbnQgZm9yIHRoZSBzdGF0dXMgYmFyXG4gICAgdmFyIGJhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGJhci5jbGFzc05hbWUgPSAnZWRpdG9yLXN0YXR1c2Jhcic7XG5cblxuICAgIC8vIENyZWF0ZSBhIG5ldyBzcGFuIGZvciBlYWNoIGl0ZW1cbiAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gU3RvcmUgaW4gdGVtcG9yYXJ5IHZhcmlhYmxlXG4gICAgICAgIHZhciBpdGVtID0gaXRlbXNbaV07XG5cblxuICAgICAgICAvLyBDcmVhdGUgc3BhbiBlbGVtZW50XG4gICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgZWwuY2xhc3NOYW1lID0gaXRlbS5jbGFzc05hbWU7XG5cblxuICAgICAgICAvLyBFbnN1cmUgdGhlIGRlZmF1bHRWYWx1ZSBpcyBhIGZ1bmN0aW9uXG4gICAgICAgIGlmICh0eXBlb2YgaXRlbS5kZWZhdWx0VmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGl0ZW0uZGVmYXVsdFZhbHVlKGVsKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gRW5zdXJlIHRoZSBvblVwZGF0ZSBpcyBhIGZ1bmN0aW9uXG4gICAgICAgIGlmICh0eXBlb2YgaXRlbS5vblVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgY2xvc3VyZSBhcm91bmQgdGhlIHNwYW4gb2YgdGhlIGN1cnJlbnQgYWN0aW9uLCB0aGVuIGV4ZWN1dGUgdGhlIG9uVXBkYXRlIGhhbmRsZXJcbiAgICAgICAgICAgIHRoaXMuY29kZW1pcnJvci5vbigndXBkYXRlJywgKGZ1bmN0aW9uIChlbCwgaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ub25VcGRhdGUoZWwpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KGVsLCBpdGVtKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbS5vbkFjdGl2aXR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBjbG9zdXJlIGFyb3VuZCB0aGUgc3BhbiBvZiB0aGUgY3VycmVudCBhY3Rpb24sIHRoZW4gZXhlY3V0ZSB0aGUgb25BY3Rpdml0eSBoYW5kbGVyXG4gICAgICAgICAgICB0aGlzLmNvZGVtaXJyb3Iub24oJ2N1cnNvckFjdGl2aXR5JywgKGZ1bmN0aW9uIChlbCwgaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ub25BY3Rpdml0eShlbCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0oZWwsIGl0ZW0pKSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIEFwcGVuZCB0aGUgaXRlbSB0byB0aGUgc3RhdHVzIGJhclxuICAgICAgICBiYXIuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIH1cblxuXG4gICAgLy8gSW5zZXJ0IHRoZSBzdGF0dXMgYmFyIGludG8gdGhlIERPTVxuICAgIHZhciBjbVdyYXBwZXIgPSB0aGlzLmNvZGVtaXJyb3IuZ2V0V3JhcHBlckVsZW1lbnQoKTtcbiAgICBjbVdyYXBwZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYmFyLCBjbVdyYXBwZXIubmV4dFNpYmxpbmcpO1xuICAgIHJldHVybiBiYXI7XG59O1xuXG4vKipcbiAqIEdldCBvciBzZXQgdGhlIHRleHQgY29udGVudC5cbiAqL1xuRWFzeU1ERS5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgdmFyIGNtID0gdGhpcy5jb2RlbWlycm9yO1xuICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gY20uZ2V0VmFsdWUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjbS5nZXREb2MoKS5zZXRWYWx1ZSh2YWwpO1xuICAgICAgICBpZiAodGhpcy5pc1ByZXZpZXdBY3RpdmUoKSkge1xuICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBjbS5nZXRXcmFwcGVyRWxlbWVudCgpO1xuICAgICAgICAgICAgdmFyIHByZXZpZXcgPSB3cmFwcGVyLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIHZhciBwcmV2aWV3X3Jlc3VsdCA9IHRoaXMub3B0aW9ucy5wcmV2aWV3UmVuZGVyKHZhbCwgcHJldmlldyk7XG4gICAgICAgICAgICBpZiAocHJldmlld19yZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwcmV2aWV3LmlubmVySFRNTCA9IHByZXZpZXdfcmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcblxuXG4vKipcbiAqIEJpbmQgc3RhdGljIG1ldGhvZHMgZm9yIGV4cG9ydHMuXG4gKi9cbkVhc3lNREUudG9nZ2xlQm9sZCA9IHRvZ2dsZUJvbGQ7XG5FYXN5TURFLnRvZ2dsZUl0YWxpYyA9IHRvZ2dsZUl0YWxpYztcbkVhc3lNREUudG9nZ2xlU3RyaWtldGhyb3VnaCA9IHRvZ2dsZVN0cmlrZXRocm91Z2g7XG5FYXN5TURFLnRvZ2dsZUJsb2NrcXVvdGUgPSB0b2dnbGVCbG9ja3F1b3RlO1xuRWFzeU1ERS50b2dnbGVIZWFkaW5nU21hbGxlciA9IHRvZ2dsZUhlYWRpbmdTbWFsbGVyO1xuRWFzeU1ERS50b2dnbGVIZWFkaW5nQmlnZ2VyID0gdG9nZ2xlSGVhZGluZ0JpZ2dlcjtcbkVhc3lNREUudG9nZ2xlSGVhZGluZzEgPSB0b2dnbGVIZWFkaW5nMTtcbkVhc3lNREUudG9nZ2xlSGVhZGluZzIgPSB0b2dnbGVIZWFkaW5nMjtcbkVhc3lNREUudG9nZ2xlSGVhZGluZzMgPSB0b2dnbGVIZWFkaW5nMztcbkVhc3lNREUudG9nZ2xlSGVhZGluZzQgPSB0b2dnbGVIZWFkaW5nNDtcbkVhc3lNREUudG9nZ2xlSGVhZGluZzUgPSB0b2dnbGVIZWFkaW5nNTtcbkVhc3lNREUudG9nZ2xlSGVhZGluZzYgPSB0b2dnbGVIZWFkaW5nNjtcbkVhc3lNREUudG9nZ2xlQ29kZUJsb2NrID0gdG9nZ2xlQ29kZUJsb2NrO1xuRWFzeU1ERS50b2dnbGVVbm9yZGVyZWRMaXN0ID0gdG9nZ2xlVW5vcmRlcmVkTGlzdDtcbkVhc3lNREUudG9nZ2xlT3JkZXJlZExpc3QgPSB0b2dnbGVPcmRlcmVkTGlzdDtcbkVhc3lNREUuY2xlYW5CbG9jayA9IGNsZWFuQmxvY2s7XG5FYXN5TURFLmRyYXdMaW5rID0gZHJhd0xpbms7XG5FYXN5TURFLmRyYXdJbWFnZSA9IGRyYXdJbWFnZTtcbkVhc3lNREUuZHJhd1VwbG9hZGVkSW1hZ2UgPSBkcmF3VXBsb2FkZWRJbWFnZTtcbkVhc3lNREUuZHJhd1RhYmxlID0gZHJhd1RhYmxlO1xuRWFzeU1ERS5kcmF3SG9yaXpvbnRhbFJ1bGUgPSBkcmF3SG9yaXpvbnRhbFJ1bGU7XG5FYXN5TURFLnVuZG8gPSB1bmRvO1xuRWFzeU1ERS5yZWRvID0gcmVkbztcbkVhc3lNREUudG9nZ2xlUHJldmlldyA9IHRvZ2dsZVByZXZpZXc7XG5FYXN5TURFLnRvZ2dsZVNpZGVCeVNpZGUgPSB0b2dnbGVTaWRlQnlTaWRlO1xuRWFzeU1ERS50b2dnbGVGdWxsU2NyZWVuID0gdG9nZ2xlRnVsbFNjcmVlbjtcblxuLyoqXG4gKiBCaW5kIGluc3RhbmNlIG1ldGhvZHMgZm9yIGV4cG9ydHMuXG4gKi9cbkVhc3lNREUucHJvdG90eXBlLnRvZ2dsZUJvbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdG9nZ2xlQm9sZCh0aGlzKTtcbn07XG5FYXN5TURFLnByb3RvdHlwZS50b2dnbGVJdGFsaWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdG9nZ2xlSXRhbGljKHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLnRvZ2dsZVN0cmlrZXRocm91Z2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdG9nZ2xlU3RyaWtldGhyb3VnaCh0aGlzKTtcbn07XG5FYXN5TURFLnByb3RvdHlwZS50b2dnbGVCbG9ja3F1b3RlID0gZnVuY3Rpb24gKCkge1xuICAgIHRvZ2dsZUJsb2NrcXVvdGUodGhpcyk7XG59O1xuRWFzeU1ERS5wcm90b3R5cGUudG9nZ2xlSGVhZGluZ1NtYWxsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdG9nZ2xlSGVhZGluZ1NtYWxsZXIodGhpcyk7XG59O1xuRWFzeU1ERS5wcm90b3R5cGUudG9nZ2xlSGVhZGluZ0JpZ2dlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0b2dnbGVIZWFkaW5nQmlnZ2VyKHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLnRvZ2dsZUhlYWRpbmcxID0gZnVuY3Rpb24gKCkge1xuICAgIHRvZ2dsZUhlYWRpbmcxKHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLnRvZ2dsZUhlYWRpbmcyID0gZnVuY3Rpb24gKCkge1xuICAgIHRvZ2dsZUhlYWRpbmcyKHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLnRvZ2dsZUhlYWRpbmczID0gZnVuY3Rpb24gKCkge1xuICAgIHRvZ2dsZUhlYWRpbmczKHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLnRvZ2dsZUhlYWRpbmc0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRvZ2dsZUhlYWRpbmc0KHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLnRvZ2dsZUhlYWRpbmc1ID0gZnVuY3Rpb24gKCkge1xuICAgIHRvZ2dsZUhlYWRpbmc1KHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLnRvZ2dsZUhlYWRpbmc2ID0gZnVuY3Rpb24gKCkge1xuICAgIHRvZ2dsZUhlYWRpbmc2KHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLnRvZ2dsZUNvZGVCbG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICB0b2dnbGVDb2RlQmxvY2sodGhpcyk7XG59O1xuRWFzeU1ERS5wcm90b3R5cGUudG9nZ2xlVW5vcmRlcmVkTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0b2dnbGVVbm9yZGVyZWRMaXN0KHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLnRvZ2dsZU9yZGVyZWRMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRvZ2dsZU9yZGVyZWRMaXN0KHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLmNsZWFuQmxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2xlYW5CbG9jayh0aGlzKTtcbn07XG5FYXN5TURFLnByb3RvdHlwZS5kcmF3TGluayA9IGZ1bmN0aW9uICgpIHtcbiAgICBkcmF3TGluayh0aGlzKTtcbn07XG5FYXN5TURFLnByb3RvdHlwZS5kcmF3SW1hZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgZHJhd0ltYWdlKHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLmRyYXdVcGxvYWRlZEltYWdlID0gZnVuY3Rpb24gKCkge1xuICAgIGRyYXdVcGxvYWRlZEltYWdlKHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLmRyYXdUYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBkcmF3VGFibGUodGhpcyk7XG59O1xuRWFzeU1ERS5wcm90b3R5cGUuZHJhd0hvcml6b250YWxSdWxlID0gZnVuY3Rpb24gKCkge1xuICAgIGRyYXdIb3Jpem9udGFsUnVsZSh0aGlzKTtcbn07XG5FYXN5TURFLnByb3RvdHlwZS51bmRvID0gZnVuY3Rpb24gKCkge1xuICAgIHVuZG8odGhpcyk7XG59O1xuRWFzeU1ERS5wcm90b3R5cGUucmVkbyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZWRvKHRoaXMpO1xufTtcbkVhc3lNREUucHJvdG90eXBlLnRvZ2dsZVByZXZpZXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdG9nZ2xlUHJldmlldyh0aGlzKTtcbn07XG5FYXN5TURFLnByb3RvdHlwZS50b2dnbGVTaWRlQnlTaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRvZ2dsZVNpZGVCeVNpZGUodGhpcyk7XG59O1xuRWFzeU1ERS5wcm90b3R5cGUudG9nZ2xlRnVsbFNjcmVlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB0b2dnbGVGdWxsU2NyZWVuKHRoaXMpO1xufTtcblxuRWFzeU1ERS5wcm90b3R5cGUuaXNQcmV2aWV3QWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjbSA9IHRoaXMuY29kZW1pcnJvcjtcbiAgICB2YXIgd3JhcHBlciA9IGNtLmdldFdyYXBwZXJFbGVtZW50KCk7XG4gICAgdmFyIHByZXZpZXcgPSB3cmFwcGVyLmxhc3RDaGlsZDtcblxuICAgIHJldHVybiBwcmV2aWV3LmNsYXNzTGlzdC5jb250YWlucygnZWRpdG9yLXByZXZpZXctYWN0aXZlJyk7XG59O1xuXG5FYXN5TURFLnByb3RvdHlwZS5pc1NpZGVCeVNpZGVBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNtID0gdGhpcy5jb2RlbWlycm9yO1xuICAgIHZhciB3cmFwcGVyID0gY20uZ2V0V3JhcHBlckVsZW1lbnQoKTtcbiAgICB2YXIgcHJldmlldyA9IHdyYXBwZXIubmV4dFNpYmxpbmc7XG5cbiAgICByZXR1cm4gcHJldmlldy5jbGFzc0xpc3QuY29udGFpbnMoJ2VkaXRvci1wcmV2aWV3LWFjdGl2ZS1zaWRlJyk7XG59O1xuXG5FYXN5TURFLnByb3RvdHlwZS5pc0Z1bGxzY3JlZW5BY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNtID0gdGhpcy5jb2RlbWlycm9yO1xuXG4gICAgcmV0dXJuIGNtLmdldE9wdGlvbignZnVsbFNjcmVlbicpO1xufTtcblxuRWFzeU1ERS5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNtID0gdGhpcy5jb2RlbWlycm9yO1xuXG4gICAgcmV0dXJuIGdldFN0YXRlKGNtKTtcbn07XG5cbkVhc3lNREUucHJvdG90eXBlLnRvVGV4dEFyZWEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNtID0gdGhpcy5jb2RlbWlycm9yO1xuICAgIHZhciB3cmFwcGVyID0gY20uZ2V0V3JhcHBlckVsZW1lbnQoKTtcbiAgICB2YXIgZWFzeU1ERUNvbnRhaW5lciA9IHdyYXBwZXIucGFyZW50Tm9kZTtcblxuICAgIGlmIChlYXN5TURFQ29udGFpbmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmd1aS50b29sYmFyKSB7XG4gICAgICAgICAgICBlYXN5TURFQ29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuZ3VpLnRvb2xiYXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmd1aS5zdGF0dXNiYXIpIHtcbiAgICAgICAgICAgIGVhc3lNREVDb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5ndWkuc3RhdHVzYmFyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ndWkuc2lkZUJ5U2lkZSkge1xuICAgICAgICAgICAgZWFzeU1ERUNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLmd1aS5zaWRlQnlTaWRlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFVud3JhcCBlYXN5TURFY29udGFpbmVyIGJlZm9yZSBjb2RlbWlycm9yIHRvVGV4dEFyZWEoKSBjYWxsXG4gICAgZWFzeU1ERUNvbnRhaW5lci5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh3cmFwcGVyLCBlYXN5TURFQ29udGFpbmVyKTtcbiAgICBlYXN5TURFQ29udGFpbmVyLnJlbW92ZSgpO1xuXG4gICAgY20udG9UZXh0QXJlYSgpO1xuXG4gICAgaWYgKHRoaXMuYXV0b3NhdmVUaW1lb3V0SWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuYXV0b3NhdmVUaW1lb3V0SWQpO1xuICAgICAgICB0aGlzLmF1dG9zYXZlVGltZW91dElkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNsZWFyQXV0b3NhdmVkVmFsdWUoKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVhc3lNREU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/easymde/src/js/easymde.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/easymde/dist/easymde.min.css":
/*!***************************************************!*\
  !*** ./node_modules/easymde/dist/easymde.min.css ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"17bd888c94c1\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWFzeW1kZS9kaXN0L2Vhc3ltZGUubWluLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLEtBQVUsRUFBRSxFQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lYXN5bWRlL2Rpc3QvZWFzeW1kZS5taW4uY3NzP2RkNzQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCIxN2JkODg4Yzk0YzFcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/easymde/dist/easymde.min.css\n");

/***/ })

};
;